From 0ed15b0ef833fd9d7587f572c7cd8598a84be52a Mon Sep 17 00:00:00 2001
From: Miao Wang <shankerwangmiao@gmail.com>
Date: Wed, 17 Jul 2024 09:03:32 +0800
Subject: [PATCH 28/33] loongarch: basic boot support for legacy firmware

The addresses passed from legacy firmware in efi system tables, the
initrd table, the efi system memory mapping table are virtual addresses.
This patch converts all that addresses back to physical addresses, to
make sure all the following booting processes can run smoothly like on
modern firmwares. The conversion happens unconditionally, since physical
addresses passed in by modern firmwares remain unchanged after the
conversion.

In the EFI Stub, the mapping entries given by GetMemoryMap() on legacy
firmwares contain virtual addresses in the phys_addr fields and 0x1xxxx
addresses in the virt_addr fields, causing the later call to
SetVirtualAddressMap() fails. This patch fixes this by correcting the
addresses in the virt_addr fields. This patch detects the existence of
the legacy firmware by reading DMW1 CSR, as done in the legacy loongarch
GRUB port. Only if legacy firmwares detected, this correction happens.

With this patch, the linux kernel is basically able to boot.
---
 arch/loongarch/kernel/efi.c              | 18 ++++++++++++++++++
 arch/loongarch/kernel/mem.c              |  1 +
 drivers/firmware/efi/libstub/loongarch.c | 20 ++++++++++++++++++++
 3 files changed, 39 insertions(+)

diff --git a/arch/loongarch/kernel/efi.c b/arch/loongarch/kernel/efi.c
index 9fc10cea21e10..201db70ac995f 100644
--- a/arch/loongarch/kernel/efi.c
+++ b/arch/loongarch/kernel/efi.c
@@ -87,6 +87,23 @@ static void __init init_screen_info(void)
 	memblock_reserve(screen_info.lfb_base, screen_info.lfb_size);
 }
 
+static void __init fix_initrd_table(const efi_config_table_t *config_tables,
+				    int count)
+{
+	for(int i = 0; i < count; i++) {
+		if (efi_guidcmp(config_tables[i].guid,
+				LINUX_EFI_INITRD_MEDIA_GUID) == 0) {
+			struct linux_efi_initrd *tbl =
+				early_memremap((u64)config_tables[i].table, sizeof(*tbl));
+			if (tbl) {
+				tbl->base = TO_PHYS(tbl->base);
+				early_memunmap(tbl, sizeof(*tbl));
+			}
+			break;
+		}
+	}
+}
+
 void __init efi_init(void)
 {
 	int size;
@@ -110,6 +127,7 @@ void __init efi_init(void)
 
 	size = sizeof(efi_config_table_t);
 	config_tables = early_memremap(efi_config_table, efi_nr_tables * size);
+	fix_initrd_table(config_tables, efi_systab->nr_tables);
 	efi_config_parse_tables(config_tables, efi_systab->nr_tables, arch_tables);
 	early_memunmap(config_tables, efi_nr_tables * size);
 
diff --git a/arch/loongarch/kernel/mem.c b/arch/loongarch/kernel/mem.c
index aed901c57fb43..86d37a447eec1 100644
--- a/arch/loongarch/kernel/mem.c
+++ b/arch/loongarch/kernel/mem.c
@@ -19,6 +19,7 @@ void __init memblock_init(void)
 	/* Parse memory information */
 	for_each_efi_memory_desc(md) {
 		mem_type = md->type;
+		md->phys_addr = TO_PHYS(md->phys_addr);
 		mem_start = md->phys_addr;
 		mem_size = md->num_pages << EFI_PAGE_SHIFT;
 		mem_end = mem_start + mem_size;
diff --git a/drivers/firmware/efi/libstub/loongarch.c b/drivers/firmware/efi/libstub/loongarch.c
index d0ef93551c44f..bd2e20c0cf423 100644
--- a/drivers/firmware/efi/libstub/loongarch.c
+++ b/drivers/firmware/efi/libstub/loongarch.c
@@ -23,6 +23,8 @@ struct exit_boot_struct {
 	int			runtime_entry_count;
 };
 
+static int is_oldworld = 0;
+
 static efi_status_t exit_boot_func(struct efi_boot_memmap *map, void *priv)
 {
 	struct exit_boot_struct *p = priv;
@@ -35,9 +37,25 @@ static efi_status_t exit_boot_func(struct efi_boot_memmap *map, void *priv)
 	efi_get_virtmap(map->map, map->map_size, map->desc_size,
 			p->runtime_map, &p->runtime_entry_count);
 
+	if (is_oldworld) {
+		for(int l = 0; l < p->runtime_entry_count * map->desc_size; l += map->desc_size) {
+			efi_memory_desc_t *entry = (void *)(p->runtime_map) + l;
+			entry->virt_addr = TO_CACHE(entry->virt_addr);
+		}
+	}
+
 	return EFI_SUCCESS;
 }
 
+static void detect_oldworld(void)
+{
+	is_oldworld = !!(csr_read64(LOONGARCH_CSR_DMWIN1) & CSR_DMW1_PLV0);
+	efi_debug("is_oldworld: %d\n", is_oldworld);
+	if(is_oldworld) {
+		efi_info("Booting on OldWorld firmware\n");
+	}
+}
+
 unsigned long __weak kernel_entry_address(unsigned long kernel_addr,
 		efi_loaded_image_t *image)
 {
@@ -53,6 +71,8 @@ efi_status_t efi_boot_kernel(void *handle, efi_loaded_image_t *image,
 	efi_status_t status;
 	u32 desc_ver;
 
+	detect_oldworld();
+
 	status = efi_alloc_virtmap(&priv.runtime_map, &desc_size, &desc_ver);
 	if (status != EFI_SUCCESS) {
 		efi_err("Unable to retrieve UEFI memory map.\n");
-- 
2.46.0

