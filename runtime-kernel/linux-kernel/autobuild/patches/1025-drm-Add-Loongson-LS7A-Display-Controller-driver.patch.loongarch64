From 1d48a545eedd9cd03fbe4e0904fdd4fed6333dc3 Mon Sep 17 00:00:00 2001
From: Huacai Chen <chenhc@lemote.com>
Date: Thu, 2 Jun 2022 13:03:13 +0800
Subject: [PATCH 25/43] drm: Add Loongson LS7A Display-Controller driver

Signed-off-by: Huacai Chen <chenhc@lemote.com>
---
 arch/loongarch/configs/loongson3_defconfig    |   1 +
 arch/loongarch/include/uapi/asm/unistd.h      |   1 +
 drivers/firmware/sysfb.c                      |   2 +-
 drivers/gpio/Kconfig                          |   2 +-
 drivers/gpio/gpio-loongson.c                  |   8 +-
 drivers/gpu/drm/Kconfig                       |   2 +
 drivers/gpu/drm/Makefile                      |   1 +
 drivers/gpu/drm/loongson/Kconfig              |  18 +
 drivers/gpu/drm/loongson/Makefile             |  16 +
 drivers/gpu/drm/loongson/loongson_connector.c | 241 +++++
 drivers/gpu/drm/loongson/loongson_crtc.c      | 510 +++++++++++
 drivers/gpu/drm/loongson/loongson_cursor.c    | 188 ++++
 drivers/gpu/drm/loongson/loongson_drv.c       | 641 +++++++++++++
 drivers/gpu/drm/loongson/loongson_drv.h       | 239 +++++
 drivers/gpu/drm/loongson/loongson_encoder.c   | 134 +++
 drivers/gpu/drm/loongson/loongson_i2c.c       | 189 ++++
 drivers/gpu/drm/loongson/loongson_i2c.h       |  43 +
 drivers/gpu/drm/loongson/loongson_irq.c       |  90 ++
 drivers/gpu/drm/loongson/loongson_vbios.c     | 857 ++++++++++++++++++
 drivers/gpu/drm/loongson/loongson_vbios.h     | 283 ++++++
 20 files changed, 3460 insertions(+), 6 deletions(-)
 create mode 100644 drivers/gpu/drm/loongson/Kconfig
 create mode 100644 drivers/gpu/drm/loongson/Makefile
 create mode 100644 drivers/gpu/drm/loongson/loongson_connector.c
 create mode 100644 drivers/gpu/drm/loongson/loongson_crtc.c
 create mode 100644 drivers/gpu/drm/loongson/loongson_cursor.c
 create mode 100644 drivers/gpu/drm/loongson/loongson_drv.c
 create mode 100644 drivers/gpu/drm/loongson/loongson_drv.h
 create mode 100644 drivers/gpu/drm/loongson/loongson_encoder.c
 create mode 100644 drivers/gpu/drm/loongson/loongson_i2c.c
 create mode 100644 drivers/gpu/drm/loongson/loongson_i2c.h
 create mode 100644 drivers/gpu/drm/loongson/loongson_irq.c
 create mode 100644 drivers/gpu/drm/loongson/loongson_vbios.c
 create mode 100644 drivers/gpu/drm/loongson/loongson_vbios.h

diff --git a/arch/loongarch/configs/loongson3_defconfig b/arch/loongarch/configs/loongson3_defconfig
index 9fc93df39f..75fafc65b2 100644
--- a/arch/loongarch/configs/loongson3_defconfig
+++ b/arch/loongarch/configs/loongson3_defconfig
@@ -643,6 +643,7 @@ CONFIG_DRM_AMDGPU_SI=y
 CONFIG_DRM_AMDGPU_CIK=y
 CONFIG_DRM_AMDGPU_USERPTR=y
 CONFIG_DRM_AST=y
+CONFIG_DRM_LOONGSON=y
 CONFIG_DRM_QXL=m
 CONFIG_DRM_VIRTIO_GPU=m
 CONFIG_FB=y
diff --git a/arch/loongarch/include/uapi/asm/unistd.h b/arch/loongarch/include/uapi/asm/unistd.h
index fcb668984f..b344b1f917 100644
--- a/arch/loongarch/include/uapi/asm/unistd.h
+++ b/arch/loongarch/include/uapi/asm/unistd.h
@@ -1,4 +1,5 @@
 /* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
+#define __ARCH_WANT_NEW_STAT
 #define __ARCH_WANT_SYS_CLONE
 #define __ARCH_WANT_SYS_CLONE3
 
diff --git a/drivers/firmware/sysfb.c b/drivers/firmware/sysfb.c
index 3c197db42c..82fcfd29bc 100644
--- a/drivers/firmware/sysfb.c
+++ b/drivers/firmware/sysfb.c
@@ -128,4 +128,4 @@ static __init int sysfb_init(void)
 }
 
 /* must execute after PCI subsystem for EFI quirks */
-device_initcall(sysfb_init);
+subsys_initcall_sync(sysfb_init);
diff --git a/drivers/gpio/Kconfig b/drivers/gpio/Kconfig
index badbe05823..9105784585 100644
--- a/drivers/gpio/Kconfig
+++ b/drivers/gpio/Kconfig
@@ -376,7 +376,7 @@ config GPIO_LOGICVC
 
 config GPIO_LOONGSON
 	bool "Loongson-2/3 GPIO support"
-	depends on CPU_LOONGSON2EF || CPU_LOONGSON64
+	depends on CPU_LOONGSON2EF || CPU_LOONGSON64 || LOONGARCH
 	help
 	  Driver for GPIO functionality on Loongson-2F/3A/3B processors.
 
diff --git a/drivers/gpio/gpio-loongson.c b/drivers/gpio/gpio-loongson.c
index a42145873c..8cac529390 100644
--- a/drivers/gpio/gpio-loongson.c
+++ b/drivers/gpio/gpio-loongson.c
@@ -17,15 +17,15 @@
 #include <linux/platform_device.h>
 #include <linux/bitops.h>
 #include <asm/types.h>
-#include <loongson.h>
+#include <asm/loongson.h>
 
 #define STLS2F_N_GPIO		4
 #define STLS3A_N_GPIO		16
 
-#ifdef CONFIG_CPU_LOONGSON64
-#define LOONGSON_N_GPIO	STLS3A_N_GPIO
-#else
+#ifdef CONFIG_CPU_LOONGSON2EF
 #define LOONGSON_N_GPIO	STLS2F_N_GPIO
+#else
+#define LOONGSON_N_GPIO	STLS3A_N_GPIO
 #endif
 
 /*
diff --git a/drivers/gpu/drm/Kconfig b/drivers/gpu/drm/Kconfig
index dc0f94f02a..ca4fdd2dda 100644
--- a/drivers/gpu/drm/Kconfig
+++ b/drivers/gpu/drm/Kconfig
@@ -285,6 +285,8 @@ source "drivers/gpu/drm/udl/Kconfig"
 
 source "drivers/gpu/drm/ast/Kconfig"
 
+source "drivers/gpu/drm/loongson/Kconfig"
+
 source "drivers/gpu/drm/mgag200/Kconfig"
 
 source "drivers/gpu/drm/armada/Kconfig"
diff --git a/drivers/gpu/drm/Makefile b/drivers/gpu/drm/Makefile
index ab4460fcd6..399725a33c 100644
--- a/drivers/gpu/drm/Makefile
+++ b/drivers/gpu/drm/Makefile
@@ -150,6 +150,7 @@ obj-$(CONFIG_DRM_ROCKCHIP) +=rockchip/
 obj-$(CONFIG_DRM_GMA500) += gma500/
 obj-$(CONFIG_DRM_UDL) += udl/
 obj-$(CONFIG_DRM_AST) += ast/
+obj-$(CONFIG_DRM_LOONGSON) +=loongson/
 obj-$(CONFIG_DRM_ARMADA) += armada/
 obj-$(CONFIG_DRM_ATMEL_HLCDC)	+= atmel-hlcdc/
 obj-y			+= rcar-du/
diff --git a/drivers/gpu/drm/loongson/Kconfig b/drivers/gpu/drm/loongson/Kconfig
new file mode 100644
index 0000000000..3f70666ab3
--- /dev/null
+++ b/drivers/gpu/drm/loongson/Kconfig
@@ -0,0 +1,18 @@
+
+config DRM_LOONGSON
+	tristate "DRM support for LS7A Display Controller"
+	depends on DRM && PCI
+	select FB_CFB_FILLRECT
+	select FB_CFB_COPYAREA
+	select FB_CFB_IMAGEBLIT
+	select DRM_KMS_HELPER
+	select DRM_KMS_FB_HELPER
+	select DRM_GEM_DMA_HELPER
+	default n
+	help
+	  Support the display controllers found on the Loongson's LS7A
+	  bridge.
+
+	  This driver provides no built-in acceleration; acceleration is
+	  performed by Vivante GC1000. This driver provides kernel mode
+	  setting and buffer management to userspace.
diff --git a/drivers/gpu/drm/loongson/Makefile b/drivers/gpu/drm/loongson/Makefile
new file mode 100644
index 0000000000..a527213784
--- /dev/null
+++ b/drivers/gpu/drm/loongson/Makefile
@@ -0,0 +1,16 @@
+#
+# Makefile for the drm device driver.  This driver provides support for the
+# Direct Rendering Infrastructure (DRI)
+#
+
+ccflags-y := -Iinclude/drm
+loongson-y := loongson_drv.o \
+	loongson_i2c.o \
+	loongson_irq.o \
+	loongson_crtc.o \
+	loongson_encoder.o \
+	loongson_connector.o \
+	loongson_cursor.o \
+	loongson_vbios.o
+
+obj-$(CONFIG_DRM_LOONGSON)	+= loongson.o
diff --git a/drivers/gpu/drm/loongson/loongson_connector.c b/drivers/gpu/drm/loongson/loongson_connector.c
new file mode 100644
index 0000000000..721336709a
--- /dev/null
+++ b/drivers/gpu/drm/loongson/loongson_connector.c
@@ -0,0 +1,241 @@
+/*
+ * Copyright (c) 2018 Loongson Technology Co., Ltd.
+ * Authors:
+ *	Chen Zhu <zhuchen@loongson.cn>
+ *	Yaling Fang <fangyaling@loongson.cn>
+ *	Dandan Zhang <zhangdandan@loongson.cn>
+ *	Huacai Chen <chenhc@lemote.com>
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/export.h>
+#include <linux/i2c.h>
+#include <linux/i2c-algo-bit.h>
+#include <linux/pm_runtime.h>
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/drm_probe_helper.h>
+#include <drm/drm_edid.h>
+
+#include "loongson_drv.h"
+
+/**
+ * loongson_connector_best_encoder
+ *
+ * @connector: point to the drm_connector structure
+ *
+ * Select the best encoder for the given connector. Used by both the helpers in
+ * drm_atomic_helper_check_modeset() and legacy CRTC helpers
+ */
+static struct drm_encoder *loongson_connector_best_encoder(struct drm_connector
+						  *connector)
+{
+	struct drm_encoder *encoder;
+
+	/* There is only one encoder per connector */
+	drm_connector_for_each_possible_encoder(connector, encoder)
+		return encoder;
+
+	return NULL;
+}
+
+/**
+ * loongson_get_modes
+ *
+ * @connetcor: central DRM connector control structure
+ *
+ * Fill in all modes currently valid for the sink into the connector->probed_modes list.
+ * It should also update the EDID property by calling drm_connector_update_edid_property().
+ */
+static int loongson_get_modes(struct drm_connector *connector)
+{
+	int id, ret = 0;
+	enum loongson_edid_method ledid_method;
+	struct edid *edid = NULL;
+	struct loongson_connector *lconnector = to_loongson_connector(connector);
+	struct i2c_adapter *adapter = lconnector->i2c->adapter;
+
+	id = drm_connector_index(connector);
+
+	ledid_method = lconnector->edid_method;
+	switch (ledid_method) {
+	case via_i2c:
+	case via_encoder:
+	default:
+		edid = drm_get_edid(connector, adapter);
+		break;
+	case via_vbios:
+		edid = kmalloc(EDID_LENGTH * 2, GFP_KERNEL);
+		memcpy(edid, lconnector->vbios_edid, EDID_LENGTH * 2);
+	}
+
+	if (edid) {
+		drm_connector_update_edid_property(connector, edid);
+		ret = drm_add_edid_modes(connector, edid);
+		kfree(edid);
+	} else {
+		ret += drm_add_modes_noedid(connector, 1920, 1080);
+		drm_set_preferred_mode(connector, 1024, 768);
+	}
+
+	return ret;
+}
+
+static bool is_connected(struct loongson_connector *lconnector)
+{
+	unsigned char start = 0x0;
+	struct i2c_adapter *adapter;
+	struct i2c_msg msgs = {
+		.addr = DDC_ADDR,
+		.len = 1,
+		.flags = 0,
+		.buf = &start,
+	};
+
+	if (!lconnector->i2c)
+		return false;
+
+	adapter = lconnector->i2c->adapter;
+	if (i2c_transfer(adapter, &msgs, 1) < 1) {
+		DRM_DEBUG_KMS("display-%d not connect\n", lconnector->id);
+		return false;
+	}
+
+	return true;
+}
+
+/**
+ * loongson_connector_detect
+ *
+ * @connector: point to drm_connector
+ * @force: bool
+ *
+ * Check to see if anything is attached to the connector.
+ * The parameter force is set to false whilst polling,
+ * true when checking the connector due to a user request
+ */
+static enum drm_connector_status loongson_connector_detect(struct drm_connector
+						   *connector, bool force)
+{
+	int r;
+	enum drm_connector_status ret = connector_status_connected;
+	struct loongson_connector *lconnector = to_loongson_connector(connector);
+
+	DRM_DEBUG("loongson_connector_detect connector_id=%d, ledid_method=%d\n",
+			drm_connector_index(connector), lconnector->edid_method);
+
+	if (lconnector->edid_method != via_vbios) {
+		r = pm_runtime_get_sync(connector->dev->dev);
+		if (r < 0)
+			return connector_status_disconnected;
+
+		if (is_connected(lconnector))
+			ret = connector_status_connected;
+		else
+			ret = connector_status_disconnected;
+
+		pm_runtime_mark_last_busy(connector->dev->dev);
+		pm_runtime_put_autosuspend(connector->dev->dev);
+	}
+
+	return ret;
+}
+
+/**
+ * These provide the minimum set of functions required to handle a connector
+ *
+ * Helper operations for connectors.These functions are used
+ * by the atomic and legacy modeset helpers and by the probe helpers.
+ */
+static const struct drm_connector_helper_funcs loongson_connector_helper_funcs = {
+        .get_modes = loongson_get_modes,
+        .best_encoder = loongson_connector_best_encoder,
+};
+
+/**
+ * These provide the minimum set of functions required to handle a connector
+ *
+ * Control connectors on a given device.
+ * The functions below allow the core DRM code to control connectors,
+ * enumerate available modes and so on.
+ */
+static const struct drm_connector_funcs loongson_connector_funcs = {
+	.dpms = drm_helper_connector_dpms,
+	.detect = loongson_connector_detect,
+	.fill_modes = drm_helper_probe_single_connector_modes,
+	.destroy = drm_connector_cleanup,
+	.reset = drm_atomic_helper_connector_reset,
+	.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,
+	.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,
+};
+
+static const unsigned short normal_i2c[] = { 0x50, I2C_CLIENT_END };
+
+
+/**
+ * loongson_connector_init
+ *
+ * @dev: drm device
+ * @connector_id:
+ *
+ * Vga is the interface between host and monitor
+ * This function is to init vga
+ */
+struct drm_connector *loongson_connector_init(struct drm_device *dev, unsigned int index)
+{
+	struct i2c_adapter *adapter;
+	struct i2c_client *ddc_client;
+	struct drm_connector *connector;
+	struct loongson_encoder *loongson_encoder;
+	struct loongson_connector *loongson_connector;
+	struct loongson_drm_device *ldev = (struct loongson_drm_device*)dev->dev_private;
+
+	const struct i2c_board_info ddc_info = {
+		.type = "ddc-dev",
+		.addr = DDC_ADDR,
+		.flags = I2C_CLASS_DDC,
+	};
+
+	loongson_encoder = ldev->mode_info[index].encoder; 
+	adapter = loongson_encoder->i2c->adapter;
+	ddc_client = i2c_new_client_device(adapter, &ddc_info);
+	if (IS_ERR(ddc_client)) {
+		i2c_del_adapter(adapter);
+		DRM_ERROR("Failed to create standard ddc client\n");
+		return NULL;
+	}
+
+	loongson_connector = kzalloc(sizeof(struct loongson_connector), GFP_KERNEL);
+	if (!loongson_connector)
+		return NULL;
+
+	ldev->connector_active0 = 0;
+	ldev->connector_active1 = 0;
+	loongson_connector->id = index;
+	loongson_connector->ldev = ldev;
+	loongson_connector->type = get_connector_type(ldev, index);
+	loongson_connector->i2c_id = get_connector_i2cid(ldev, index);
+	loongson_connector->hotplug = get_hotplug_mode(ldev, index);
+	loongson_connector->edid_method = get_edid_method(ldev, index);
+	if (loongson_connector->edid_method == via_vbios)
+		loongson_connector->vbios_edid = get_vbios_edid(ldev, index);
+
+	loongson_connector->i2c = &ldev->i2c_bus[index];
+	if (!loongson_connector->i2c)
+		DRM_INFO("connector-%d match i2c-%d err\n", index,
+			 loongson_connector->i2c_id);
+
+	connector = &loongson_connector->base;
+
+	drm_connector_helper_add(connector, &loongson_connector_helper_funcs);
+
+	drm_connector_init(dev, connector,
+			   &loongson_connector_funcs, loongson_connector->type);
+
+	drm_connector_register(connector);
+
+	return connector;
+}
diff --git a/drivers/gpu/drm/loongson/loongson_crtc.c b/drivers/gpu/drm/loongson/loongson_crtc.c
new file mode 100644
index 0000000000..9d26873eef
--- /dev/null
+++ b/drivers/gpu/drm/loongson/loongson_crtc.c
@@ -0,0 +1,510 @@
+/*
+ * Copyright (c) 2018 Loongson Technology Co., Ltd.
+ * Authors:
+ *	Chen Zhu <zhuchen@loongson.cn>
+ *	Yaling Fang <fangyaling@loongson.cn>
+ *	Dandan Zhang <zhangdandan@loongson.cn>
+ *	Huacai Chen <chenhc@lemote.com>
+ *	Jiaxun Yang <jiaxun.yang@flygoat.com>
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/delay.h>
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_plane.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/drm_plane_helper.h>
+#include <drm/drm_fb_dma_helper.h>
+#include <drm/drm_fourcc.h>
+#include <drm/drm_framebuffer.h>
+#include <drm/drm_gem_dma_helper.h>
+#include "loongson_drv.h"
+
+/**
+ * This file contains setup code for the CRTC
+ */
+
+DEFINE_SPINLOCK(loongson_crtc_lock);
+
+static int loongson_crtc_enable_vblank(struct drm_crtc *crtc)
+{
+	struct loongson_crtc *lcrtc = to_loongson_crtc(crtc);
+	struct loongson_drm_device *ldev = lcrtc->ldev;
+
+	if(lcrtc->crtc_id == 0) {
+		ldev->int_reg |= (BIT(INT_DVO0_FB_END) << 16);
+	} else {
+		ldev->int_reg |= (BIT(INT_DVO1_FB_END) << 16);
+	}
+
+	spin_lock(&loongson_reglock);
+	writel(ldev->int_reg, ldev->mmio + FB_INT_REG);
+	spin_unlock(&loongson_reglock);
+
+	return 0;
+}
+
+static void loongson_crtc_disable_vblank(struct drm_crtc *crtc)
+{
+	struct loongson_crtc *lcrtc = to_loongson_crtc(crtc);
+	struct loongson_drm_device *ldev = lcrtc->ldev;
+
+
+	if(lcrtc->crtc_id == 0) {
+		ldev->int_reg &= (~BIT(INT_DVO0_FB_END) << 16);
+	} else {
+		ldev->int_reg &= (~BIT(INT_DVO1_FB_END) << 16);
+	}
+
+	spin_lock(&loongson_reglock);
+	writel(ldev->int_reg, ldev->mmio + FB_INT_REG);
+	spin_unlock(&loongson_reglock);
+}
+
+#define PLL_REF_CLK_MHZ    100
+#define PCLK_PRECISION_INDICATOR 10000
+
+/**
+ * cal_freq
+ *
+ * @pixclock: unsigned int
+ * @pll_config: point to the pix_pll structure
+ *
+ * Calculate frequency
+ */
+static unsigned int cal_freq(unsigned int pixclock, struct pix_pll *pll_config)
+{
+	int i, j, loopc_offset;
+	unsigned int refc_set[] = {4, 5, 3};
+	unsigned int prec_set[] = {1, 5, 10, 50, 100};   /*in 1/PCLK_PRECISION_INDICATOR*/
+	unsigned int pstdiv, loopc, refc;
+	unsigned int precision_req, precision;
+	unsigned int loopc_min, loopc_max, loopc_mid;
+	unsigned long long real_dvo, req_dvo;
+
+	/*try precision from high to low*/
+	for (j = 0; j < sizeof(prec_set)/sizeof(int); j++){
+		precision_req = prec_set[j];
+
+		/*try each refc*/
+		for (i = 0; i < sizeof(refc_set)/sizeof(int); i++) {
+			refc = refc_set[i];
+			loopc_min = (1200 / PLL_REF_CLK_MHZ) * refc;  /*1200 / (PLL_REF_CLK_MHZ / refc)*/
+			loopc_max = (3200 / PLL_REF_CLK_MHZ) * refc;  /*3200 / (PLL_REF_CLK_MHZ / refc)*/
+			loopc_mid = (2200 / PLL_REF_CLK_MHZ) * refc;  /*(loopc_min + loopc_max) / 2;*/
+			loopc_offset = -1;
+
+			/*try each loopc*/
+			for (loopc = loopc_mid; (loopc <= loopc_max) && (loopc >= loopc_min); loopc += loopc_offset) {
+				if(loopc_offset < 0)
+					loopc_offset = -loopc_offset;
+				else
+					loopc_offset = -(loopc_offset+1);
+
+				pstdiv = loopc * PLL_REF_CLK_MHZ * 1000 / refc / pixclock;
+				if((pstdiv > 127) || (pstdiv < 1))
+					continue;
+
+				/*real_freq is float type which is not available, but read_freq * pstdiv is available.*/
+				req_dvo  = (pixclock * pstdiv);
+				real_dvo = (loopc * PLL_REF_CLK_MHZ * 1000 / refc);
+				precision = abs(real_dvo * PCLK_PRECISION_INDICATOR / req_dvo - PCLK_PRECISION_INDICATOR);
+
+				if(precision < precision_req){
+					pll_config->l2_div = pstdiv;
+					pll_config->l1_loopc = loopc;
+					pll_config->l1_frefc = refc;
+					if(j > 1)
+						printk("Warning: PIX clock precision degraded to %d / %d\n", precision_req, PCLK_PRECISION_INDICATOR);
+					return 1;
+				}
+			}
+		}
+	}
+	return 0;
+}
+
+/**
+ * config_pll
+ *
+ * @pll_base: represent a long type
+ * @pll_cfg: point to the pix_pll srtucture
+ *
+ * Config pll apply to ls7a
+ */
+static void config_pll(void *pll_base, struct pix_pll *pll_cfg)
+{
+	unsigned long val;
+
+	/* clear sel_pll_out0 */
+	val = readl(pll_base + 0x4);
+	val &= ~(1UL << 8);
+	writel(val, pll_base + 0x4);
+	/* set pll_pd */
+	val = readl(pll_base + 0x4);
+	val |= (1UL << 13);
+	writel(val, pll_base + 0x4);
+	/* clear set_pll_param */
+	val = readl(pll_base + 0x4);
+	val &= ~(1UL << 11);
+	writel(val, pll_base + 0x4);
+	/* clear old value & config new value */
+	val = readl(pll_base + 0x4);
+	val &= ~(0x7fUL << 0);
+	val |= (pll_cfg->l1_frefc << 0); /* refc */
+	writel(val, pll_base + 0x4);
+	val = readl(pll_base + 0x0);
+	val &= ~(0x7fUL << 0);
+	val |= (pll_cfg->l2_div << 0);   /* div */
+	val &= ~(0x1ffUL << 21);
+	val |= (pll_cfg->l1_loopc << 21);/* loopc */
+	writel(val, pll_base + 0x0);
+	/* set set_pll_param */
+	val = readl(pll_base + 0x4);
+	val |= (1UL << 11);
+	writel(val, pll_base + 0x4);
+	/* clear pll_pd */
+	val = readl(pll_base + 0x4);
+	val &= ~(1UL << 13);
+	writel(val, pll_base + 0x4);
+	/* wait pll lock */
+	while(!(readl(pll_base + 0x4) & 0x80))
+		cpu_relax();
+	/* set sel_pll_out0 */
+	val = readl(pll_base + 0x4);
+	val |= (1UL << 8);
+	writel(val, pll_base + 0x4);
+}
+
+static void loongson_config_pll(int id, unsigned int pix_freq)
+{
+	unsigned int out;
+	struct pix_pll pll_cfg;
+
+	out = cal_freq(pix_freq, &pll_cfg);
+	if (id == 0)
+		config_pll(LS7A_PIX0_PLL, &pll_cfg);
+	else
+		config_pll(LS7A_PIX1_PLL, &pll_cfg);
+}
+
+/**
+ * These provide the minimum set of functions required to handle a CRTC
+ * Each driver is responsible for filling out this structure at startup time
+ *
+ * The drm_crtc_funcs structure is the central CRTC management structure
+ * in the DRM. Each CRTC controls one or more connectors
+ */
+static const struct drm_crtc_funcs loongson_swcursor_crtc_funcs = {
+	.destroy = drm_crtc_cleanup,
+	.set_config = drm_atomic_helper_set_config,
+	.page_flip = drm_atomic_helper_page_flip,
+	.reset = drm_atomic_helper_crtc_reset,
+	.atomic_duplicate_state = drm_atomic_helper_crtc_duplicate_state,
+	.atomic_destroy_state = drm_atomic_helper_crtc_destroy_state,
+	.enable_vblank = loongson_crtc_enable_vblank,
+	.disable_vblank = loongson_crtc_disable_vblank,
+};
+
+static const struct drm_crtc_funcs loongson_hwcursor_crtc_funcs = {
+	.cursor_set2 = loongson_crtc_cursor_set2,
+	.cursor_move = loongson_crtc_cursor_move,
+	.destroy = drm_crtc_cleanup,
+	.set_config = drm_atomic_helper_set_config,
+	.page_flip = drm_atomic_helper_page_flip,
+	.reset = drm_atomic_helper_crtc_reset,
+	.atomic_duplicate_state = drm_atomic_helper_crtc_duplicate_state,
+	.atomic_destroy_state = drm_atomic_helper_crtc_destroy_state,
+	.enable_vblank = loongson_crtc_enable_vblank,
+	.disable_vblank = loongson_crtc_disable_vblank,
+};
+
+static const uint32_t loongson_formats[] = {
+	DRM_FORMAT_RGB565,
+	DRM_FORMAT_RGB888,
+	DRM_FORMAT_XRGB8888,
+	DRM_FORMAT_ARGB8888,
+};
+
+static const uint64_t loongson_format_modifiers[] = {
+	DRM_FORMAT_MOD_LINEAR,
+	DRM_FORMAT_MOD_INVALID
+};
+
+static enum drm_mode_status loongson_crtc_mode_valid(struct drm_crtc *crtc,
+						    const struct drm_display_mode *mode)
+{
+	int id = crtc->index;
+	struct drm_device *dev = crtc->dev;
+	struct loongson_drm_device *ldev = (struct loongson_drm_device*)dev->dev_private;
+
+	if (mode->hdisplay > get_crtc_max_width(ldev, id))
+		return MODE_BAD;
+	if (mode->vdisplay > get_crtc_max_height(ldev, id))
+		return MODE_BAD;
+	if (ldev->num_crtc == 1) {
+		if (mode->hdisplay % 16)
+			return MODE_BAD;
+	} else {
+		if (mode->hdisplay % 64)
+			return MODE_BAD;
+	}
+
+	return MODE_OK;
+}
+
+u32 crtc_read(struct loongson_crtc *lcrtc, u32 offset)
+{
+	struct loongson_drm_device *ldev = lcrtc->ldev;
+	return readl(ldev->mmio + offset + (lcrtc->crtc_id * CRTC_REG_OFFSET));
+}
+
+void crtc_write(struct loongson_crtc *lcrtc, u32 offset, u32 val)
+{
+	struct loongson_drm_device *ldev = lcrtc->ldev;
+	writel(val, ldev->mmio + offset + (lcrtc->crtc_id * CRTC_REG_OFFSET));
+}
+
+static void loongson_crtc_mode_set_nofb(struct drm_crtc *crtc)
+{
+	unsigned int hr, hss, hse, hfl;
+	unsigned int vr, vss, vse, vfl;
+	unsigned int pix_freq;
+	unsigned long flags;
+	struct loongson_crtc *lcrtc = to_loongson_crtc(crtc);
+	struct drm_display_mode *mode = &crtc->state->adjusted_mode;
+
+	hr	= mode->hdisplay;
+	hss	= mode->hsync_start;
+	hse	= mode->hsync_end;
+	hfl	= mode->htotal;
+
+	vr	= mode->vdisplay;
+	vss	= mode->vsync_start;
+	vse	= mode->vsync_end;
+	vfl	= mode->vtotal;
+
+	pix_freq = mode->clock;
+
+	DRM_DEBUG("crtc_id = %d, hr = %d, hss = %d, hse = %d, hfl = %d, vr = %d, vss = %d, vse = %d, vfl = %d, pix_freq = %d,\n",
+			lcrtc->crtc_id, hr, hss, hse, hfl, vr, vss, vse, vfl, pix_freq);
+
+	spin_lock_irqsave(&loongson_reglock, flags);
+	crtc_write(lcrtc, FB_DITCFG_DVO_REG, 0);
+	crtc_write(lcrtc, FB_DITTAB_LO_DVO_REG, 0);
+	crtc_write(lcrtc, FB_DITTAB_HI_DVO_REG, 0);
+	crtc_write(lcrtc, FB_PANCFG_DVO_REG, 0x80001311);
+	crtc_write(lcrtc, FB_PANTIM_DVO_REG, 0);
+
+	crtc_write(lcrtc, FB_HDISPLAY_DVO_REG, (mode->crtc_htotal << 16) | mode->crtc_hdisplay);
+	crtc_write(lcrtc, FB_HSYNC_DVO_REG, 0x40000000 | (mode->crtc_hsync_end << 16) | mode->crtc_hsync_start);
+
+	crtc_write(lcrtc, FB_VDISPLAY_DVO_REG, (mode->crtc_vtotal << 16) | mode->crtc_vdisplay);
+	crtc_write(lcrtc, FB_VSYNC_DVO_REG, 0x40000000 | (mode->crtc_vsync_end << 16) | mode->crtc_vsync_start);
+
+	crtc_write(lcrtc, FB_STRI_DVO_REG, (crtc->primary->state->fb->pitches[0] + 255) & ~255);
+
+	DRM_DEBUG("Stride: %x\n",(crtc->primary->state->fb->pitches[0] + 255) & ~255);
+
+	switch (crtc->primary->state->fb->format->format) {
+	case DRM_FORMAT_RGB565:
+		lcrtc->cfg_reg |= 0x3;
+		crtc_write(lcrtc, FB_CFG_DVO_REG, lcrtc->cfg_reg);
+		break;
+	case DRM_FORMAT_RGB888:
+	default:
+		lcrtc->cfg_reg |= 0x4;
+		crtc_write(lcrtc, FB_CFG_DVO_REG, lcrtc->cfg_reg);
+		break;
+	}
+	spin_unlock_irqrestore(&loongson_reglock, flags);
+
+	loongson_config_pll(lcrtc->crtc_id, mode->clock);
+}
+
+static void loongson_crtc_atomic_enable(struct drm_crtc *crtc,
+				       struct drm_atomic_state *state)
+{
+	unsigned long flags;
+	struct loongson_crtc *lcrtc = to_loongson_crtc(crtc);
+
+	if (lcrtc->cfg_reg & CFG_ENABLE)
+		goto vblank_on;
+
+	lcrtc->cfg_reg |= CFG_ENABLE;
+	spin_lock_irqsave(&loongson_reglock, flags);
+	crtc_write(lcrtc, FB_CFG_DVO_REG, lcrtc->cfg_reg);
+	spin_unlock_irqrestore(&loongson_reglock, flags);
+
+vblank_on:
+	drm_crtc_vblank_on(crtc);
+}
+
+static void loongson_crtc_atomic_disable(struct drm_crtc *crtc,
+					struct drm_atomic_state *state)
+{
+	unsigned long flags;
+	struct loongson_crtc *lcrtc = to_loongson_crtc(crtc);
+
+	lcrtc->cfg_reg &= ~CFG_ENABLE;
+	spin_lock_irqsave(&loongson_reglock, flags);
+	crtc_write(lcrtc, FB_CFG_DVO_REG, lcrtc->cfg_reg);
+	spin_unlock_irqrestore(&loongson_reglock, flags);
+
+	spin_lock_irq(&crtc->dev->event_lock);
+	if (crtc->state->event) {
+		drm_crtc_send_vblank_event(crtc, crtc->state->event);
+		crtc->state->event = NULL;
+	}
+	spin_unlock_irq(&crtc->dev->event_lock);
+
+	drm_crtc_vblank_off(crtc);
+}
+
+static void loongson_crtc_atomic_flush(struct drm_crtc *crtc,
+				  struct drm_atomic_state *state)
+{
+	struct drm_pending_vblank_event *event = crtc->state->event;
+
+	if (event) {
+		crtc->state->event = NULL;
+
+		spin_lock_irq(&crtc->dev->event_lock);
+		if (drm_crtc_vblank_get(crtc) == 0)
+			drm_crtc_arm_vblank_event(crtc, event);
+		else
+			drm_crtc_send_vblank_event(crtc, event);
+		spin_unlock_irq(&crtc->dev->event_lock);
+	}
+}
+
+static void loongson_plane_atomic_update(struct drm_plane *plane,
+					 struct drm_atomic_state *state)
+{
+	int id, clonemode;
+	unsigned int pitch;
+	unsigned long flags;
+	struct loongson_crtc *lcrtc;
+	struct loongson_drm_device *ldev;
+	struct drm_plane_state *pstate = plane->state;
+
+	if (!pstate->crtc || !pstate->fb)
+		return;
+
+	pitch = pstate->fb->pitches[0];
+	lcrtc = to_loongson_crtc(pstate->crtc);
+	ldev = lcrtc->ldev;
+	id = lcrtc->crtc_id;
+	clonemode = clone_mode(ldev);
+
+	/* CRTC1 cloned from CRTC0 in clone mode */
+	if (clonemode)
+		ldev->lcrtc[1].cfg_reg |= CFG_PANELSWITCH;
+	else
+		ldev->lcrtc[1].cfg_reg &= ~CFG_PANELSWITCH;
+
+	spin_lock_irqsave(&loongson_reglock, flags);
+	crtc_write(lcrtc, FB_STRI_DVO_REG, (pitch + 255) & ~255);
+	if (crtc_read(lcrtc, FB_CFG_DVO_REG) & CFG_FBNUM)
+		crtc_write(lcrtc, FB_ADDR0_DVO_REG, drm_fb_dma_get_gem_addr(pstate->fb, pstate, 0));
+	else
+		crtc_write(lcrtc, FB_ADDR1_DVO_REG, drm_fb_dma_get_gem_addr(pstate->fb, pstate, 0));
+
+	lcrtc->cfg_reg |= CFG_ENABLE;
+	crtc_write(lcrtc, FB_CFG_DVO_REG, lcrtc->cfg_reg | CFG_FBSWITCH);
+	if (clonemode) {
+		if (id)
+			crtc_write(&ldev->lcrtc[0], FB_CFG_DVO_REG, ldev->lcrtc[0].cfg_reg | CFG_ENABLE);
+		else
+			crtc_write(&ldev->lcrtc[1], FB_CFG_DVO_REG, ldev->lcrtc[1].cfg_reg | CFG_ENABLE);
+	}
+	spin_unlock_irqrestore(&loongson_reglock, flags);
+
+	udelay(2500);
+}
+
+/**
+ * These provide the minimum set of functions required to handle a CRTC
+ *
+ * The drm_crtc_helper_funcs is a helper operations for CRTC
+ */
+static const struct drm_crtc_helper_funcs loongson_crtc_helper_funcs = {
+	.mode_valid = loongson_crtc_mode_valid,
+	.mode_set_nofb	= loongson_crtc_mode_set_nofb,
+	.atomic_enable	= loongson_crtc_atomic_enable,
+	.atomic_disable	= loongson_crtc_atomic_disable,
+	.atomic_flush	= loongson_crtc_atomic_flush,
+};
+
+static void loongson_plane_destroy(struct drm_plane *plane)
+{
+	drm_plane_cleanup(plane);
+}
+
+static bool loongson_format_mod_supported(struct drm_plane *plane,
+					   uint32_t format, uint64_t modifier)
+{
+	return (modifier == DRM_FORMAT_MOD_LINEAR);
+}
+
+static const struct drm_plane_funcs loongson_plane_funcs = {
+	.atomic_duplicate_state = drm_atomic_helper_plane_duplicate_state,
+	.atomic_destroy_state = drm_atomic_helper_plane_destroy_state,
+	.destroy = loongson_plane_destroy,
+	.disable_plane = drm_atomic_helper_disable_plane,
+	.reset = drm_atomic_helper_plane_reset,
+	.update_plane = drm_atomic_helper_update_plane,
+	.format_mod_supported = loongson_format_mod_supported,
+};
+
+static const struct drm_plane_helper_funcs loongson_plane_helper_funcs = {
+	.atomic_update = loongson_plane_atomic_update,
+};
+
+/**
+ * loongosn_crtc_init
+ *
+ * @ldev: point to the loongson_drm_device structure
+ *
+ * Init CRTC
+ */
+int loongson_crtc_init(struct loongson_drm_device *ldev)
+{
+	int i, ret;
+	extern bool hw_cursor;
+
+	for(i=0;i<ldev->num_crtc;i++){
+		ldev->lcrtc[i].ldev = ldev;
+		ldev->lcrtc[i].crtc_id = i;
+
+		ldev->lcrtc[i].cfg_reg = CFG_RESET;
+		ldev->lcrtc[i].primary = devm_kzalloc(ldev->dev->dev, sizeof(*ldev->lcrtc[i].primary), GFP_KERNEL);
+		if (!ldev->lcrtc[i].primary)
+			return -ENOMEM;
+
+		ret = drm_universal_plane_init(ldev->dev, ldev->lcrtc[i].primary, BIT(i), &loongson_plane_funcs,
+				       loongson_formats, ARRAY_SIZE(loongson_formats),
+				       loongson_format_modifiers, DRM_PLANE_TYPE_PRIMARY, NULL);
+		if (ret)
+			return ret;
+
+		drm_plane_helper_add(ldev->lcrtc[i].primary, &loongson_plane_helper_funcs);
+
+		if (hw_cursor)
+			ret = drm_crtc_init_with_planes(ldev->dev, &ldev->lcrtc[i].base,ldev->lcrtc[i].primary,
+					NULL, &loongson_hwcursor_crtc_funcs, NULL);
+		else
+			ret = drm_crtc_init_with_planes(ldev->dev, &ldev->lcrtc[i].base,ldev->lcrtc[i].primary,
+					NULL, &loongson_swcursor_crtc_funcs, NULL);
+		if (ret) {
+			loongson_plane_destroy(ldev->lcrtc[i].primary);
+			return ret;
+		}
+		drm_crtc_helper_add(&ldev->lcrtc[i].base, &loongson_crtc_helper_funcs);
+	}
+
+	return 0;
+}
diff --git a/drivers/gpu/drm/loongson/loongson_cursor.c b/drivers/gpu/drm/loongson/loongson_cursor.c
new file mode 100644
index 0000000000..ca6a2a5cf2
--- /dev/null
+++ b/drivers/gpu/drm/loongson/loongson_cursor.c
@@ -0,0 +1,188 @@
+/*
+ * Copyright (c) 2018 Loongson Technology Co., Ltd.
+ * Authors:
+ *	Chen Zhu <zhuchen@loongson.cn>
+ *	Yaling Fang <fangyaling@loongson.cn>
+ *	Dandan Zhang <zhangdandan@loongson.cn>
+ *	Huacai Chen <chenhc@lemote.com>
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <drm/drm_gem_dma_helper.h>
+#include "loongson_drv.h"
+
+/*
+  Hide the cursor off screen. We can't disable the cursor hardware because it
+  takes too long to re-activate and causes momentary corruption
+*/
+static void loongson_hide_cursor(struct drm_crtc *crtc)
+{
+	unsigned long flags;
+	volatile void __iomem *base;
+	struct drm_device *dev = crtc->dev;
+	struct loongson_drm_device *ldev = (struct loongson_drm_device *)dev->dev_private;
+	struct loongson_crtc *loongson_crtc = to_loongson_crtc(crtc);
+	unsigned int tmp, crtc_id = loongson_crtc->crtc_id;
+
+	base = ldev->mmio;
+	tmp = readl(base + FB_CUR_CFG_REG);
+	tmp &= ~0xff;
+	if (clone_mode(ldev)) {
+		spin_lock_irqsave(&loongson_reglock, flags);
+		writel(tmp | 0x00, base + FB_CUR_CFG_REG);
+		spin_unlock_irqrestore(&loongson_reglock, flags);
+		ldev->cursor_showed = false;
+	} else {
+		if (ldev->cursor_crtc_id != crtc_id)
+			return;
+
+		spin_lock_irqsave(&loongson_reglock, flags);
+		if (crtc_id) {
+			writel(tmp | 0x10, base + FB_CUR_CFG_REG);
+		} else {
+			writel(tmp | 0x00, base + FB_CUR_CFG_REG);
+		}
+		spin_unlock_irqrestore(&loongson_reglock, flags);
+		ldev->cursor_showed = false;
+	}
+}
+
+static void loongson_show_cursor(struct drm_crtc *crtc)
+{
+	unsigned long flags;
+	volatile void __iomem *base;
+	struct drm_device *dev = crtc->dev;
+	struct loongson_drm_device *ldev = (struct loongson_drm_device *)dev->dev_private;
+	struct loongson_crtc *loongson_crtc = to_loongson_crtc(crtc);
+	unsigned int crtc_id = loongson_crtc->crtc_id;
+
+	base = ldev->mmio;
+	if (clone_mode(ldev)) {
+		spin_lock_irqsave(&loongson_reglock, flags);
+		writel(0x00050202, base + FB_CUR_CFG_REG);
+		spin_unlock_irqrestore(&loongson_reglock, flags);
+		ldev->cursor_crtc_id = 0;
+		ldev->cursor_showed = true;
+	} else {
+		if (ldev->cursor_crtc_id == crtc_id) {
+			spin_lock_irqsave(&loongson_reglock, flags);
+			if(crtc_id == 0){
+				writel(0x00050202, base + FB_CUR_CFG_REG);
+		        }else{
+				writel(0x00050212, base + FB_CUR_CFG_REG);
+			}
+			spin_unlock_irqrestore(&loongson_reglock, flags);
+
+			ldev->cursor_showed = true;
+			ldev->cursor_crtc_id = crtc_id;
+		}
+	}
+}
+
+int loongson_crtc_cursor_set2(struct drm_crtc *crtc,
+			struct drm_file *file_priv,
+			uint32_t handle,
+			uint32_t width,
+			uint32_t height,
+			int32_t hot_x, int32_t hot_y)
+{
+	u32 gpu_addr;
+	unsigned long flags;
+	unsigned int crtc_id;
+	volatile void __iomem *base;
+	struct drm_gem_object *obj;
+	struct drm_device *dev = crtc->dev;
+	struct loongson_crtc *loongson_crtc = to_loongson_crtc(crtc);
+	struct loongson_drm_device *ldev = (struct loongson_drm_device *)dev->dev_private;
+	struct drm_gem_dma_object *cma, *cursor = ldev->cursor;
+
+	base = ldev->mmio;
+        crtc_id = loongson_crtc->crtc_id;
+
+	if ((width != 32 || height != 32) && handle) {
+		return -EINVAL;
+	}
+
+	if (!handle || !file_priv) {
+		loongson_hide_cursor(crtc);
+		return 0;
+	}
+
+	obj = drm_gem_object_lookup(file_priv, handle);
+	if (!obj)
+		return -ENOENT;
+
+	cma = to_drm_gem_dma_obj(obj);
+
+	memcpy(cursor->vaddr, cma->vaddr, 32*32*4);
+
+	/* Program gpu address of cursor buffer */
+	gpu_addr = ldev->cursor->dma_addr;
+	spin_lock_irqsave(&loongson_reglock, flags);
+	writel(gpu_addr, base + FB_CUR_ADDR_REG);
+	writel(0x00eeeeee, base + FB_CUR_BACK_REG);
+	writel(0x00aaaaaa, base + FB_CUR_FORE_REG);
+	spin_unlock_irqrestore(&loongson_reglock, flags);
+
+	loongson_show_cursor(crtc);
+
+	drm_gem_object_put(obj);
+
+	return 0;
+}
+
+int loongson_crtc_cursor_move(struct drm_crtc *crtc, int x, int y)
+{
+	unsigned long flags;
+	unsigned int tmp, crtc_id;
+	int xorign = 0, yorign = 0;
+	volatile void __iomem *base;
+	struct loongson_crtc *loongson_crtc = to_loongson_crtc(crtc);
+	struct loongson_drm_device *ldev = (struct loongson_drm_device *)crtc->dev->dev_private;
+
+	base = ldev->mmio;
+        crtc_id = loongson_crtc->crtc_id;
+
+	/* upper edge condition */
+	yorign = y + crtc->y;
+	if (yorign < 0)
+		y = 0;
+
+	/* left edge conditon */
+	xorign = x + crtc->x;
+	if (xorign < 0)
+		x = 0;
+
+	/* move from one crtc to another, check which crtc should he shown
+	 * the x or y < 0, it means the cursor it out of current review,
+	 * && xorign/ yorign > 0, it means the cursor is in the framebuffer
+	 * but not in curren review */
+	if ((x < 0 && xorign > 0) || (y < 0 && yorign > 0)) {
+		if(ldev->cursor_crtc_id == crtc_id && !clone_mode(ldev))
+		 /*the cursor is not show, so hide if the (x,y) is in active crtc*/
+			loongson_hide_cursor(crtc);
+		return 0;
+	}
+
+	if (x < 0)
+		x = 0;
+	if (y < 0)
+		y = 0;
+
+	tmp = x & 0xffff;
+	tmp |= y << 16;
+	spin_lock_irqsave(&loongson_reglock, flags);
+	writel(tmp, base + FB_CUR_LOC_ADDR_REG);
+	spin_unlock_irqrestore(&loongson_reglock, flags);
+	if (ldev->cursor_crtc_id != crtc_id && !clone_mode(ldev)) {
+		ldev->cursor_crtc_id = crtc_id;
+		ldev->cursor_showed = false;
+	}
+	if (!ldev->cursor_showed)
+		loongson_show_cursor(crtc);
+
+	return 0;
+}
diff --git a/drivers/gpu/drm/loongson/loongson_drv.c b/drivers/gpu/drm/loongson/loongson_drv.c
new file mode 100644
index 0000000000..1ce52a2c65
--- /dev/null
+++ b/drivers/gpu/drm/loongson/loongson_drv.c
@@ -0,0 +1,641 @@
+/*
+ * Copyright (c) 2018 Loongson Technology Co., Ltd.
+ * Authors:
+ *	Chen Zhu <zhuchen@loongson.cn>
+ *	Yaling Fang <fangyaling@loongson.cn>
+ *	Dandan Zhang <zhangdandan@loongson.cn>
+ *	Huacai Chen <chenhuacai@loongson.cn>
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <asm/addrspace.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/dma-mapping.h>
+#include <linux/console.h>
+#include <linux/device.h>
+#include <linux/slab.h>
+#include <linux/pci.h>
+#include <linux/pci_ids.h>
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/vgaarb.h>
+#include <linux/vga_switcheroo.h>
+
+#include <drm/drm_aperture.h>
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/drm_probe_helper.h>
+#include <drm/drm_gem_dma_helper.h>
+#include <drm/drm_gem_framebuffer_helper.h>
+#include "loongson_drv.h"
+
+#define DEVICE_NAME	"loongson-drm"
+#define DRIVER_NAME	"loongson-drm"
+#define DRIVER_DESC	"Loongson DRM Driver"
+#define DRIVER_DATE	"20201201"
+#define DRIVER_MAJOR	1
+#define DRIVER_MINOR	0
+#define DRIVER_PATCHLEVEL	1
+
+#define PCI_DEVICE_ID_LOONGSON_DC1	0x7a06
+#define PCI_DEVICE_ID_LOONGSON_DC2	0x7a36
+
+bool hw_cursor = false;
+module_param_named(cursor, hw_cursor, bool, 0600);
+
+bool poll_connector = false;
+module_param_named(poll, poll_connector, bool, 0600);
+
+DEFINE_SPINLOCK(loongson_reglock);
+
+static struct drm_driver loongson_drm_driver;
+
+/**
+ * loongson_mode_funcs---basic driver provided mode setting functions
+ *
+ * Some global (i.e. not per-CRTC, connector, etc) mode setting functions that
+ * involve drivers.
+ */
+static const struct drm_mode_config_funcs loongson_mode_funcs = {
+	.fb_create = drm_gem_fb_create,
+	.atomic_check = drm_atomic_helper_check,
+	.atomic_commit = drm_atomic_helper_commit,
+	.output_poll_changed = drm_fb_helper_output_poll_changed
+};
+
+/**
+ *  loongson_drm_device_init  ----init drm device
+ *
+ * @dev   pointer to drm_device structure
+ * @flags start up flag
+ *
+ * RETURN
+ *   drm device init result
+ */
+static int loongson_drm_device_init(struct drm_device *dev, uint32_t flags)
+{
+	int ret = 0;
+	struct loongson_drm_device *ldev = dev->dev_private;
+
+	ldev->num_crtc = 2;
+	loongson_vbios_init(ldev);
+
+	/*BAR 0 contains registers */
+	ldev->mmio_base = pci_resource_start(to_pci_dev(dev->dev), 0);
+	ldev->mmio_size = pci_resource_len(to_pci_dev(dev->dev), 0);
+
+	ldev->mmio = pcim_iomap(to_pci_dev(dev->dev), 0, 0);
+	if (ldev->mmio == NULL)
+		return -ENOMEM;
+
+	DRM_INFO("ldev->mmio_base = 0x%llx, ldev->mmio_size = 0x%llx\n",
+			ldev->mmio_base, ldev->mmio_size);
+
+	if (!devm_request_mem_region(ldev->dev->dev, ldev->mmio_base, ldev->mmio_size,
+			"loongson_drmfb_mmio")) {
+		DRM_ERROR("Can't reserve mmio registers\n");
+		return -ENOMEM;
+	}
+
+	ret = loongson_gpio_init(ldev);
+	if (ret < 0)
+		DRM_ERROR("Failed to initialize dc gpios\n");
+
+	return ret;
+}
+
+/**
+ * loongson_modeset_init --- init kernel mode setting
+ *
+ * @ldev: pointer to loongson_drm_device structure
+ *
+ * RETURN
+ *  return init result
+ */
+int loongson_modeset_init(struct loongson_drm_device *ldev)
+{
+	int i, ret;
+	struct drm_encoder *encoder;
+	struct drm_connector *connector;
+
+	ldev->mode_info[0].mode_config_initialized = true;
+	ldev->mode_info[1].mode_config_initialized = true;
+
+	ldev->dev->mode_config.max_width = LOONGSON_MAX_FB_WIDTH;
+	ldev->dev->mode_config.max_height = LOONGSON_MAX_FB_HEIGHT;
+
+	ldev->dev->mode_config.cursor_width = 32;
+	ldev->dev->mode_config.cursor_height = 32;
+
+	ret = loongson_i2c_init(ldev);
+	if (ret < 0) {
+		DRM_ERROR("Failed to initialize i2c\n");
+		return ret;
+	}
+
+	loongson_crtc_init(ldev);
+
+	for (i=0; i<ldev->num_crtc; i++) {
+		DRM_DEBUG("loongson drm encoder init\n");
+		ldev->mode_info[i].crtc = &ldev->lcrtc[i];
+		encoder = loongson_encoder_init(ldev->dev, i);
+		if (!encoder) {
+			DRM_ERROR("loongson_encoder_init failed\n");
+			return -1;
+		}
+		ldev->mode_info[i].encoder = to_loongson_encoder(encoder);
+
+		DRM_DEBUG("loongson drm connector init\n");
+		connector = loongson_connector_init(ldev->dev, i);
+		if (!connector) {
+			DRM_ERROR("loongson_connector_init failed\n");
+			return -1;
+		}
+		ldev->mode_info[i].connector = to_loongson_connector(connector);
+
+		drm_connector_attach_encoder(connector, encoder);
+		if (poll_connector)
+			connector->polled = DRM_CONNECTOR_POLL_CONNECT | DRM_CONNECTOR_POLL_DISCONNECT;
+	}
+
+	return 0;
+}
+
+/**
+ * loongson_modeset_fini --- deinit kernel mode setting
+ *
+ * @ldev: pointer to loongson_drm_device structure
+ *
+ * RETURN
+ */
+void loongson_modeset_fini(struct loongson_drm_device *ldev)
+{
+}
+
+static int loongson_detect_chip(struct loongson_drm_device *ldev)
+{
+	struct pci_dev *pdev;
+
+	pdev = pci_get_device(PCI_VENDOR_ID_LOONGSON, PCI_DEVICE_ID_LOONGSON_DC1, NULL);
+	if (pdev) {
+		ldev->chip = dc_7a1000;
+		DRM_INFO("Set LS7A1000 DC device\n");
+		return 0;
+	}
+
+	pdev = pci_get_device(PCI_VENDOR_ID_LOONGSON, PCI_DEVICE_ID_LOONGSON_DC2, NULL);
+	if (pdev) {
+		ldev->chip = dc_7a2000;
+		DRM_INFO("Set LS7A2000 DC device\n");
+		return 0;
+	}
+
+	return -1;
+}
+
+/**
+ * loongson_vga_load - setup chip and create an initial config
+ * @dev: DRM device
+ * @flags: startup flags
+ *
+ * The driver load routine has to do several things:
+ *   - initialize the memory manager
+ *   - allocate initial config memory
+ *   - setup the DRM framebuffer with the allocated memory
+ */
+static int loongson_drm_load(struct drm_device *dev, unsigned long flags)
+{
+	int r, ret, irq;
+	struct pci_dev *pdev;
+	struct loongson_drm_device *ldev;
+
+	dma_set_mask_and_coherent(dev->dev, DMA_BIT_MASK(32));
+
+	ldev = devm_kzalloc(dev->dev, sizeof(struct loongson_drm_device), GFP_KERNEL);
+	if (ldev == NULL)
+		return -ENOMEM;
+	dev->dev_private = (void *)ldev;
+	ldev->dev = dev;
+	pdev = to_pci_dev(dev->dev);
+
+	ret = loongson_detect_chip(ldev);
+	if (ret)
+		dev_err(dev->dev, "Fatal error during detect chip: %d\n", ret);
+
+	ret = loongson_drm_device_init(dev, flags);
+	DRM_DEBUG("end loongson drm device init.\n");
+
+	drm_mode_config_init(dev);
+	dev->mode_config.funcs = (void *)&loongson_mode_funcs;
+	dev->mode_config.preferred_depth = 24;
+	dev->mode_config.prefer_shadow = 1;
+
+	irq = pdev->irq;
+	pci_set_drvdata(pdev, dev);
+	dev_set_drvdata(dev->dev, dev);
+
+	r = loongson_modeset_init(ldev);
+	if (r)
+		dev_err(dev->dev, "Fatal error during modeset init: %d\n", r);
+
+	r = loongson_irq_install(dev, irq);
+	if (r)
+		dev_err(dev->dev, "Fatal error during irq install: %d\n", r);
+
+	ldev->inited = true;
+	drm_mode_config_reset(dev);
+
+	r = drm_vblank_init(dev, ldev->num_crtc);
+	if (r)
+		dev_err(dev->dev, "Fatal error during vblank init: %d\n", r);
+
+	/* Make small buffers to store a hardware cursor (double buffered icon updates) */
+	ldev->cursor = drm_gem_dma_create(dev, roundup(32*32*4, PAGE_SIZE));
+
+	drm_kms_helper_poll_init(dev);
+
+	drm_aperture_remove_framebuffers(false, &loongson_drm_driver);
+
+	return 0;
+}
+
+/**
+ * loongson_drm_unload--release drm resource
+ *
+ * @dev: pointer to drm_device
+ *
+ */
+static void loongson_drm_unload(struct drm_device *dev)
+{
+        struct loongson_drm_device *ldev = dev->dev_private;
+
+	if (ldev == NULL)
+		return;
+
+	loongson_modeset_fini(ldev);
+	drm_mode_config_cleanup(dev);
+	dev->dev_private = NULL;
+	dev_set_drvdata(dev->dev, NULL);
+	ldev->inited = false;
+
+	return;
+}
+
+/**
+ * loongson_drm_open -Driver callback when a new struct drm_file is opened.
+ * Useful for setting up driver-private data structures like buffer allocators,
+ *  execution contexts or similar things.
+ *
+ * @dev DRM device
+ * @file DRM file private date
+ *
+ * RETURN
+ * 0 on success, a negative error code on failure, which will be promoted to
+ *  userspace as the result of the open() system call.
+ */
+static int loongson_drm_open(struct drm_device *dev, struct drm_file *file)
+{
+	file->driver_priv = NULL;
+
+	DRM_DEBUG("open: dev=%p, file=%p", dev, file);
+
+	return 0;
+}
+
+DEFINE_DRM_GEM_DMA_FOPS(fops);
+
+/**
+ * loongson_drm_driver - DRM device structure
+ *
+ * .load: driver callback to complete initialization steps after the driver is registered
+ * .unload:Reverse the effects of the driver load callback
+ * .open:Driver callback when a new struct drm_file is opened
+ * .fops:File operations for the DRM device node.
+ * .gem_free_object:deconstructor for drm_gem_objects
+ * .dumb_create:This creates a new dumb buffer in the driver’s backing storage manager
+ *  (GEM, TTM or something else entirely) and returns the resulting buffer handle.
+ *  This handle can then be wrapped up into a framebuffer modeset object
+ * .dumb_map_offset:Allocate an offset in the drm device node’s address space
+ *  to be able to memory map a dumb buffer
+ * .dump_destory:This destroys the userspace handle for the given dumb backing storage buffer
+ */
+static struct drm_driver loongson_drm_driver = {
+	.driver_features = DRIVER_MODESET | DRIVER_GEM | DRIVER_HAVE_IRQ | DRIVER_ATOMIC,
+	.open = loongson_drm_open,
+	.fops = &fops,
+
+	.name = DRIVER_NAME,
+	.desc = DRIVER_DESC,
+	.date = DRIVER_DATE,
+	.major = DRIVER_MAJOR,
+	.minor = DRIVER_MINOR,
+	.patchlevel = DRIVER_PATCHLEVEL,
+
+	DRM_GEM_DMA_DRIVER_OPS,
+	.gem_prime_import	= drm_gem_prime_import,
+	.gem_prime_import_sg_table = drm_gem_dma_prime_import_sg_table,
+};
+
+/**
+ * loongson_drm_pci_devices  -- pci device id info
+ *
+ * __u32 vendor, device           Vendor and device ID or PCI_ANY_ID
+ * __u32 subvendor, subdevice     Subsystem ID's or PCI_ANY_ID
+ * __u32 class, class_mask        (class,subclass,prog-if) triplet
+ * kernel_ulong_t driver_data     Data private to the driver
+ */
+static struct pci_device_id loongson_drm_pci_devices[] = {
+	{PCI_DEVICE(PCI_VENDOR_ID_LOONGSON, PCI_DEVICE_ID_LOONGSON_DC1)},
+	{PCI_DEVICE(PCI_VENDOR_ID_LOONGSON, PCI_DEVICE_ID_LOONGSON_DC2)},
+	{0, 0, 0, 0, 0, 0, 0}
+};
+
+MODULE_DEVICE_TABLE(pci, loongson_drm_pci_devices);
+
+/**
+ * loongson_drm_pci_register -- add pci device
+ *
+ * @pdev PCI device
+ * @ent pci device id
+ */
+static int loongson_drm_pci_register(struct pci_dev *pdev,
+				 const struct pci_device_id *ent)
+
+{
+	int ret;
+	struct drm_device *dev;
+
+	dev = drm_dev_alloc(&loongson_drm_driver, &pdev->dev);
+	if (IS_ERR(dev))
+		return PTR_ERR(dev);
+
+	ret = pci_enable_device(pdev);
+	if (ret)
+		goto err_free;
+
+	loongson_drm_load(dev, 0x0);
+
+	ret = drm_dev_register(dev, 0);
+	if (ret)
+		goto err_pdev;
+
+	drm_fbdev_generic_setup(dev, 32);
+
+	return 0;
+
+err_pdev:
+	pci_disable_device(pdev);
+err_free:
+	drm_dev_put(dev);
+	return ret;
+}
+
+/**
+ * loongson_drm_pci_unregister -- release drm device
+ *
+ * @pdev PCI device
+ */
+static void loongson_drm_pci_unregister(struct pci_dev *pdev)
+{
+	struct drm_device *dev = pci_get_drvdata(pdev);
+	loongson_drm_unload(dev);
+	drm_dev_put(dev);
+}
+
+/*
+ * Suspend & resume.
+ */
+/*
+ * loongson_drm_suspend - initiate device suspend
+ *
+ * @pdev: drm dev pointer
+ * @state: suspend state
+ *
+ * Puts the hw in the suspend state (all asics).
+ * Returns 0 for success or an error on failure.
+ * Called at driver suspend.
+ */
+int loongson_drm_suspend(struct drm_device *dev, bool suspend)
+{
+	struct pci_dev *pdev = to_pci_dev(dev->dev);
+        struct loongson_drm_device *ldev;
+
+        if (dev == NULL || dev->dev_private == NULL)
+                return -ENODEV;
+
+        ldev = dev->dev_private;
+
+        drm_kms_helper_poll_disable(dev);
+	ldev->state = drm_atomic_helper_suspend(dev);
+
+	pci_save_state(pdev);
+	if (suspend) {
+		/* Shut down the device */
+		pci_disable_device(pdev);
+		pci_set_power_state(pdev, PCI_D3hot);
+	}
+
+	console_lock();
+	drm_fb_helper_set_suspend(ldev->dev->fb_helper, 1);
+	console_unlock();
+
+	return 0;
+}
+
+/*
+ *  * loongson_drm_resume - initiate device suspend
+ *
+ * @pdev: drm dev pointer
+ * @state: suspend state
+ *
+ * Puts the hw in the suspend state (all asics).
+ * Returns 0 for success or an error on failure.
+ * Called at driver suspend.
+ */
+
+int loongson_drm_resume(struct drm_device *dev, bool resume)
+{
+	struct pci_dev *pdev = to_pci_dev(dev->dev);
+	struct loongson_drm_device *ldev = dev->dev_private;
+
+	console_lock();
+
+	if (resume) {
+		pci_set_power_state(pdev, PCI_D0);
+		pci_restore_state(pdev);
+		if (pci_enable_device(pdev)) {
+			console_unlock();
+			return -1;
+		}
+	}
+
+        /* blat the mode back in */
+	drm_atomic_helper_resume(dev, ldev->state);
+
+	drm_kms_helper_poll_enable(dev);
+
+	drm_fb_helper_set_suspend(ldev->dev->fb_helper, 0);
+
+	console_unlock();
+
+	return 0;
+}
+
+/**
+ * loongson_drm_pm_suspend
+ *
+ * @dev   pointer to the device
+ *
+ * Executed before putting the system into a sleep state in which the
+ * contents of main memory are preserved.
+ */
+static int loongson_drm_pm_suspend(struct device *dev)
+{
+	struct drm_device *drm_dev = dev_get_drvdata(dev);
+
+	return loongson_drm_suspend(drm_dev, true);
+}
+
+/**
+ * loongson_drm_pm_resume
+ *
+ * @dev pointer to the device
+ *
+ * Executed after waking the system up from a sleep state in which the
+ * contents of main memory were preserved.
+ */
+static int loongson_drm_pm_resume(struct device *dev)
+{
+	struct drm_device *drm_dev = dev_get_drvdata(dev);
+
+	return loongson_drm_resume(drm_dev, true);
+}
+
+/**
+ *  loongson_drm_pm_freeze
+ *
+ *  @dev pointer to device
+ *
+ *  Hibernation-specific, executed before creating a hibernation image.
+ *  Analogous to @suspend(), but it should not enable the device to signal
+ *  wakeup events or change its power state.
+ */
+static int loongson_drm_pm_freeze(struct device *dev)
+{
+	struct drm_device *drm_dev = dev_get_drvdata(dev);
+
+	return loongson_drm_suspend(drm_dev, false);
+}
+
+/**
+ * loongson_drm_pm_draw
+ *
+ * @dev pointer to device
+ *
+ * Hibernation-specific, executed after creating a hibernation image OR
+ * if the creation of an image has failed.  Also executed after a failing
+ * attempt to restore the contents of main memory from such an image.
+ * Undo the changes made by the preceding @freeze(), so the device can be
+ * operated in the same way as immediately before the call to @freeze().
+ */
+static int loongson_drm_pm_thaw(struct device *dev)
+{
+	struct drm_device *drm_dev = dev_get_drvdata(dev);
+	
+	return loongson_drm_resume(drm_dev, false);
+}
+
+#define loongson_drm_pm_poweroff	loongson_drm_pm_freeze
+#define loongson_drm_pm_restore		loongson_drm_pm_resume
+
+/*
+ * * struct dev_pm_ops - device PM callbacks
+ *
+ *@suspend:  Executed before putting the system into a sleep state in which the
+ *           contents of main memory are preserved.
+ *@resume:   Executed after waking the system up from a sleep state in which the
+ *           contents of main memory were preserved.
+ *@freeze:   Hibernation-specific, executed before creating a hibernation image.
+ *           Analogous to @suspend(), but it should not enable the device to signal
+ *           wakeup events or change its power state.  The majority of subsystems
+ *           (with the notable exception of the PCI bus type) expect the driver-level
+ *           @freeze() to save the device settings in memory to be used by @restore()
+ *           during the subsequent resume from hibernation.
+ *@thaw:     Hibernation-specific, executed after creating a hibernation image OR
+ *           if the creation of an image has failed.  Also executed after a failing
+ *           attempt to restore the contents of main memory from such an image.
+ *           Undo the changes made by the preceding @freeze(), so the device can be
+ *           operated in the same way as immediately before the call to @freeze().
+ *@poweroff: Hibernation-specific, executed after saving a hibernation image.
+ *           Analogous to @suspend(), but it need not save the device's settings in
+ *           memory.
+ *@restore:  Hibernation-specific, executed after restoring the contents of main
+ *           memory from a hibernation image, analogous to @resume().
+ */
+static const struct dev_pm_ops loongson_drm_pm_ops = {
+	.suspend = loongson_drm_pm_suspend,
+	.resume = loongson_drm_pm_resume,
+	.freeze = loongson_drm_pm_freeze,
+	.thaw = loongson_drm_pm_thaw,
+	.poweroff = loongson_drm_pm_poweroff,
+	.restore = loongson_drm_pm_restore,
+};
+
+/**
+ * loongson_drm_pci_driver -- pci driver structure
+ *
+ * .id_table : must be non-NULL for probe to be called
+ * .probe: New device inserted
+ * .remove: Device removed
+ * .resume: Device suspended
+ * .suspend: Device woken up
+ */
+static struct pci_driver loongson_drm_pci_driver = {
+	.name		= DRIVER_NAME,
+	.id_table	= loongson_drm_pci_devices,
+	.probe		= loongson_drm_pci_register,
+	.remove		= loongson_drm_pci_unregister,
+	.driver.pm	= &loongson_drm_pm_ops,
+};
+
+/**
+ * loongson_drm_pci_init()  -- kernel module init function
+ */
+static int __init loongson_drm_init(void)
+{
+	int ret;
+	struct pci_dev *pdev = NULL;
+
+	/* If external graphics card exist, use it as default */
+	while ((pdev = pci_get_class(PCI_CLASS_DISPLAY_VGA << 8, pdev))) {
+		if (pdev->vendor == PCI_VENDOR_ID_ATI)
+			return 0;
+		if (pdev->vendor == 0x1a03) /* ASpeed */
+			return 0;
+	}
+
+	ret = pci_register_driver(&loongson_drm_pci_driver);
+
+	return ret;
+}
+
+/**
+ * loongson_drm_pci_exit()  -- kernel module exit function
+ */
+static void __exit loongson_drm_exit(void)
+{
+	pci_unregister_driver(&loongson_drm_pci_driver);
+}
+
+module_init(loongson_drm_init);
+module_exit(loongson_drm_exit);
+
+MODULE_AUTHOR("Chen Zhu <zhuchen@loongson.cn>");
+MODULE_AUTHOR("Huacai Chen <chenhuacai@loongson.cn>");
+MODULE_DESCRIPTION("Loongson LS7A DRM Driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/gpu/drm/loongson/loongson_drv.h b/drivers/gpu/drm/loongson/loongson_drv.h
new file mode 100644
index 0000000000..fd9efd5c4e
--- /dev/null
+++ b/drivers/gpu/drm/loongson/loongson_drv.h
@@ -0,0 +1,239 @@
+#ifndef __LOONGSON_DRV_H__
+#define __LOONGSON_DRV_H__
+
+#include <linux/i2c.h>
+#include <linux/i2c-algo-bit.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <asm/loongson.h>
+
+#include <drm/drm_drv.h>
+#include <drm/drm_encoder.h>
+#include <drm/drm_fb_helper.h>
+#include <drm/drm_fbdev_generic.h>
+#include <drm/drm_gem.h>
+#include <drm/drm_modeset_helper_vtables.h>
+#include <drm/drm_vblank.h>
+
+#include "loongson_i2c.h"
+#include "loongson_vbios.h"
+
+#define to_loongson_crtc(x) container_of(x, struct loongson_crtc, base)
+#define to_loongson_encoder(x) container_of(x, struct loongson_encoder, base)
+#define to_loongson_connector(x) container_of(x, struct loongson_connector, base)
+
+#define LOONGSON_MAX_FB_HEIGHT	4096
+#define LOONGSON_MAX_FB_WIDTH	4096
+
+#define CUR_WIDTH_SIZE		32
+#define CUR_HEIGHT_SIZE		32
+
+#define LO_OFF	0
+#define HI_OFF	8
+
+#define LS7A_PIX0_PLL		(void *)TO_UNCACHE(LS7A_CHIPCFG_REG_BASE + 0x04b0)
+#define LS7A_PIX1_PLL		(void *)TO_UNCACHE(LS7A_CHIPCFG_REG_BASE + 0x04c0)
+
+#define CURIOSET_CORLOR		0x4607
+#define CURIOSET_POSITION	0x4608
+#define CURIOLOAD_ARGB		0x4609
+#define CURIOLOAD_IMAGE		0x460A
+#define CURIOHIDE_SHOW		0x460B
+#define FBEDID_GET		0X860C
+
+#define CRTC_REG_OFFSET		0x10
+
+#define CFG_FMT			GENMASK(2,0)
+#define CFG_FBSWITCH		BIT(7)
+#define CFG_ENABLE		BIT(8)
+#define CFG_PANELSWITCH 	BIT(9)
+#define CFG_FBNUM_BIT		11
+#define CFG_FBNUM		BIT(11)
+#define CFG_GAMMAR		BIT(12)
+#define CFG_RESET		BIT(20)
+
+#define FB_CFG_DVO_REG		(0x1240)
+#define FB_ADDR0_DVO_REG	(0x1260)
+#define FB_ADDR1_DVO_REG	(0x1580)
+#define FB_STRI_DVO_REG		(0x1280)
+#define FB_DITCFG_DVO_REG	(0x1360)
+#define FB_DITTAB_LO_DVO_REG	(0x1380)
+#define FB_DITTAB_HI_DVO_REG	(0x13a0)
+#define FB_PANCFG_DVO_REG	(0x13c0)
+#define FB_PANTIM_DVO_REG	(0x13e0)
+#define FB_HDISPLAY_DVO_REG	(0x1400)
+#define FB_HSYNC_DVO_REG	(0x1420)
+#define FB_VDISPLAY_DVO_REG	(0x1480)
+#define FB_VSYNC_DVO_REG	(0x14a0)
+#define FB_GAMINDEX_DVO_REG	(0x14e0)
+#define FB_GAMDATA_DVO_REG	(0x1500)
+
+#define HDMI_ZONEIDLE_REG 	(0x1700)
+#define HDMI_CTRL_REG		(0x1720)
+
+#define HDMI_AUDIO_BUF_REG	(0x1740)
+#define HDMI_AUDIO_NCFG_REG	(0x1760)
+#define HDMI_AUDIO_CTSCFG_REG	(0x1780)
+#define HDMI_AUDIO_CTSCALCFG_REG	(0x17a0)
+#define HDMI_AUDIO_INFOFRAME_REG	(0x17c0)
+#define HDMI_AUDIO_SAMPLE_REG	(0x17e0)
+
+#define HDMI_PHY_CTRL_REG	(0x1800)
+#define HDMI_PHY_PLLCFG_REG	(0x1820)
+
+#define FB_CUR_CFG_REG		(0x1520)
+#define FB_CUR_ADDR_REG		(0x1530)
+#define FB_CUR_LOC_ADDR_REG	(0x1540)
+#define FB_CUR_BACK_REG		(0x1550)
+#define FB_CUR_FORE_REG		(0x1560)
+#define FB_INT_REG		(0x1570)
+
+#define INT_DVO1_VSYNC		0
+#define INT_DVO1_HSYNC		1
+#define INT_DVO0_VSYNC		2
+#define INT_DVO0_HSYNC		3
+#define INT_CURSOR_FB_END	4
+#define INT_DVO1_FB_END		5
+#define INT_DVO0_FB_END		6
+
+#define MAX_CRTC 2
+
+enum loongson_chip {
+	dc_7a1000,
+	dc_7a2000
+};
+
+struct pix_pll {
+	unsigned int l2_div;
+	unsigned int l1_loopc;
+	unsigned int l1_frefc;
+};
+
+struct config_reg {
+	u8 dev_addr;
+	u8 reg;
+	u8 value;
+} __packed;
+
+struct cfg_encoder {
+	u8 reg_num;
+	u32 hdisplay;
+	u32 vdisplay;
+	struct config_reg config_regs[256];
+};
+
+struct loongson_crtc {
+	struct drm_crtc base;
+	unsigned int crtc_id;
+	uint32_t cfg_reg;
+	struct drm_plane *primary; /* Primary panel belongs to this crtc */
+	struct drm_pending_vblank_event *event;
+	struct loongson_drm_device *ldev;
+};
+
+struct loongson_encoder {
+	struct drm_encoder base;
+	u32 type;
+	u32 i2c_id;
+	int encoder_id;
+	struct loongson_i2c *i2c;
+	struct loongson_crtc *lcrtc; /* Binding crtc, not actual one */
+};
+
+struct loongson_connector {
+	struct drm_connector base;
+	u16 id;
+	u32 type;
+	u16 i2c_id;
+	u16 hotplug;
+	u16 edid_method;
+	u8 *vbios_edid;
+	struct loongson_i2c *i2c;
+	struct loongson_drm_device *ldev;
+};
+
+struct loongson_mode_info {
+	bool mode_config_initialized;
+	struct loongson_crtc *crtc;
+	struct loongson_encoder *encoder;
+	struct loongson_connector *connector;
+};
+
+struct loongson_drm_device {
+	struct drm_device *dev;
+	struct drm_atomic_state	*state;
+
+	resource_size_t	mmio_base;
+	resource_size_t	mmio_size;
+	void __iomem	*mmio;
+	uint32_t	int_reg;
+
+	struct drm_display_mode		mode;
+	struct loongson_mode_info	mode_info[2];
+	struct drm_gem_dma_object	*cursor;
+
+	int 			num_crtc;
+	struct loongson_crtc 	lcrtc[MAX_CRTC];
+	struct loongson_i2c	i2c_bus[DC_I2C_BUS_MAX];
+
+	void *vbios;
+	struct list_head desc_list;
+
+	bool	inited;
+	bool 	suspended;
+	bool	cursor_showed;
+	int	cursor_crtc_id;
+
+	int connector_active0;
+	int connector_active1;
+
+	enum loongson_chip chip;
+};
+
+extern spinlock_t loongson_reglock;
+
+/* FIXME: LS7A2000's switch_panel is not available, just return false. */
+static inline bool clone_mode(struct loongson_drm_device *ldev)
+{
+	return false;
+
+	if (ldev->num_crtc < 2)
+		return true;
+	if (ldev->mode_info[0].connector->base.status != connector_status_connected)
+		return true;
+	if (ldev->mode_info[1].connector->base.status != connector_status_connected)
+		return true;
+	if (ldev->lcrtc[0].base.x || ldev->lcrtc[0].base.y)
+		return false;
+	if (ldev->lcrtc[1].base.x || ldev->lcrtc[1].base.y)
+		return false;
+
+	return true;
+}
+
+int loongson_irq_install(struct drm_device *dev, int irq);
+void loongson_irq_uninstall(struct drm_device *dev);
+int loongson_irq_enable_vblank(struct drm_device *dev,unsigned int crtc_id);
+void loongson_irq_disable_vblank(struct drm_device *dev,unsigned int crtc_id);
+
+u32 crtc_read(struct loongson_crtc *lcrtc, u32 offset);
+void crtc_write(struct loongson_crtc *lcrtc, u32 offset, u32 val);
+
+int loongson_gpio_init(struct loongson_drm_device *ldev);
+int loongson_crtc_init(struct loongson_drm_device *ldev);
+struct drm_encoder *loongson_encoder_init(struct drm_device *dev, unsigned int index);
+struct drm_connector *loongson_connector_init(struct drm_device *dev, unsigned int index);
+
+int loongson_fbdev_init(struct loongson_drm_device *ldev);
+void loongson_fbdev_fini(struct loongson_drm_device *ldev);
+void loongson_fbdev_restore_mode(struct loongson_drm_device *ldev);
+
+int loongson_drm_drm_suspend(struct drm_device *dev, bool suspend,
+                                   bool fbcon, bool freeze);
+int loongson_drm_drm_resume(struct drm_device *dev, bool resume, bool fbcon);
+		   /* loongson_cursor.c */
+int loongson_crtc_cursor_set2(struct drm_crtc *crtc, struct drm_file *file_priv,
+					uint32_t handle, uint32_t width, uint32_t height, int32_t hot_x, int32_t hot_y);
+int loongson_crtc_cursor_move(struct drm_crtc *crtc, int x, int y);
+
+#endif
diff --git a/drivers/gpu/drm/loongson/loongson_encoder.c b/drivers/gpu/drm/loongson/loongson_encoder.c
new file mode 100644
index 0000000000..f2d4c49f53
--- /dev/null
+++ b/drivers/gpu/drm/loongson/loongson_encoder.c
@@ -0,0 +1,134 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2018 Loongson Technology Co., Ltd.
+ * Copyright (C) 2019 Lemote Inc.
+ * Authors:
+ *	Chen Zhu <zhuchen@loongson.cn>
+ *	Yaling Fang <fangyaling@loongson.cn>
+ *	Dandan Zhang <zhangdandan@loongson.cn>
+ *	Huacai Chen <chenhc@lemote.com>
+ *	Jiaxun Yang <jiaxun.yang@flygoat.com>
+ */
+
+#include <drm/drm_crtc_helper.h>
+#include "loongson_drv.h"
+
+/**
+ * loongson_encoder_destroy
+ *
+ * @encoder: encoder object
+ *
+ * Clean up encoder resources
+ */
+static void loongson_encoder_destroy(struct drm_encoder *encoder)
+{
+	struct loongson_encoder *loongson_encoder = to_loongson_encoder(encoder);
+	drm_encoder_cleanup(encoder);
+	kfree(loongson_encoder);
+}
+
+static int loongson_encoder_atomic_check(struct drm_encoder *encoder,
+				    struct drm_crtc_state *crtc_state,
+				    struct drm_connector_state *conn_state)
+{
+	return 0;
+}
+
+static void loongson_encoder_atomic_mode_set(struct drm_encoder *encoder,
+				struct drm_crtc_state *crtc_state,
+				struct drm_connector_state *conn_state)
+{
+	unsigned long flags;
+	struct loongson_encoder *lenc = to_loongson_encoder(encoder);
+	struct loongson_crtc *lcrtc_origin = lenc->lcrtc;
+	struct loongson_crtc *lcrtc_current = to_loongson_crtc(crtc_state->crtc);
+
+	if (lcrtc_origin->crtc_id != lcrtc_current->crtc_id)
+		lcrtc_origin->cfg_reg |= CFG_PANELSWITCH;
+	else
+		lcrtc_origin->cfg_reg &= ~CFG_PANELSWITCH;
+
+	spin_lock_irqsave(&loongson_reglock, flags);
+	crtc_write(lcrtc_origin, FB_CFG_DVO_REG, lcrtc_origin->cfg_reg);
+	spin_unlock_irqrestore(&loongson_reglock, flags);
+}
+
+/**
+ * These provide the minimum set of functions required to handle a encoder
+ *
+ * Helper operations for encoders
+ */
+static const struct drm_encoder_helper_funcs loongson_encoder_helper_funcs = {
+	.atomic_check = loongson_encoder_atomic_check,
+	.atomic_mode_set = loongson_encoder_atomic_mode_set,
+};
+
+/**
+ * These provide the minimum set of functions required to handle a encoder
+ *
+ * Encoder controls,encoder sit between CRTCs and connectors
+ */
+static const struct drm_encoder_funcs loongson_encoder_encoder_funcs = {
+	.destroy = loongson_encoder_destroy,
+};
+
+static void loongson_hdmi_init(struct loongson_drm_device *ldev, int index)
+{
+	u32 val;
+	int offset = index * 0x10;
+	volatile void __iomem *base = ldev->mmio;
+
+	spin_lock(&loongson_reglock);
+	writel(0x287, base + HDMI_CTRL_REG + offset);
+
+	writel(0x00400040, base + HDMI_ZONEIDLE_REG + offset);
+
+	writel(6272, base + HDMI_AUDIO_NCFG_REG + offset);
+	writel(0x80000000, base + HDMI_AUDIO_CTSCFG_REG + offset);
+
+	writel(0x11, base + HDMI_AUDIO_INFOFRAME_REG + offset);
+	val = readl(base + HDMI_AUDIO_INFOFRAME_REG + offset) | 0x4;
+	writel(val, base + HDMI_AUDIO_INFOFRAME_REG + offset);
+
+	writel(0x1, base + HDMI_AUDIO_SAMPLE_REG + offset);
+	spin_unlock(&loongson_reglock);
+
+	DRM_DEBUG("Loongson HDMI init finish.\n");
+}
+
+/**
+ * loongson_encoder_init
+ *
+ * @dev: point to the drm_device structure
+ *
+ * Init encoder
+ */
+struct drm_encoder *loongson_encoder_init(struct drm_device *dev, unsigned int index)
+{
+	struct drm_encoder *encoder;
+	struct loongson_encoder *loongson_encoder;
+	struct loongson_drm_device *ldev = dev->dev_private;
+
+	loongson_encoder = kzalloc(sizeof(struct loongson_encoder), GFP_KERNEL);
+	if (!loongson_encoder)
+		return NULL;
+
+	loongson_encoder->encoder_id = index;
+	loongson_encoder->i2c = &ldev->i2c_bus[index];
+	loongson_encoder->lcrtc = &ldev->lcrtc[index];
+	loongson_encoder->type = get_encoder_type(ldev, index);
+	encoder = &loongson_encoder->base;
+
+	if (loongson_encoder->type == DRM_MODE_ENCODER_TMDS)
+		loongson_hdmi_init(ldev, index);
+
+	encoder->possible_crtcs = BIT(index);
+	encoder->possible_clones = BIT(1) | BIT(0);
+	/* encoder->possible_crtcs = BIT(1) | BIT(0); */
+
+	drm_encoder_helper_add(encoder, &loongson_encoder_helper_funcs);
+	drm_encoder_init(dev, encoder, &loongson_encoder_encoder_funcs,
+			 loongson_encoder->type, NULL);
+
+	return encoder;
+}
diff --git a/drivers/gpu/drm/loongson/loongson_i2c.c b/drivers/gpu/drm/loongson/loongson_i2c.c
new file mode 100644
index 0000000000..55a59ccfd7
--- /dev/null
+++ b/drivers/gpu/drm/loongson/loongson_i2c.c
@@ -0,0 +1,189 @@
+// SPDX-License-Identifier: GPL-2.0+
+
+#include "loongson_i2c.h"
+#include "loongson_drv.h"
+#include "loongson_vbios.h"
+
+u32 ls7a_mm_rreg(struct loongson_drm_device *ldev, u32 offset)
+{
+	return readl(ldev->mmio + offset);
+}
+
+void ls7a_mm_wreg(struct loongson_drm_device *ldev, u32 offset, u32 val)
+{
+	writel(val, ldev->mmio + offset);
+}
+
+static inline void __dc_gpio_set_dir(struct loongson_drm_device *ldev,
+				     unsigned int pin, int input)
+{
+	u32 temp;
+
+	temp = ls7a_mm_rreg(ldev, LS7A_DC_GPIO_CFG_OFFSET);
+	if (input)
+		temp |= 1UL << pin;
+	else
+		temp &= ~(1UL << pin);
+	ls7a_mm_wreg(ldev, LS7A_DC_GPIO_CFG_OFFSET, temp);
+}
+
+static void __dc_gpio_set_val(struct loongson_drm_device *ldev, unsigned int pin,
+			      int high)
+{
+	u32 temp;
+
+	temp = ls7a_mm_rreg(ldev, LS7A_DC_GPIO_OUT_OFFSET);
+	if (high)
+		temp |= 1UL << pin;
+	else
+		temp &= ~(1UL << pin);
+	ls7a_mm_wreg(ldev, LS7A_DC_GPIO_OUT_OFFSET, temp);
+}
+
+static void loongson_i2c_set_data(void *i2c, int value)
+{
+	struct loongson_i2c *li2c = i2c;
+	struct loongson_drm_device *ldev = li2c->ldev;
+	unsigned int pin = li2c->data;
+
+	if (value)
+		__dc_gpio_set_dir(ldev, pin, 1);
+	else {
+		__dc_gpio_set_val(ldev, pin, 0);
+		__dc_gpio_set_dir(ldev, pin, 0);
+	}
+}
+
+static void loongson_i2c_set_clock(void *i2c, int value)
+{
+	struct loongson_i2c *li2c = i2c;
+	struct loongson_drm_device *ldev = li2c->ldev;
+	unsigned int pin = li2c->clock;
+
+	if (value)
+		__dc_gpio_set_dir(ldev, pin, 1);
+	else {
+		__dc_gpio_set_val(ldev, pin, 0);
+		__dc_gpio_set_dir(ldev, pin, 0);
+	}
+}
+
+static int loongson_i2c_get_data(void *i2c)
+{
+	int val;
+	struct loongson_i2c *li2c = i2c;
+	struct loongson_drm_device *ldev = li2c->ldev;
+	unsigned int pin = li2c->data;
+
+	val = ls7a_mm_rreg(ldev, LS7A_DC_GPIO_IN_OFFSET);
+
+	return (val >> pin) & 1;
+}
+
+static int loongson_i2c_get_clock(void *i2c)
+{
+	int val;
+	struct loongson_i2c *li2c = i2c;
+	struct loongson_drm_device *ldev = li2c->ldev;
+	unsigned int pin = li2c->clock;
+
+	val = ls7a_mm_rreg(ldev, LS7A_DC_GPIO_IN_OFFSET);
+
+	return (val >> pin) & 1;
+}
+
+static int loongson_i2c_create(struct loongson_drm_device *ldev,
+			       struct loongson_i2c *li2c, const char *name)
+{
+	int ret;
+	unsigned int i2c_num;
+	struct i2c_adapter *i2c_adapter;
+	struct i2c_algo_bit_data *i2c_algo_data;
+
+	i2c_num = li2c->i2c_id;
+	i2c_adapter = kzalloc(sizeof(struct i2c_adapter), GFP_KERNEL);
+	if (!i2c_adapter)
+		return -ENOMEM;
+
+	i2c_algo_data = kzalloc(sizeof(struct i2c_algo_bit_data), GFP_KERNEL);
+	if (!i2c_algo_data) {
+		ret = -ENOMEM;
+		goto free_adapter;
+	}
+
+	i2c_adapter->owner = THIS_MODULE;
+	i2c_adapter->class = I2C_CLASS_DDC;
+	i2c_adapter->algo_data = i2c_algo_data;
+	i2c_adapter->dev.parent = ldev->dev->dev;
+	i2c_adapter->nr = -1;
+	snprintf(i2c_adapter->name, sizeof(i2c_adapter->name), "%s%d", name,
+		 i2c_num);
+
+	li2c->data = i2c_num * 2;
+	li2c->clock = i2c_num * 2 + 1;
+	DRM_INFO("Created dc-i2c%d, sda=%d, scl=%d\n", i2c_num, li2c->data,
+		 li2c->clock);
+
+	i2c_algo_data->setsda = loongson_i2c_set_data;
+	i2c_algo_data->setscl = loongson_i2c_set_clock;
+	i2c_algo_data->getsda = loongson_i2c_get_data;
+	i2c_algo_data->getscl = loongson_i2c_get_clock;
+	i2c_algo_data->udelay = DC_I2C_TON;
+	i2c_algo_data->timeout = usecs_to_jiffies(2200); /* from VESA */
+
+	ret = i2c_bit_add_numbered_bus(i2c_adapter);
+	if (ret)
+		goto free_algo_data;
+
+	li2c->adapter = i2c_adapter;
+	i2c_algo_data->data = li2c;
+	i2c_set_adapdata(li2c->adapter, li2c);
+	li2c->init = true;
+	li2c->ldev = ldev;
+	DRM_INFO("Register i2c algo-bit adapter [%s]\n", i2c_adapter->name);
+
+	return 0;
+
+free_algo_data:
+	DRM_ERROR("Failed to register i2c adapter %s\n", i2c_adapter->name);
+	kfree(i2c_algo_data);
+free_adapter:
+	kfree(i2c_adapter);
+
+	return ret;
+}
+
+int loongson_gpio_init(struct loongson_drm_device *ldev)
+{
+	int pin;
+
+	/* set gpio dir output 0-3 */
+	for (pin = 0; pin < 4; pin++) {
+		__dc_gpio_set_val(ldev, pin, 0);
+		__dc_gpio_set_dir(ldev, pin, 0);
+	}
+
+	return 0;
+}
+
+int loongson_i2c_init(struct loongson_drm_device *ldev)
+{
+	int ret, i;
+
+	ret = get_loongson_i2c(ldev);
+	if (ret != true) {
+		DRM_ERROR("Failed to get i2c_id form vbios\n");
+		return -ENODEV;
+	}
+
+	for (i = 0; i < DC_I2C_BUS_MAX; i++) {
+		if (!ldev->i2c_bus[i].use)
+			continue;
+		ldev->i2c_bus[i].i2c_id = i;
+		ret = loongson_i2c_create(ldev, &ldev->i2c_bus[i], DC_I2C_NAME);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
diff --git a/drivers/gpu/drm/loongson/loongson_i2c.h b/drivers/gpu/drm/loongson/loongson_i2c.h
new file mode 100644
index 0000000000..97d3d139ca
--- /dev/null
+++ b/drivers/gpu/drm/loongson/loongson_i2c.h
@@ -0,0 +1,43 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright (c) 2020 Loongson Technology Co., Ltd.
+ * Authors:
+ *	sunhao <sunhao@loongson.cn>
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#ifndef __LOONGSON_I2C_H__
+#define __LOONGSON_I2C_H__
+
+#include <linux/i2c.h>
+#include <linux/i2c-algo-bit.h>
+#include <drm/drm_edid.h>
+
+/* Modify this marco to config i2c bus speed, bus_freq = 500 / T */
+/* Eg: i2c_bus_freq=100k when T=5 */
+#define DC_I2C_TON 5
+#define DC_I2C_NAME "ls7a_dc_i2c"
+#define DC_I2C_BUS_MAX 2
+
+/* Loongson 7A display controller proprietary GPIOs */
+#define LS7A_DC_GPIO_CFG_OFFSET (0x1660)
+#define LS7A_DC_GPIO_IN_OFFSET (0x1650)
+#define LS7A_DC_GPIO_OUT_OFFSET (0x1650)
+
+struct loongson_drm_device;
+
+struct loongson_i2c {
+	struct loongson_drm_device *ldev;
+	struct i2c_client *ddc_client;
+	struct i2c_adapter *adapter;
+	u32 data, clock;
+	bool use, init;
+	u32 i2c_id;
+};
+
+int loongson_i2c_init(struct loongson_drm_device *ldev);
+
+#endif
diff --git a/drivers/gpu/drm/loongson/loongson_irq.c b/drivers/gpu/drm/loongson/loongson_irq.c
new file mode 100644
index 0000000000..81f38b7595
--- /dev/null
+++ b/drivers/gpu/drm/loongson/loongson_irq.c
@@ -0,0 +1,90 @@
+/*
+ * Copyright (c) 2018 Loongson Technology Co., Ltd.
+ * Authors:
+ *	Chen Zhu <zhuchen@loongson.cn>
+ *	Yaling Fang <fangyaling@loongson.cn>
+ *	Dandan Zhang <zhangdandan@loongson.cn>
+ *	Huacai Chen <chenhc@lemote.com>
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include "loongson_drv.h"
+
+static irqreturn_t loongson_irq_handler(int irq, void *arg)
+{
+	unsigned int val;
+	struct drm_device *dev = (struct drm_device *) arg;
+	struct loongson_drm_device *ldev = dev->dev_private;
+	volatile void __iomem *base = ldev->mmio;
+ 
+	val = readl(base + FB_INT_REG);
+	spin_lock(&loongson_reglock);
+	writel(val, base + FB_INT_REG);
+	spin_unlock(&loongson_reglock);
+
+	if (val & BIT(INT_DVO0_FB_END)){
+		drm_crtc_handle_vblank(&ldev->lcrtc[0].base);
+	}
+
+	if (val & BIT(INT_DVO1_FB_END)){
+		drm_crtc_handle_vblank(&ldev->lcrtc[1].base);
+	}
+
+	spin_lock(&loongson_reglock);
+	writel(ldev->int_reg, base + FB_INT_REG);
+	spin_unlock(&loongson_reglock);
+
+	return IRQ_HANDLED;
+}
+
+static void loongson_irq_preinstall(struct drm_device *dev)
+{
+	unsigned long flags;
+	struct loongson_drm_device *ldev = dev->dev_private;
+	volatile void __iomem *base = ldev->mmio;
+
+	/* disable interupt */
+	spin_lock_irqsave(&loongson_reglock, flags);
+	writel(0x0000 << 16, base + FB_INT_REG);
+	spin_unlock_irqrestore(&loongson_reglock, flags);
+}
+
+static int loongson_irq_postinstall(struct drm_device *dev)
+{
+	return 0;
+}
+
+int loongson_irq_install(struct drm_device *dev, int irq)
+{
+	int ret;
+
+	if (irq == IRQ_NOTCONNECTED)
+		return -ENOTCONN;
+
+	loongson_irq_preinstall(dev);
+
+	/* PCI devices require shared interrupts. */
+	ret = request_irq(irq, loongson_irq_handler,
+			  IRQF_SHARED, dev->driver->name, dev);
+	if (ret)
+		return ret;
+
+	loongson_irq_postinstall(dev);
+
+	return 0;
+}
+
+void loongson_irq_uninstall(struct drm_device *dev)
+{
+	unsigned long flags;
+	struct loongson_drm_device *ldev = dev->dev_private;
+	volatile void __iomem *base = ldev->mmio;
+
+	/* disable interupt */
+	spin_lock_irqsave(&loongson_reglock, flags);
+	writel(0x0000 << 16, base + FB_INT_REG);
+	spin_unlock_irqrestore(&loongson_reglock, flags);
+}
diff --git a/drivers/gpu/drm/loongson/loongson_vbios.c b/drivers/gpu/drm/loongson/loongson_vbios.c
new file mode 100644
index 0000000000..1d12cf4e87
--- /dev/null
+++ b/drivers/gpu/drm/loongson/loongson_vbios.c
@@ -0,0 +1,857 @@
+/*
+ * Copyright (c) 2018 Loongson Technology Co., Ltd.
+ * Authors:
+ *	Chen Zhu <zhuchen@loongson.cn>
+ *	Yaling Fang <fangyaling@loongson.cn>
+ *	Dandan Zhang <zhangdandan@loongson.cn>
+ *	Huacai Chen <chenhc@lemote.com>
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include "loongson_drv.h"
+#include "loongson_vbios.h"
+
+#define VBIOS_START 0x1000
+#define VBIOS_SIZE  0x40000
+#define VBIOS_DESC_OFFSET 0x6000
+
+/* VBIOS INFO ADDRESS TABLE */
+struct acpi_viat_table {
+	struct acpi_table_header header;
+	unsigned long vbios_addr;
+} __packed;
+
+static u32 get_vbios_version(struct loongson_vbios *vbios)
+{
+	u32 minor, major, version;
+
+	minor = vbios->version_minor;
+	major = vbios->version_major;
+	version = major * 10 + minor;
+
+	return version;
+}
+
+static bool parse_vbios_i2c(struct desc_node *this, struct vbios_cmd *cmd)
+{
+	bool ret = true;
+	int i, num, size;
+	struct vbios_i2c *i2c;
+	struct vbios_i2c *vbios_i2c = NULL;
+	struct loongson_i2c *val = (struct loongson_i2c *)cmd->res;
+
+	size = this->desc->size;
+	vbios_i2c = kzalloc(size, GFP_KERNEL);
+	if (!vbios_i2c)
+		return false;
+
+	memset(vbios_i2c, 0xff, size);
+	memcpy(vbios_i2c, this->data, size);
+	num = size / sizeof(*vbios_i2c);
+
+	i2c = vbios_i2c;
+	for (i = 0; (i < num && i < DC_I2C_BUS_MAX); i++) {
+		val->i2c_id = (u32)i2c->id;
+		val->use = true;
+		val++;
+		i2c++;
+	}
+
+	kfree(vbios_i2c);
+	return ret;
+}
+
+static bool parse_vbios_crtc(struct desc_node *this, struct vbios_cmd *cmd)
+{
+	bool ret = true;
+	u64 request = (u64)cmd->req;
+	u32 *val = (u32 *)cmd->res;
+	struct vbios_crtc crtc;
+
+	memset(&crtc, 0xff, sizeof(crtc));
+	memcpy(&crtc, this->data, min_t(u32, this->desc->size, sizeof(crtc)));
+
+	switch (request) {
+	case VBIOS_CRTC_ID:
+		*val = crtc.crtc_id;
+		break;
+	case VBIOS_CRTC_ENCODER_ID:
+		*val = crtc.encoder_id;
+		break;
+	case VBIOS_CRTC_MAX_FREQ:
+		*val = crtc.max_freq;
+		break;
+	case VBIOS_CRTC_MAX_WIDTH:
+		*val = crtc.max_width;
+		break;
+	case VBIOS_CRTC_MAX_HEIGHT:
+		*val = crtc.max_height;
+		break;
+	case VBIOS_CRTC_IS_VB_TIMING:
+		*val = crtc.is_vb_timing;
+		break;
+	default:
+		ret = false;
+		break;
+	}
+
+	return ret;
+}
+
+static bool parse_vbios_encoder(struct desc_node *this, struct vbios_cmd *cmd)
+{
+	bool ret = true;
+	u64 request = (u64)cmd->req;
+	u32 *val = (u32 *)cmd->res;
+	struct vbios_encoder encoder;
+
+	memset(&encoder, 0xff, sizeof(encoder));
+	memcpy(&encoder, this->data,
+	       min_t(u32, this->desc->size, sizeof(encoder)));
+
+	switch (request) {
+	case VBIOS_ENCODER_I2C_ID:
+		*val = encoder.i2c_id;
+		break;
+	case VBIOS_ENCODER_CONNECTOR_ID:
+		*val = encoder.connector_id;
+		break;
+	case VBIOS_ENCODER_TYPE:
+		*val = encoder.type;
+		break;
+	case VBIOS_ENCODER_CONFIG_TYPE:
+		*val = encoder.config_type;
+		break;
+	case VBIOS_ENCODER_CHIP:
+		*val = encoder.chip;
+		break;
+	case VBIOS_ENCODER_CHIP_ADDR:
+		*val = encoder.chip_addr;
+		break;
+	default:
+		ret = false;
+		break;
+	}
+
+	return ret;
+}
+
+static bool parse_vbios_cfg_encoder(struct desc_node *this,
+				    struct vbios_cmd *cmd)
+{
+	bool ret = true;
+	u64 request = (u64)cmd->req;
+	u32 *val = (u32 *)cmd->res;
+	struct cfg_encoder *cfg_encoder;
+	struct cfg_encoder *cfg;
+	struct vbios_cfg_encoder *vbios_cfg_encoder;
+	u32 num, size, i = 0;
+
+	vbios_cfg_encoder = (struct vbios_cfg_encoder *)this->data;
+	size = sizeof(struct vbios_cfg_encoder);
+	num = this->desc->size / size;
+
+	switch (request) {
+	case VBIOS_ENCODER_CONFIG_PARAM:
+		cfg_encoder = (struct cfg_encoder *)kzalloc(
+			sizeof(struct cfg_encoder) * num, GFP_KERNEL);
+		cfg = cfg_encoder;
+		for (i = 0; i < num; i++) {
+			cfg->reg_num = vbios_cfg_encoder->reg_num;
+			cfg->hdisplay = vbios_cfg_encoder->hdisplay;
+			cfg->vdisplay = vbios_cfg_encoder->vdisplay;
+			memcpy(&cfg->config_regs,
+			       &vbios_cfg_encoder->config_regs,
+			       sizeof(struct vbios_conf_reg) * 256);
+
+			cfg++;
+			vbios_cfg_encoder++;
+		}
+		cmd->res = (void *)cfg_encoder;
+		break;
+	case VBIOS_ENCODER_CONFIG_NUM:
+		*val = num;
+		break;
+	default:
+		ret = false;
+		break;
+	}
+
+	return ret;
+}
+
+static bool parse_vbios_connector(struct desc_node *this, struct vbios_cmd *cmd)
+{
+	bool ret = true;
+	u64 request = (u64)cmd->req;
+	u32 *val = (u32 *)cmd->res;
+	struct vbios_connector connector;
+
+	memset(&connector, 0xff, sizeof(connector));
+	memcpy(&connector, this->data,
+	       min_t(u32, this->desc->size, sizeof(connector)));
+
+	switch (request) {
+	case VBIOS_CONNECTOR_I2C_ID:
+		*val = connector.i2c_id;
+		break;
+	case VBIOS_CONNECTOR_INTERNAL_EDID:
+		memcpy((u8 *)(ulong)val, connector.internal_edid,
+		       EDID_LENGTH * 2);
+		break;
+	case VBIOS_CONNECTOR_TYPE:
+		*val = connector.type;
+		break;
+	case VBIOS_CONNECTOR_HOTPLUG:
+		*val = connector.hotplug;
+		break;
+	case VBIOS_CONNECTOR_EDID_METHOD:
+		*val = connector.edid_method;
+		break;
+	case VBIOS_CONNECTOR_IRQ_GPIO:
+		*val = connector.irq_gpio;
+		break;
+	case VBIOS_CONNECTOR_IRQ_PLACEMENT:
+		*val = connector.gpio_placement;
+		break;
+	default:
+		ret = false;
+		break;
+	}
+
+	return ret;
+}
+
+static bool parse_vbios_backlight(struct desc_node *this, struct vbios_cmd *cmd)
+{
+	return 0;
+}
+
+static bool parse_vbios_pwm(struct desc_node *this, struct vbios_cmd *cmd)
+{
+	bool ret = true;
+	u64 request = (u64)cmd->req;
+	u32 *val = (u32 *)cmd->res;
+	struct vbios_pwm *pwm = (struct vbios_pwm *)this->data;
+
+	switch (request) {
+	case VBIOS_PWM_ID:
+		*val = pwm->pwm;
+		break;
+	case VBIOS_PWM_PERIOD:
+		*val = pwm->peroid;
+		break;
+	case VBIOS_PWM_POLARITY:
+		*val = pwm->polarity;
+		break;
+	default:
+		ret = false;
+		break;
+	}
+
+	return ret;
+}
+
+static bool parse_vbios_header(struct desc_node *this, struct vbios_cmd *cmd)
+{
+	return true;
+}
+
+static bool parse_vbios_default(struct desc_node *this, struct vbios_cmd *cmd)
+{
+	struct vbios_desc *vb_desc;
+
+	vb_desc = this->desc;
+	DRM_WARN("Current descriptor[T-%d][V-%d] cannot be interprete.\n",
+		 vb_desc->type, vb_desc->ver);
+	return false;
+}
+
+#define FUNC(t, v, f)                                                          \
+	{                                                                      \
+		.type = t, .ver = v, .func = f,                                \
+	}
+
+static struct desc_func tables[] = {
+	FUNC(desc_header, ver_v1, parse_vbios_header),
+	FUNC(desc_i2c, ver_v1, parse_vbios_i2c),
+	FUNC(desc_crtc, ver_v1, parse_vbios_crtc),
+	FUNC(desc_encoder, ver_v1, parse_vbios_encoder),
+	FUNC(desc_connector, ver_v1, parse_vbios_connector),
+	FUNC(desc_cfg_encoder, ver_v1, parse_vbios_cfg_encoder),
+	FUNC(desc_backlight, ver_v1, parse_vbios_backlight),
+	FUNC(desc_pwm, ver_v1, parse_vbios_pwm),
+};
+
+static inline parse_func *get_parse_func(struct vbios_desc *vb_desc)
+{
+	int i;
+	u32 type = vb_desc->type;
+	u32 ver = vb_desc->ver;
+	parse_func *func = parse_vbios_default;
+	u32 tt_num = ARRAY_SIZE(tables);
+
+	for (i = 0; i < tt_num; i++) {
+		if ((tables[i].ver == ver) && (tables[i].type == type)) {
+			func = tables[i].func;
+			break;
+		}
+	}
+
+	return func;
+}
+
+static inline u32 insert_desc_list(struct loongson_drm_device *ldev,
+				   struct vbios_desc *vb_desc)
+{
+	struct desc_node *node;
+	parse_func *func = NULL;
+
+	WARN_ON(!ldev || !vb_desc);
+	node = (struct desc_node *)kzalloc(sizeof(*node), GFP_KERNEL);
+	if (!node)
+		return -ENOMEM;
+
+	func = get_parse_func(vb_desc);
+	node->parse = func;
+	node->desc = (void *)vb_desc;
+	node->data = ((u8 *)ldev->vbios + vb_desc->offset);
+	list_add_tail(&node->head, &ldev->desc_list);
+
+	return 0;
+}
+
+static inline void free_desc_list(struct loongson_drm_device *ldev)
+{
+	struct desc_node *node, *tmp;
+
+	list_for_each_entry_safe (node, tmp, &ldev->desc_list, head) {
+		list_del(&node->head);
+		kfree(node);
+	}
+}
+
+#define DESC_LIST_MAX 1024
+
+static u32 parse_vbios_desc(struct loongson_drm_device *ldev)
+{
+	u32 i, ret = 0;
+	struct vbios_desc *desc;
+	enum desc_type type = 0;
+	u8 *vbios = (u8 *)ldev->vbios;
+
+	WARN_ON(!vbios);
+
+	desc = (struct vbios_desc *)(vbios + VBIOS_DESC_OFFSET);
+	for (i = 0; i < DESC_LIST_MAX; i++) {
+		type = desc->type;
+		if (type == desc_max)
+			break;
+
+		ret = insert_desc_list(ldev, desc);
+		if (ret)
+			DRM_DEBUG_KMS("Parse T-%d V-%d failed[%d]\n", desc->ver,
+				      desc->type, ret);
+
+		desc++;
+	}
+
+	return ret;
+}
+
+static inline struct desc_node *get_desc_node(struct loongson_drm_device *ldev,
+					      u16 type, u8 index)
+{
+	struct desc_node *node, *tmp;
+	struct vbios_desc *vb_desc;
+
+	list_for_each_entry_safe (node, tmp, &ldev->desc_list, head) {
+		vb_desc = node->desc;
+		if (vb_desc->type == type && vb_desc->index == index)
+			return node;
+	}
+
+	return NULL;
+}
+
+static bool vbios_get_data(struct loongson_drm_device *ldev, struct vbios_cmd *cmd)
+{
+	struct desc_node *node;
+
+	WARN_ON(!cmd);
+
+	node = get_desc_node(ldev, cmd->type, cmd->index);
+	if (node && node->parse)
+		return node->parse(node, cmd);
+
+	DRM_DEBUG_DRIVER("Failed to get node(%d,%d)\n", cmd->type, cmd->index);
+
+	return false;
+}
+
+u32 get_connector_type(struct loongson_drm_device *ldev, u32 index)
+{
+	u32 type = -1;
+	bool ret = false;
+	struct vbios_cmd vbt_cmd;
+
+	vbt_cmd.index = index;
+	vbt_cmd.type = desc_connector;
+	vbt_cmd.req = (void *)(ulong)VBIOS_CONNECTOR_TYPE;
+	vbt_cmd.res = (void *)(ulong)&type;
+	ret = vbios_get_data(ldev, &vbt_cmd);
+	if (!ret)
+		type = -1;
+
+	return type;
+}
+
+u16 get_connector_i2cid(struct loongson_drm_device *ldev, u32 index)
+{
+	u16 i2c_id = -1;
+	bool ret = false;
+	struct vbios_cmd vbt_cmd;
+
+	vbt_cmd.index = index;
+	vbt_cmd.type = desc_connector;
+	vbt_cmd.req = (void *)(ulong)VBIOS_CONNECTOR_I2C_ID;
+	vbt_cmd.res = (void *)(ulong)&i2c_id;
+	ret = vbios_get_data(ldev, &vbt_cmd);
+	if (!ret)
+		i2c_id = -1;
+
+	return i2c_id;
+}
+
+u32 get_connector_irq_gpio(struct loongson_drm_device *ldev, u32 index)
+{
+	int ret;
+	u32 irq_gpio;
+	struct vbios_cmd vbt_cmd;
+
+	vbt_cmd.index = index;
+	vbt_cmd.type = desc_connector;
+	vbt_cmd.req = (void *)(ulong)VBIOS_CONNECTOR_IRQ_GPIO;
+	vbt_cmd.res = (void *)(ulong)&irq_gpio;
+	ret = vbios_get_data(ldev, &vbt_cmd);
+	if (!ret)
+		return -1;
+
+	return irq_gpio;
+}
+
+enum gpio_placement get_connector_gpio_placement(struct loongson_drm_device *ldev,
+						 u32 index)
+{
+	int ret;
+	enum gpio_placement irq_placement;
+	struct vbios_cmd vbt_cmd;
+
+	vbt_cmd.index = index;
+	vbt_cmd.type = desc_connector;
+	vbt_cmd.req = (void *)(ulong)VBIOS_CONNECTOR_IRQ_PLACEMENT;
+	vbt_cmd.res = (void *)(ulong)&irq_placement;
+	ret = vbios_get_data(ldev, &vbt_cmd);
+	if (!ret)
+		return -1;
+
+	return irq_placement;
+}
+
+u16 get_hotplug_mode(struct loongson_drm_device *ldev, u32 index)
+{
+	u16 mode = -1;
+	bool ret = false;
+	struct vbios_cmd vbt_cmd;
+
+	vbt_cmd.index = index;
+	vbt_cmd.type = desc_connector;
+	vbt_cmd.req = (void *)(ulong)VBIOS_CONNECTOR_HOTPLUG;
+	vbt_cmd.res = (void *)(ulong)&mode;
+	ret = vbios_get_data(ldev, &vbt_cmd);
+	if (!ret)
+		mode = -1;
+
+	return mode;
+}
+
+u16 get_edid_method(struct loongson_drm_device *ldev, u32 index)
+{
+	bool ret = false;
+	u16 method = via_null;
+	struct vbios_cmd vbt_cmd;
+
+	vbt_cmd.index = index;
+	vbt_cmd.type = desc_connector;
+	vbt_cmd.req = (void *)(ulong)VBIOS_CONNECTOR_EDID_METHOD;
+	vbt_cmd.res = (void *)(ulong)&method;
+	ret = vbios_get_data(ldev, &vbt_cmd);
+	if (!ret)
+		method = via_null;
+
+	return method;
+}
+
+u8 *get_vbios_edid(struct loongson_drm_device *ldev, u32 index)
+{
+	u8 *edid = NULL;
+	bool ret = false;
+	struct vbios_cmd vbt_cmd;
+
+	edid = kzalloc(sizeof(u8) * EDID_LENGTH * 2, GFP_KERNEL);
+	if (!edid)
+		return edid;
+
+	vbt_cmd.index = index;
+	vbt_cmd.type = desc_connector;
+	vbt_cmd.req = (void *)(ulong)VBIOS_CONNECTOR_INTERNAL_EDID;
+	vbt_cmd.res = (void *)(ulong)edid;
+	ret = vbios_get_data(ldev, &vbt_cmd);
+	if (!ret)
+		return NULL;
+
+	return edid;
+}
+
+u32 get_vbios_pwm(struct loongson_drm_device *ldev, u32 index, u16 request)
+{
+	u32 value = -1;
+	bool ret = false;
+	struct vbios_cmd vbt_cmd;
+
+	vbt_cmd.index = index;
+	vbt_cmd.type = desc_pwm;
+	vbt_cmd.req = (void *)(ulong)request;
+	vbt_cmd.res = (void *)(ulong)&value;
+	ret = vbios_get_data(ldev, &vbt_cmd);
+	if (!ret)
+		value = 0xffffffff;
+
+	return value;
+}
+
+u32 get_crtc_id(struct loongson_drm_device *ldev, u32 index)
+{
+	u32 crtc_id = 0;
+	bool ret = false;
+	struct vbios_cmd vbt_cmd;
+
+	vbt_cmd.index = index;
+	vbt_cmd.type = desc_crtc;
+	vbt_cmd.req = (void *)(ulong)VBIOS_CRTC_ID;
+	vbt_cmd.res = (void *)(ulong)&crtc_id;
+	ret = vbios_get_data(ldev, &vbt_cmd);
+	if (!ret)
+		crtc_id = 0;
+
+	return crtc_id;
+}
+
+u32 get_crtc_max_freq(struct loongson_drm_device *ldev, u32 index)
+{
+	bool ret = false;
+	u32 max_freq = 0;
+	struct vbios_cmd vbt_cmd;
+
+	vbt_cmd.index = index;
+	vbt_cmd.type = desc_crtc;
+	vbt_cmd.req = (void *)(ulong)VBIOS_CRTC_MAX_FREQ;
+	vbt_cmd.res = (void *)(ulong)&max_freq;
+	ret = vbios_get_data(ldev, &vbt_cmd);
+	if (!ret)
+		max_freq = 0;
+
+	return max_freq;
+}
+
+u32 get_crtc_max_width(struct loongson_drm_device *ldev, u32 index)
+{
+	bool ret = false;
+	u32 max_width = 0;
+	struct vbios_cmd vbt_cmd;
+
+	vbt_cmd.index = index;
+	vbt_cmd.type = desc_crtc;
+	vbt_cmd.req = (void *)(ulong)VBIOS_CRTC_MAX_WIDTH;
+	vbt_cmd.res = (void *)(ulong)&max_width;
+	ret = vbios_get_data(ldev, &vbt_cmd);
+	if (!ret)
+		max_width = LOONGSON_MAX_FB_WIDTH;
+
+	return max_width;
+}
+
+u32 get_crtc_max_height(struct loongson_drm_device *ldev, u32 index)
+{
+	bool ret = false;
+	u32 max_height = 0;
+	struct vbios_cmd vbt_cmd;
+
+	vbt_cmd.index = index;
+	vbt_cmd.type = desc_crtc;
+	vbt_cmd.req = (void *)(ulong)VBIOS_CRTC_MAX_HEIGHT;
+	vbt_cmd.res = (void *)(ulong)&max_height;
+	ret = vbios_get_data(ldev, &vbt_cmd);
+	if (!ret)
+		max_height = LOONGSON_MAX_FB_HEIGHT;
+
+	return max_height;
+}
+
+u32 get_crtc_encoder_id(struct loongson_drm_device *ldev, u32 index)
+{
+	bool ret = false;
+	u32 encoder_id = 0;
+	struct vbios_cmd vbt_cmd;
+
+	vbt_cmd.index = index;
+	vbt_cmd.type = desc_crtc;
+	vbt_cmd.req = (void *)(ulong)VBIOS_CRTC_ENCODER_ID;
+	vbt_cmd.res = (void *)(ulong)&encoder_id;
+	ret = vbios_get_data(ldev, &vbt_cmd);
+	if (!ret)
+		encoder_id = 0;
+
+	return encoder_id;
+}
+
+bool get_crtc_is_vb_timing(struct loongson_drm_device *ldev, u32 index)
+{
+	bool ret = false;
+	bool vb_timing = false;
+	struct vbios_cmd vbt_cmd;
+
+	vbt_cmd.index = index;
+	vbt_cmd.type = desc_crtc;
+	vbt_cmd.req = (void *)(ulong)VBIOS_CRTC_IS_VB_TIMING;
+	vbt_cmd.res = (void *)(ulong)&vb_timing;
+	ret = vbios_get_data(ldev, &vbt_cmd);
+	if (!ret)
+		vb_timing = false;
+
+	return vb_timing;
+}
+
+struct crtc_timing *get_crtc_timing(struct loongson_drm_device *ldev, u32 index)
+{
+	return NULL;
+}
+
+u32 get_encoder_connector_id(struct loongson_drm_device *ldev, u32 index)
+{
+	bool ret = false;
+	u32 connector_id = 0;
+	struct vbios_cmd vbt_cmd;
+
+	vbt_cmd.index = index;
+	vbt_cmd.type = desc_encoder;
+	vbt_cmd.req = (void *)(ulong)VBIOS_ENCODER_CONNECTOR_ID;
+	vbt_cmd.res = (void *)(ulong)&connector_id;
+	ret = vbios_get_data(ldev, &vbt_cmd);
+	if (!ret)
+		connector_id = 0;
+
+	return connector_id;
+}
+
+u32 get_encoder_i2c_id(struct loongson_drm_device *ldev, u32 index)
+{
+	u32 i2c_id = 0;
+	bool ret = false;
+	struct vbios_cmd vbt_cmd;
+
+	vbt_cmd.index = index;
+	vbt_cmd.type = desc_encoder;
+	vbt_cmd.req = (void *)(ulong)VBIOS_ENCODER_I2C_ID;
+	vbt_cmd.res = (void *)(ulong)&i2c_id;
+	ret = vbios_get_data(ldev, &vbt_cmd);
+	if (!ret)
+		i2c_id = 0;
+
+	return i2c_id;
+}
+
+struct cfg_encoder *get_encoder_config(struct loongson_drm_device *ldev, u32 index)
+{
+	bool ret = false;
+	struct vbios_cmd vbt_cmd;
+	struct cfg_encoder *encoder_config = NULL;
+
+	vbt_cmd.index = index;
+	vbt_cmd.type = desc_cfg_encoder;
+	vbt_cmd.req = (void *)(ulong)VBIOS_ENCODER_CONFIG_PARAM;
+	ret = vbios_get_data(ldev, &vbt_cmd);
+	if (ret)
+		encoder_config = (struct cfg_encoder *)vbt_cmd.res;
+
+	return encoder_config;
+}
+
+u32 get_encoder_cfg_num(struct loongson_drm_device *ldev, u32 index)
+{
+	struct vbios_cmd vbt_cmd;
+	bool ret = false;
+	u32 cfg_num = 0;
+
+	vbt_cmd.index = index;
+	vbt_cmd.type = desc_cfg_encoder;
+	vbt_cmd.req = (void *)(ulong)VBIOS_ENCODER_CONFIG_NUM;
+	vbt_cmd.res = (void *)(ulong)&cfg_num;
+	ret = vbios_get_data(ldev, &vbt_cmd);
+	if (!ret)
+		cfg_num = 0;
+
+	return cfg_num;
+}
+
+enum encoder_config get_encoder_config_type(struct loongson_drm_device *ldev,
+					    u32 index)
+{
+	bool ret = false;
+	enum encoder_config config_type = encoder_bios_config;
+	struct vbios_cmd vbt_cmd;
+
+	vbt_cmd.index = index;
+	vbt_cmd.type = desc_encoder;
+	vbt_cmd.req = (void *)(ulong)VBIOS_ENCODER_CONFIG_TYPE;
+	vbt_cmd.res = (void *)(ulong)&config_type;
+	ret = vbios_get_data(ldev, &vbt_cmd);
+	if (!ret)
+		config_type = encoder_bios_config;
+
+	return config_type;
+}
+
+enum encoder_object get_encoder_chip(struct loongson_drm_device *ldev, u32 index)
+{
+	int ret;
+	enum encoder_object chip;
+	struct vbios_cmd vbt_cmd;
+
+	vbt_cmd.index = index;
+	vbt_cmd.type = desc_encoder;
+	vbt_cmd.req = (void *)(ulong)VBIOS_ENCODER_CHIP;
+	vbt_cmd.res = (void *)(ulong)&chip;
+	ret = vbios_get_data(ldev, &vbt_cmd);
+	if (!ret)
+		return Unknown;
+
+	return chip;
+}
+
+u8 get_encoder_chip_addr(struct loongson_drm_device *ldev, u32 index)
+{
+	int ret;
+	u8 chip_addr;
+	struct vbios_cmd vbt_cmd;
+
+	vbt_cmd.index = index;
+	vbt_cmd.type = desc_encoder;
+	vbt_cmd.req = (void *)(ulong)VBIOS_ENCODER_CHIP_ADDR;
+	vbt_cmd.res = (void *)(ulong)&chip_addr;
+	ret = vbios_get_data(ldev, &vbt_cmd);
+	if (!ret)
+		return Unknown;
+
+	return chip_addr;
+}
+
+enum encoder_type get_encoder_type(struct loongson_drm_device *ldev, u32 index)
+{
+	bool ret = false;
+	enum encoder_type type = encoder_dac;
+	struct vbios_cmd vbt_cmd;
+
+	vbt_cmd.index = index;
+	vbt_cmd.type = desc_encoder;
+	vbt_cmd.req = (void *)(ulong)VBIOS_ENCODER_TYPE;
+	vbt_cmd.res = (void *)(ulong)&type;
+	ret = vbios_get_data(ldev, &vbt_cmd);
+	if (!ret)
+		type = encoder_dac;
+
+	return type;
+}
+
+bool get_loongson_i2c(struct loongson_drm_device *ldev)
+{
+	bool ret = false;
+	struct vbios_cmd vbt_cmd;
+
+	vbt_cmd.index = 0;
+	vbt_cmd.type = desc_i2c;
+	vbt_cmd.res = (void *)&ldev->i2c_bus;
+	ret = vbios_get_data(ldev, &vbt_cmd);
+
+	if (!ret) {
+		ldev->i2c_bus[0].use = true;
+		ldev->i2c_bus[1].use = true;
+	}
+
+	return true;
+}
+
+static void *get_vbios_from_acpi(void)
+{
+	void *vbios = NULL;
+#ifdef CONFIG_ACPI
+	struct acpi_viat_table *viat;
+	struct acpi_table_header *hdr;
+
+	if (!ACPI_SUCCESS(acpi_get_table("VIAT", 1, &hdr)))
+		return NULL;
+
+	if (hdr->length != sizeof(struct acpi_viat_table)) {
+		DRM_WARN("ACPI VIAT table present but broken (length error)\n");
+		return NULL;
+	}
+
+	vbios = kmalloc(VBIOS_SIZE, GFP_KERNEL);
+	if (!vbios)
+		return NULL;
+
+	viat = (struct acpi_viat_table *)hdr;
+	memcpy(vbios, phys_to_virt(viat->vbios_addr), VBIOS_SIZE);
+
+	DRM_INFO("Get VBIOS from ACPI success!\n");
+#endif
+	return vbios;
+}
+
+bool loongson_vbios_init(struct loongson_drm_device *ldev)
+{
+	void *vbios = NULL;
+	struct loongson_vbios *header;
+
+	vbios = get_vbios_from_acpi();
+	if (vbios)
+		goto success;
+
+	vbios = kzalloc(256 * 1024, GFP_KERNEL);
+	if (!vbios)
+		return false;
+
+	header = vbios;
+	header->crtc_num = 2;
+
+success:
+	header = ldev->vbios = vbios;
+	ldev->num_crtc = header->crtc_num;
+
+	DRM_INFO("Loongson VBIOS version %d.%d\n", header->version_major,
+		 header->version_minor);
+
+	INIT_LIST_HEAD(&ldev->desc_list);
+	parse_vbios_desc(ldev);
+
+	return true;
+}
+
+void loongson_vbios_exit(struct loongson_drm_device *ldev)
+{
+	free_desc_list(ldev);
+	kfree(ldev->vbios);
+}
diff --git a/drivers/gpu/drm/loongson/loongson_vbios.h b/drivers/gpu/drm/loongson/loongson_vbios.h
new file mode 100644
index 0000000000..25ae943a6c
--- /dev/null
+++ b/drivers/gpu/drm/loongson/loongson_vbios.h
@@ -0,0 +1,283 @@
+#ifndef __LOONGSON_VBIOS_H__
+#define __LOONGSON_VBIOS_H__
+
+#define VBIOS_PWM_ID 0x0
+#define VBIOS_PWM_PERIOD 0x1
+#define VBIOS_PWM_POLARITY 0x2
+
+#define VBIOS_CRTC_ID 0x1
+#define VBIOS_CRTC_ENCODER_ID 0x2
+#define VBIOS_CRTC_MAX_FREQ 0x3
+#define VBIOS_CRTC_MAX_WIDTH 0x4
+#define VBIOS_CRTC_MAX_HEIGHT 0x5
+#define VBIOS_CRTC_IS_VB_TIMING 0x6
+
+#define VBIOS_ENCODER_I2C_ID 0x1
+#define VBIOS_ENCODER_CONNECTOR_ID 0x2
+#define VBIOS_ENCODER_TYPE 0x3
+#define VBIOS_ENCODER_CONFIG_TYPE 0x4
+#define VBIOS_ENCODER_CONFIG_PARAM 0x1
+#define VBIOS_ENCODER_CONFIG_NUM 0x2
+#define VBIOS_ENCODER_CHIP 0x05
+#define VBIOS_ENCODER_CHIP_ADDR 0x06
+
+#define VBIOS_CONNECTOR_I2C_ID 0x1
+#define VBIOS_CONNECTOR_INTERNAL_EDID 0x2
+#define VBIOS_CONNECTOR_TYPE 0x3
+#define VBIOS_CONNECTOR_HOTPLUG 0x4
+#define VBIOS_CONNECTOR_EDID_METHOD 0x5
+#define VBIOS_CONNECTOR_IRQ_PLACEMENT 0x06
+#define VBIOS_CONNECTOR_IRQ_GPIO 0x07
+
+struct desc_node;
+struct vbios_cmd;
+typedef bool(parse_func)(struct desc_node *, struct vbios_cmd *);
+
+enum desc_type {
+	desc_header = 0,
+	desc_crtc,
+	desc_encoder,
+	desc_connector,
+	desc_i2c,
+	desc_pwm,
+	desc_gpio,
+	desc_backlight,
+	desc_fan,
+	desc_irq_vblank,
+	desc_cfg_encoder,
+	desc_max = 0xffff
+};
+
+enum desc_ver {
+	ver_v1,
+};
+
+enum hotplug {
+	disable = 0,
+	polling,
+	irq,
+	hotplug_max = 0xffffffff,
+};
+
+enum loongson_edid_method {
+	via_null = 0,
+	via_i2c,
+	via_vbios,
+	via_encoder,
+	via_max = 0xffffffff,
+};
+
+enum i2c_type { i2c_cpu, i2c_gpio, i2c_max = -1 };
+
+enum vbios_backlight_type { bl_unuse, bl_ec, bl_pwm };
+
+enum encoder_config {
+	encoder_transparent = 0,
+	encoder_os_config,
+	encoder_bios_config,
+	encoder_timing_filling,
+	encoder_kernel_driver,
+	encoder_type_max = 0xffffffff,
+};
+
+enum encoder_type {
+	encoder_none,
+	encoder_dac,
+	encoder_tmds,
+	encoder_lvds,
+	encoder_tvdac,
+	encoder_virtual,
+	encoder_dsi,
+	encoder_dpmst,
+	encoder_dpi
+};
+
+enum connector_type {
+	connector_unknown,
+	connector_vga,
+	connector_dvii,
+	connector_dvid,
+	connector_dvia,
+	connector_composite,
+	connector_svideo,
+	connector_lvds,
+	connector_component,
+	connector_9pindin,
+	connector_displayport,
+	connector_hdmia,
+	connector_hdmib,
+	connector_tv,
+	connector_edp,
+	connector_virtual,
+	connector_dsi,
+	connector_dpi
+};
+
+enum gpio_placement {
+	GPIO_PLACEMENT_LS3A = 0,
+	GPIO_PLACEMENT_LS7A,
+};
+
+enum encoder_object {
+	Unknown = 0x00,
+	INTERNAL_DVO = 0x01,
+	INTERNAL_HDMI = 0x02,
+	VGA_CH7055 = 0x10,
+	VGA_ADV7125 = 0x11,
+	DVI_TFP410 = 0x20,
+	HDMI_IT66121 = 0x30,
+	HDMI_SIL9022 = 0x31,
+	HDMI_LT8618 = 0x32,
+	HDMI_MS7210 = 0x33,
+	EDP_NCS8805 = 0x40
+};
+
+struct loongson_vbios {
+	char title[16];
+	uint32_t version_major;
+	uint32_t version_minor;
+	char information[20];
+	uint32_t crtc_num;
+	uint32_t crtc_offset;
+	uint32_t connector_num;
+	uint32_t connector_offset;
+	uint32_t encoder_num;
+	uint32_t encoder_offset;
+} __packed;
+
+struct vbios_header {
+	u32 feature;
+	u8 oem_vendor[32];
+	u8 oem_product[32];
+	u32 legacy_offset;
+	u32 legacy_size;
+	u32 desc_offset;
+	u32 desc_size;
+	u32 data_offset;
+	u32 data_size;
+} __packed;
+
+struct vbios_backlight {
+	u32 feature;
+	u8 used;
+	enum vbios_backlight_type type;
+} __packed;
+
+struct vbios_i2c {
+	u32 feature;
+	u16 id;
+	enum i2c_type type;
+} __packed;
+
+struct vbios_pwm {
+	u32 feature;
+	u8 pwm;
+	u8 polarity;
+	u32 peroid;
+} __packed;
+
+struct vbios_desc {
+	u16 type;
+	u8 ver;
+	u8 index;
+	u32 offset;
+	u32 size;
+	u64 ext[2];
+} __packed;
+
+struct vbios_cmd {
+	u8 index;
+	enum desc_type type;
+	u64 *req;
+	void *res;
+};
+
+struct desc_func {
+	enum desc_type type;
+	u16 ver;
+	s8 *name;
+	u8 index;
+	parse_func *func;
+};
+
+struct desc_node {
+	struct list_head head;
+	u8 *data;
+	struct vbios_desc *desc;
+	parse_func *parse;
+};
+
+struct vbios_crtc {
+	u32 feature;
+	u32 crtc_id;
+	u32 encoder_id;
+	u32 max_freq;
+	u32 max_width;
+	u32 max_height;
+	bool is_vb_timing;
+} __packed;
+
+struct vbios_encoder {
+	u32 feature;
+	u32 i2c_id;
+	u32 connector_id;
+	enum encoder_type type;
+	enum encoder_config config_type;
+	enum encoder_object chip;
+	u8 chip_addr;
+} __packed;
+
+struct vbios_connector {
+	u32 feature;
+	u32 i2c_id;
+	u8 internal_edid[256];
+	enum connector_type type;
+	enum hotplug hotplug;
+	enum loongson_edid_method edid_method;
+	u32 irq_gpio;
+	enum gpio_placement gpio_placement;
+} __packed;
+
+struct vbios_conf_reg {
+	u8 dev_addr;
+	u8 reg;
+	u8 value;
+} __packed;
+
+struct vbios_cfg_encoder {
+	u32 hdisplay;
+	u32 vdisplay;
+	u8 reg_num;
+	struct vbios_conf_reg config_regs[256];
+} __packed;
+
+bool loongson_vbios_init(struct loongson_drm_device *ldev);
+void loongson_vbios_exit(struct loongson_drm_device *ldev);
+u32 get_connector_type(struct loongson_drm_device *ldev, u32 index);
+u16 get_connector_i2cid(struct loongson_drm_device *ldev, u32 index);
+u16 get_hotplug_mode(struct loongson_drm_device *ldev, u32 index);
+u8 *get_vbios_edid(struct loongson_drm_device *ldev, u32 index);
+u16 get_edid_method(struct loongson_drm_device *ldev, u32 index);
+u32 get_vbios_pwm(struct loongson_drm_device *ldev, u32 index, u16 request);
+u32 get_crtc_id(struct loongson_drm_device *ldev, u32 index);
+u32 get_crtc_max_freq(struct loongson_drm_device *ldev, u32 index);
+u32 get_crtc_max_width(struct loongson_drm_device *ldev, u32 index);
+u32 get_crtc_max_height(struct loongson_drm_device *ldev, u32 index);
+u32 get_crtc_encoder_id(struct loongson_drm_device *ldev, u32 index);
+bool get_crtc_is_vb_timing(struct loongson_drm_device *ldev, u32 index);
+
+struct crtc_timing *get_crtc_timing(struct loongson_drm_device *ldev, u32 index);
+
+bool get_loongson_i2c(struct loongson_drm_device *ldev);
+u32 get_encoder_i2c_id(struct loongson_drm_device *ldev, u32 index);
+u32 get_encoder_connector_id(struct loongson_drm_device *ldev, u32 index);
+enum encoder_config get_encoder_config_type(struct loongson_drm_device *ldev, u32 index);
+enum encoder_type get_encoder_type(struct loongson_drm_device *ldev, u32 index);
+struct cfg_encoder *get_encoder_config(struct loongson_drm_device *ldev, u32 index);
+u32 get_encoder_cfg_num(struct loongson_drm_device *ldev, u32 index);
+enum encoder_object get_encoder_chip(struct loongson_drm_device *ldev, u32 index);
+u8 get_encoder_chip_addr(struct loongson_drm_device *ldev, u32 index);
+u32 get_connector_irq_gpio(struct loongson_drm_device *ldev, u32 index);
+enum gpio_placement get_connector_gpio_placement(struct loongson_drm_device *ldev,
+						 u32 index);
+#endif
-- 
2.39.1

