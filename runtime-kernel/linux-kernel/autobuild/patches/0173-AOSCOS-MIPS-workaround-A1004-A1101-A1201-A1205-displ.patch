From 8d72786e5e48053aae25a82ce8b869c61ba5c052 Mon Sep 17 00:00:00 2001
From: Huacai Chen <chenhc@lemote.com>
Date: Thu, 1 Dec 2016 09:51:35 +0800
Subject: [PATCH 173/274] AOSCOS: MIPS: workaround A1004/A1101/A1201/A1205
 display issues

1. Do not enable LVDS(A1004)/VGA(A1101) output until modeset initializes
   to workaround display corruption (flashing lines).
2. Turn on A1201/A1205's LVDS after GPU initilization.

[Mingcong Bai: Revised title to reflect changes better. Resolved merge
conflicts in the following...

  arch/mips/loongson64/platform.c
  arch/mips/loongson64/workarounds.c
  drivers/gpu/drm/radeon/radeon_kms.c

Moved arch/mips/loongson64/loongson-3/Makefile
  => arch/mips/loongson64/Makefile and revised accordingly

Original commit message:

  For A1004/A1101/A1201/A1205 display workaround.

  1, Do not enable LVDS(A1004)/VGA(A1101) output until modeset init,
     to workaround strange display. It has flash-line sometimes.
  2, Turn off A1201/A1205's lvds before gpu initilization and turn on it
     after that.]

Signed-off-by: Huacai Chen <chenhc@lemote.com>
Signed-off-by: Hongliang Tao <taohl@lemote.com>
Signed-off-by: Hua Yan <yanh@lemote.com>
Signed-off-by: Mingcong Bai <jeffbai@aosc.io>

Signed-off-by: Kexy Biscuit <kexybiscuit@aosc.io>
---
 .../include/asm/mach-loongson64/workarounds.h |  2 +
 arch/mips/loongson64/Makefile                 |  2 +-
 arch/mips/loongson64/platform.c               | 17 +++++++++
 arch/mips/loongson64/workarounds.c            | 37 +++++++++++++++++++
 drivers/gpu/drm/drm_crtc_helper.c             | 12 ++++++
 drivers/gpu/drm/radeon/radeon_kms.c           | 11 ++++++
 6 files changed, 80 insertions(+), 1 deletion(-)
 create mode 100644 arch/mips/loongson64/workarounds.c

diff --git a/arch/mips/include/asm/mach-loongson64/workarounds.h b/arch/mips/include/asm/mach-loongson64/workarounds.h
index 17b71172a097..a38cbc2a5a44 100644
--- a/arch/mips/include/asm/mach-loongson64/workarounds.h
+++ b/arch/mips/include/asm/mach-loongson64/workarounds.h
@@ -4,5 +4,7 @@
 
 #define WORKAROUND_CPUFREQ	0x00000001
 #define WORKAROUND_CPUHOTPLUG	0x00000002
+#define WORKAROUND_LVDS_EC 	0x00000004
+#define WORKAROUND_LVDS_GPIO	0x00000008
 
 #endif
diff --git a/arch/mips/loongson64/Makefile b/arch/mips/loongson64/Makefile
index 8de79d904678..27a7555972b8 100644
--- a/arch/mips/loongson64/Makefile
+++ b/arch/mips/loongson64/Makefile
@@ -5,7 +5,7 @@
 obj-$(CONFIG_MACH_LOONGSON64) += cop2-ex.o dma.o \
 				setup.o init.o env.o time.o reset.o \
 				clock.o constant_timer.o ec_wpce775l.o \
-				platform.o \
+				platform.o workarounds.o \
 
 obj-$(CONFIG_SMP)	+= smp.o
 obj-$(CONFIG_NUMA)	+= numa.o
diff --git a/arch/mips/loongson64/platform.c b/arch/mips/loongson64/platform.c
index a447eab0218d..eab6afbcad5c 100644
--- a/arch/mips/loongson64/platform.c
+++ b/arch/mips/loongson64/platform.c
@@ -6,6 +6,8 @@
  *         Chen Huacai, chenhc@lemote.com
  */
 
+#include <linux/gpio.h>
+#include <linux/delay.h>
 #include <linux/platform_device.h>
 #include <loongson_hwmon.h>
 
@@ -65,3 +67,18 @@ struct loongson_fan_policy step_speed_policy = {
 struct loongson_fan_policy constant_speed_policy = {
 	.type = CONSTANT_SPEED_POLICY,
 };
+
+#define GPIO_LCD_CNTL		5
+#define GPIO_BACKLIGHIT_CNTL	7
+
+static int __init loongson3_platform_init(void)
+{
+	if (loongson_sysconf.workarounds & WORKAROUND_LVDS_GPIO) {
+		gpio_request(GPIO_LCD_CNTL,  "gpio_lcd_cntl");
+		gpio_request(GPIO_BACKLIGHIT_CNTL, "gpio_bl_cntl");
+	}
+
+	return 0;
+}
+
+arch_initcall(loongson3_platform_init);
diff --git a/arch/mips/loongson64/workarounds.c b/arch/mips/loongson64/workarounds.c
new file mode 100644
index 000000000000..13b26d17b941
--- /dev/null
+++ b/arch/mips/loongson64/workarounds.c
@@ -0,0 +1,37 @@
+#include <linux/delay.h>
+#include <linux/gpio.h>
+#include <asm/bootinfo.h>
+#include <ec_wpce775l.h>
+#include <workarounds.h>
+
+#define GPIO_LCD_CNTL		5
+#define GPIO_BACKLIGHIT_CNTL	7
+
+void gpio_lvds_off(void)
+{
+	gpio_direction_output(GPIO_BACKLIGHIT_CNTL, 0);
+	gpio_direction_output(GPIO_LCD_CNTL, 0);
+}
+
+static void gpio_lvds_on(void)
+{
+	gpio_direction_output(GPIO_LCD_CNTL, 1);
+	msleep(250);
+	gpio_direction_output(GPIO_BACKLIGHIT_CNTL, 1);
+}
+
+void turn_off_lvds(void)
+{
+	if (loongson_sysconf.workarounds & WORKAROUND_LVDS_EC)
+		ec_write(INDEX_BACKLIGHT_STSCTRL, BACKLIGHT_OFF);
+	if (loongson_sysconf.workarounds & WORKAROUND_LVDS_GPIO)
+		gpio_lvds_off();
+}
+
+void turn_on_lvds(void)
+{
+	if (loongson_sysconf.workarounds & WORKAROUND_LVDS_EC)
+		ec_write(INDEX_BACKLIGHT_STSCTRL, BACKLIGHT_ON);
+	if (loongson_sysconf.workarounds & WORKAROUND_LVDS_GPIO)
+		gpio_lvds_on();
+}
diff --git a/drivers/gpu/drm/drm_crtc_helper.c b/drivers/gpu/drm/drm_crtc_helper.c
index 0955f1c385dd..e2cc92abec9a 100644
--- a/drivers/gpu/drm/drm_crtc_helper.c
+++ b/drivers/gpu/drm/drm_crtc_helper.c
@@ -886,6 +886,10 @@ static int drm_helper_choose_crtc_dpms(struct drm_crtc *crtc)
 	return dpms;
 }
 
+#ifdef CONFIG_CPU_LOONGSON3
+void turn_off_lvds(void);
+void turn_on_lvds(void);
+#endif
 /**
  * drm_helper_connector_dpms() - connector dpms helper implementation
  * @connector: affected connector
@@ -926,6 +930,10 @@ int drm_helper_connector_dpms(struct drm_connector *connector, int mode)
 
 	/* from off to on, do crtc then encoder */
 	if (mode < old_dpms) {
+#ifdef CONFIG_CPU_LOONGSON3
+		if(connector->connector_type == DRM_MODE_CONNECTOR_LVDS)
+			turn_on_lvds();
+#endif
 		if (crtc) {
 			const struct drm_crtc_helper_funcs *crtc_funcs = crtc->helper_private;
 
@@ -939,6 +947,10 @@ int drm_helper_connector_dpms(struct drm_connector *connector, int mode)
 
 	/* from on to off, do encoder then crtc */
 	if (mode > old_dpms) {
+#ifdef CONFIG_CPU_LOONGSON3
+		if(connector->connector_type == DRM_MODE_CONNECTOR_LVDS)
+			turn_off_lvds();
+#endif
 		if (encoder)
 			drm_helper_encoder_dpms(encoder, encoder_dpms);
 		if (crtc) {
diff --git a/drivers/gpu/drm/radeon/radeon_kms.c b/drivers/gpu/drm/radeon/radeon_kms.c
index 645e33bf7947..59613adaa283 100644
--- a/drivers/gpu/drm/radeon/radeon_kms.c
+++ b/drivers/gpu/drm/radeon/radeon_kms.c
@@ -88,6 +88,10 @@ void radeon_driver_unload_kms(struct drm_device *dev)
 	dev->dev_private = NULL;
 }
 
+#ifdef CONFIG_CPU_LOONGSON3
+extern void turn_on_lvds(void);
+extern void turn_off_lvds(void);
+#endif
 /**
  * radeon_driver_load_kms - Main load function for KMS.
  *
@@ -119,6 +123,9 @@ int radeon_driver_load_kms(struct drm_device *dev, unsigned long flags)
 			rdev->agp->agp_info.aper_size *
 			1024 * 1024);
 	}
+#ifdef CONFIG_CPU_LOONGSON3
+	turn_off_lvds();
+#endif
 
 	/* update BUS flag */
 	if (pci_find_capability(pdev, PCI_CAP_ID_AGP)) {
@@ -155,6 +162,10 @@ int radeon_driver_load_kms(struct drm_device *dev, unsigned long flags)
 	if (r)
 		dev_err(dev->dev, "Fatal error during modeset init\n");
 
+#ifdef CONFIG_CPU_LOONGSON3
+	turn_on_lvds();
+#endif
+
 	/* Call ACPI methods: require modeset init
 	 * but failure is not fatal
 	 */
-- 
2.47.1

