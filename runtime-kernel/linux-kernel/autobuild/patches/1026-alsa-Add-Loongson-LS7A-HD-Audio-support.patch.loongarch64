From 8b1f454b4e8b01b86145d89c0fb59e3c4141e74e Mon Sep 17 00:00:00 2001
From: Huacai Chen <chenhc@lemote.com>
Date: Thu, 1 Dec 2016 09:51:35 +0800
Subject: [PATCH 26/43] alsa: Add Loongson LS7A HD-Audio support

Signed-off-by: Huacai Chen <chenhc@lemote.com>
---
 arch/loongarch/configs/loongson3_defconfig |   1 +
 include/linux/pci_ids.h                    |   1 +
 sound/hda/hdac_bus.c                       |   6 +-
 sound/hda/hdac_controller.c                |  59 +-
 sound/hda/hdac_device.c                    |   1 +
 sound/hda/hdac_stream.c                    |  62 +-
 sound/pci/hda/Kconfig                      |  11 +
 sound/pci/hda/Makefile                     |   2 +
 sound/pci/hda/hda_controller.c             |  44 +-
 sound/pci/hda/hda_controller.h             |   4 +
 sound/pci/hda/hda_loongson.c               | 849 +++++++++++++++++++++
 sound/pci/hda/patch_hdmi.c                 |   8 +
 sound/pci/hda/patch_realtek.c              |  12 +-
 13 files changed, 1032 insertions(+), 28 deletions(-)
 create mode 100644 sound/pci/hda/hda_loongson.c

diff --git a/arch/loongarch/configs/loongson3_defconfig b/arch/loongarch/configs/loongson3_defconfig
index 75fafc65b2..ee58596695 100644
--- a/arch/loongarch/configs/loongson3_defconfig
+++ b/arch/loongarch/configs/loongson3_defconfig
@@ -662,6 +662,7 @@ CONFIG_SND_SEQ_DUMMY=m
 CONFIG_SND_BT87X=m
 CONFIG_SND_BT87X_OVERCLOCK=y
 CONFIG_SND_HDA_INTEL=y
+CONFIG_SND_HDA_LOONGSON=y
 CONFIG_SND_HDA_HWDEP=y
 CONFIG_SND_HDA_INPUT_BEEP=y
 CONFIG_SND_HDA_PATCH_LOADER=y
diff --git a/include/linux/pci_ids.h b/include/linux/pci_ids.h
index 55e3d3361b..70b7ff2182 100644
--- a/include/linux/pci_ids.h
+++ b/include/linux/pci_ids.h
@@ -171,6 +171,7 @@
 #define PCI_DEVICE_ID_LOONGSON_LPC      0x7a0c
 #define PCI_DEVICE_ID_LOONGSON_DMA      0x7a0f
 #define PCI_DEVICE_ID_LOONGSON_IOMMU	0x7a1f
+#define PCI_DEVICE_ID_LOONGSON_HDMI	0x7a37
 
 #define PCI_VENDOR_ID_TTTECH		0x0357
 #define PCI_DEVICE_ID_TTTECH_MC322	0x000a
diff --git a/sound/hda/hdac_bus.c b/sound/hda/hdac_bus.c
index d497414a55..baf4fe8176 100644
--- a/sound/hda/hdac_bus.c
+++ b/sound/hda/hdac_bus.c
@@ -11,6 +11,7 @@
 #include <sound/hdaudio.h>
 #include "local.h"
 #include "trace.h"
+#include "../pci/hda/hda_controller.h"
 
 static void snd_hdac_bus_process_unsol_events(struct work_struct *work);
 
@@ -109,6 +110,7 @@ int snd_hdac_bus_exec_verb_unlocked(struct hdac_bus *bus, unsigned int addr,
 {
 	unsigned int tmp;
 	int err;
+	struct azx *chip = bus_to_azx(bus);
 
 	if (cmd == ~0)
 		return -EINVAL;
@@ -117,7 +119,9 @@ int snd_hdac_bus_exec_verb_unlocked(struct hdac_bus *bus, unsigned int addr,
 		*res = -1;
 	else if (bus->sync_write)
 		res = &tmp;
-	for (;;) {
+	if (chip->driver_caps & AZX_DCAPS_LS2X_WORKAROUND)
+		err = bus->ops->command(bus, cmd);
+	else for (;;) {
 		trace_hda_send_cmd(bus, cmd);
 		err = bus->ops->command(bus, cmd);
 		if (err != -EAGAIN)
diff --git a/sound/hda/hdac_controller.c b/sound/hda/hdac_controller.c
index 3c7af65582..d531745ab7 100644
--- a/sound/hda/hdac_controller.c
+++ b/sound/hda/hdac_controller.c
@@ -10,6 +10,7 @@
 #include <sound/hdaudio.h>
 #include <sound/hda_register.h>
 #include "local.h"
+#include "../pci/hda/hda_controller.h"
 
 /* clear CORB read pointer properly */
 static void azx_clear_corbrp(struct hdac_bus *bus)
@@ -42,6 +43,8 @@ static void azx_clear_corbrp(struct hdac_bus *bus)
  */
 void snd_hdac_bus_init_cmd_io(struct hdac_bus *bus)
 {
+	struct azx *chip = bus_to_azx(bus);
+
 	WARN_ON_ONCE(!bus->rb.area);
 
 	spin_lock_irq(&bus->reg_lock);
@@ -58,11 +61,15 @@ void snd_hdac_bus_init_cmd_io(struct hdac_bus *bus)
 
 	/* reset the corb hw read pointer */
 	snd_hdac_chip_writew(bus, CORBRP, AZX_CORBRP_RST);
-	if (!bus->corbrp_self_clear)
+	if (chip->driver_caps & AZX_DCAPS_LS2X_WORKAROUND)
+		snd_hdac_chip_writew(bus, CORBRP, 0);
+	else if (!bus->corbrp_self_clear)
 		azx_clear_corbrp(bus);
 
 	/* enable corb dma */
 	snd_hdac_chip_writeb(bus, CORBCTL, AZX_CORBCTL_RUN);
+	if (chip->driver_caps & AZX_DCAPS_LS2X_WORKAROUND)
+		snd_hdac_chip_readb(bus, CORBCTL);
 
 	/* RIRB set up */
 	bus->rirb.addr = bus->rb.addr + 2048;
@@ -79,7 +86,12 @@ void snd_hdac_bus_init_cmd_io(struct hdac_bus *bus)
 	/* set N=1, get RIRB response interrupt for new entry */
 	snd_hdac_chip_writew(bus, RINTCNT, 1);
 	/* enable rirb dma and response irq */
-	snd_hdac_chip_writeb(bus, RIRBCTL, AZX_RBCTL_DMA_EN | AZX_RBCTL_IRQ_EN);
+	if (chip->driver_caps & AZX_DCAPS_LS2X_WORKAROUND) {
+		snd_hdac_chip_writeb(bus, RIRBCTL, AZX_RBCTL_DMA_EN);
+		snd_hdac_chip_readb(bus, RIRBCTL);
+	}
+	else
+		snd_hdac_chip_writeb(bus, RIRBCTL, AZX_RBCTL_DMA_EN | AZX_RBCTL_IRQ_EN);
 	/* Accept unsolicited responses */
 	snd_hdac_chip_updatel(bus, GCTL, AZX_GCTL_UNSOL, AZX_GCTL_UNSOL);
 	spin_unlock_irq(&bus->reg_lock);
@@ -132,6 +144,18 @@ static unsigned int azx_command_addr(u32 cmd)
 	return addr;
 }
 
+static unsigned int azx_response_addr(u32 res)
+{
+	unsigned int addr = res & 0xf;
+
+	if (addr >= AZX_MAX_CODECS) {
+		snd_BUG();
+		addr = 0;
+	}
+
+	return addr;
+}
+
 /**
  * snd_hdac_bus_send_cmd - send a command verb via CORB
  * @bus: HD-audio core bus
@@ -207,13 +231,8 @@ void snd_hdac_bus_update_rirb(struct hdac_bus *bus)
 		rp = bus->rirb.rp << 1; /* an RIRB entry is 8-bytes */
 		res_ex = le32_to_cpu(bus->rirb.buf[rp + 1]);
 		res = le32_to_cpu(bus->rirb.buf[rp]);
-		addr = res_ex & 0xf;
-		if (addr >= HDA_MAX_CODECS) {
-			dev_err(bus->dev,
-				"spurious response %#x:%#x, rp = %d, wp = %d",
-				res, res_ex, bus->rirb.rp, wp);
-			snd_BUG();
-		} else if (res_ex & AZX_RIRB_EX_UNSOL_EV)
+		addr = azx_response_addr(res_ex);
+		if (res_ex & AZX_RIRB_EX_UNSOL_EV)
 			snd_hdac_bus_queue_event(bus, res, res_ex);
 		else if (bus->rirb.cmds[addr]) {
 			bus->rirb.res[addr] = res;
@@ -482,16 +501,24 @@ static void azx_int_disable(struct hdac_bus *bus)
 static void azx_int_clear(struct hdac_bus *bus)
 {
 	struct hdac_stream *azx_dev;
+	struct azx *chip = bus_to_azx(bus);
 
 	/* clear stream status */
-	list_for_each_entry(azx_dev, &bus->stream_list, list)
-		snd_hdac_stream_writeb(azx_dev, SD_STS, SD_INT_MASK);
+	list_for_each_entry(azx_dev, &bus->stream_list, list) {
+		if (chip->driver_caps & AZX_DCAPS_LS2X_WORKAROUND)
+			snd_hdac_stream_updateb(azx_dev, SD_STS, 0, 0);
+		else
+			snd_hdac_stream_writeb(azx_dev, SD_STS, SD_INT_MASK);
+	}
 
 	/* clear STATESTS */
 	snd_hdac_chip_writew(bus, STATESTS, STATESTS_INT_MASK);
 
 	/* clear rirb status */
-	snd_hdac_chip_writeb(bus, RIRBSTS, RIRB_INT_MASK);
+	if (chip->driver_caps & AZX_DCAPS_LS2X_WORKAROUND)
+		snd_hdac_chip_updateb(bus, RIRBSTS, ~RIRB_INT_MASK, 0);
+	else
+		snd_hdac_chip_writeb(bus, RIRBSTS, RIRB_INT_MASK);
 
 	/* clear int status */
 	snd_hdac_chip_writel(bus, INTSTS, AZX_INT_CTRL_EN | AZX_INT_ALL_STREAM);
@@ -572,11 +599,17 @@ int snd_hdac_bus_handle_stream_irq(struct hdac_bus *bus, unsigned int status,
 	struct hdac_stream *azx_dev;
 	u8 sd_status;
 	int handled = 0;
+	struct azx *chip = bus_to_azx(bus);
 
 	list_for_each_entry(azx_dev, &bus->stream_list, list) {
 		if (status & azx_dev->sd_int_sta_mask) {
 			sd_status = snd_hdac_stream_readb(azx_dev, SD_STS);
-			snd_hdac_stream_writeb(azx_dev, SD_STS, SD_INT_MASK);
+			if (chip->driver_caps & AZX_DCAPS_LS2X_WORKAROUND) {
+				snd_hdac_stream_writeb(azx_dev, SD_STS, sd_status);
+				snd_hdac_stream_readb(azx_dev, SD_STS);
+			}
+			else
+				snd_hdac_stream_writeb(azx_dev, SD_STS, SD_INT_MASK);
 			handled |= 1 << azx_dev->index;
 			if ((!azx_dev->substream && !azx_dev->cstream) ||
 			    !azx_dev->running || !(sd_status & SD_INT_COMPLETE))
diff --git a/sound/hda/hdac_device.c b/sound/hda/hdac_device.c
index accc9d279c..89bed32b53 100644
--- a/sound/hda/hdac_device.c
+++ b/sound/hda/hdac_device.c
@@ -645,6 +645,7 @@ struct hda_vendor_id {
 };
 
 static const struct hda_vendor_id hda_vendor_ids[] = {
+	{ 0x0014, "Loongson" },
 	{ 0x1002, "ATI" },
 	{ 0x1013, "Cirrus Logic" },
 	{ 0x1057, "Motorola" },
diff --git a/sound/hda/hdac_stream.c b/sound/hda/hdac_stream.c
index 1f56fd33b9..19c1f7a28b 100644
--- a/sound/hda/hdac_stream.c
+++ b/sound/hda/hdac_stream.c
@@ -13,6 +13,7 @@
 #include <sound/hdaudio.h>
 #include <sound/hda_register.h>
 #include "trace.h"
+#include "../pci/hda/hda_controller.h"
 
 /*
  * the hdac_stream library is intended to be used with the following
@@ -130,6 +131,7 @@ EXPORT_SYMBOL_GPL(snd_hdac_stream_init);
 void snd_hdac_stream_start(struct hdac_stream *azx_dev)
 {
 	struct hdac_bus *bus = azx_dev->bus;
+	struct azx *chip = bus_to_azx(bus);
 	int stripe_ctl;
 
 	trace_snd_hdac_stream_start(bus, azx_dev);
@@ -146,11 +148,19 @@ void snd_hdac_stream_start(struct hdac_stream *azx_dev)
 			stripe_ctl = snd_hdac_get_stream_stripe_ctl(bus, azx_dev->substream);
 		else
 			stripe_ctl = 0;
-		snd_hdac_stream_updateb(azx_dev, SD_CTL_3B, SD_CTL_STRIPE_MASK,
+		if (chip->driver_caps & AZX_DCAPS_LS2X_WORKAROUND)
+			snd_hdac_stream_updatel(azx_dev, SD_CTL_3B, SD_CTL_STRIPE_MASK,
+					stripe_ctl);
+		else
+			snd_hdac_stream_updateb(azx_dev, SD_CTL_3B, SD_CTL_STRIPE_MASK,
 					stripe_ctl);
 	}
 	/* set DMA start and interrupt mask */
-	snd_hdac_stream_updateb(azx_dev, SD_CTL,
+	if (chip->driver_caps & AZX_DCAPS_LS2X_WORKAROUND)
+		snd_hdac_stream_updatel(azx_dev, SD_CTL,
+				0, SD_CTL_DMA_START | SD_INT_MASK);
+	else
+		snd_hdac_stream_updateb(azx_dev, SD_CTL,
 				0, SD_CTL_DMA_START | SD_INT_MASK);
 	azx_dev->running = true;
 }
@@ -162,11 +172,31 @@ EXPORT_SYMBOL_GPL(snd_hdac_stream_start);
  */
 static void snd_hdac_stream_clear(struct hdac_stream *azx_dev)
 {
-	snd_hdac_stream_updateb(azx_dev, SD_CTL,
-				SD_CTL_DMA_START | SD_INT_MASK, 0);
-	snd_hdac_stream_writeb(azx_dev, SD_STS, SD_INT_MASK); /* to be sure */
-	if (azx_dev->stripe)
-		snd_hdac_stream_updateb(azx_dev, SD_CTL_3B, SD_CTL_STRIPE_MASK, 0);
+	int stream;
+	struct azx *chip = bus_to_azx(azx_dev->bus);
+	struct snd_pcm_substream *substream = azx_dev->substream;
+
+	if (chip->driver_caps & AZX_DCAPS_LS2X_WORKAROUND) {
+		snd_hdac_stream_updatel(azx_dev, SD_CTL,
+					SD_CTL_DMA_START | SD_INT_MASK, 0);
+		snd_hdac_stream_writeb(azx_dev, SD_STS, SD_INT_MASK); /* to be sure */
+		if (azx_dev->stripe)
+			snd_hdac_stream_updatel(azx_dev, SD_CTL_3B, SD_CTL_STRIPE_MASK, 0);
+
+		if (!substream)
+			stream_to_azx_dev(azx_dev)->fix_prvpos = 0;
+		else {
+			stream = substream->stream;
+			stream_to_azx_dev(azx_dev)->fix_prvpos =
+				chip->get_position[stream](chip, stream_to_azx_dev(azx_dev));
+		}
+	} else {
+		snd_hdac_stream_updateb(azx_dev, SD_CTL,
+					SD_CTL_DMA_START | SD_INT_MASK, 0);
+		snd_hdac_stream_writeb(azx_dev, SD_STS, SD_INT_MASK); /* to be sure */
+		if (azx_dev->stripe)
+			snd_hdac_stream_updateb(azx_dev, SD_CTL_3B, SD_CTL_STRIPE_MASK, 0);
+	}
 	azx_dev->running = false;
 }
 
@@ -221,6 +251,10 @@ void snd_hdac_stream_reset(struct hdac_stream *azx_dev)
 {
 	unsigned char val;
 	int dma_run_state;
+	struct azx *chip = bus_to_azx(azx_dev->bus);
+
+	if (chip->driver_caps & AZX_DCAPS_LS2X_WORKAROUND)
+		goto out;
 
 	snd_hdac_stream_clear(azx_dev);
 
@@ -239,6 +273,7 @@ void snd_hdac_stream_reset(struct hdac_stream *azx_dev)
 	/* wait for hardware to report that the stream is out of reset */
 	snd_hdac_stream_readb_poll(azx_dev, SD_CTL, val, !(val & SD_CTL_STREAM_RESET), 3, 300);
 
+out:
 	/* reset first position - may not be synced with hw at this time */
 	if (azx_dev->posbuf)
 		*azx_dev->posbuf = 0;
@@ -254,6 +289,7 @@ int snd_hdac_stream_setup(struct hdac_stream *azx_dev)
 	struct hdac_bus *bus = azx_dev->bus;
 	struct snd_pcm_runtime *runtime;
 	unsigned int val;
+	struct azx *chip = bus_to_azx(bus);
 
 	if (azx_dev->substream)
 		runtime = azx_dev->substream->runtime;
@@ -270,7 +306,14 @@ int snd_hdac_stream_setup(struct hdac_stream *azx_dev)
 	snd_hdac_stream_writel(azx_dev, SD_CTL, val);
 
 	/* program the length of samples in cyclic buffer */
-	snd_hdac_stream_writel(azx_dev, SD_CBL, azx_dev->bufsize);
+	if (chip->driver_caps & AZX_DCAPS_LS2X_WORKAROUND) {
+		if(azx_dev->substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+			snd_hdac_stream_writel(azx_dev, SD_CBL, azx_dev->bufsize - 64);
+		else
+			snd_hdac_stream_writel(azx_dev, SD_CBL, azx_dev->bufsize - 16);
+	}
+	else
+		snd_hdac_stream_writel(azx_dev, SD_CBL, azx_dev->bufsize);
 
 	/* program the stream format */
 	/* this value needs to be the same as the one programmed */
@@ -491,6 +534,7 @@ int snd_hdac_stream_setup_periods(struct hdac_stream *azx_dev)
 	__le32 *bdl;
 	int i, ofs, periods, period_bytes;
 	int pos_adj, pos_align;
+	struct azx *chip = bus_to_azx(bus);
 
 	if (substream) {
 		runtime = substream->runtime;
@@ -515,6 +559,8 @@ int snd_hdac_stream_setup_periods(struct hdac_stream *azx_dev)
 	azx_dev->frags = 0;
 
 	pos_adj = bus->bdl_pos_adj;
+	if (chip->driver_caps & AZX_DCAPS_LS2X_WORKAROUND)
+		pos_adj = 0;
 	if (runtime && !azx_dev->no_period_wakeup && pos_adj > 0) {
 		pos_align = pos_adj;
 		pos_adj = DIV_ROUND_UP(pos_adj * runtime->rate, 48000);
diff --git a/sound/pci/hda/Kconfig b/sound/pci/hda/Kconfig
index 886255a03e..b11accc787 100644
--- a/sound/pci/hda/Kconfig
+++ b/sound/pci/hda/Kconfig
@@ -42,6 +42,17 @@ config SND_HDA_TEGRA
 	  To compile this driver as a module, choose M here: the module
 	  will be called snd-hda-tegra.
 
+config SND_HDA_LOONGSON
+	tristate "Loongson HD Audio"
+	depends on MACH_LOONGSON64
+	select SND_HDA
+	help
+	  Say Y here to include support for Loongson's LS7A "High
+	  Definition Audio" controller.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-hda-loongson.
+
 if SND_HDA
 
 config SND_HDA_HWDEP
diff --git a/sound/pci/hda/Makefile b/sound/pci/hda/Makefile
index 00d3061044..43bd77a69d 100644
--- a/sound/pci/hda/Makefile
+++ b/sound/pci/hda/Makefile
@@ -1,6 +1,7 @@
 # SPDX-License-Identifier: GPL-2.0
 snd-hda-intel-objs := hda_intel.o
 snd-hda-tegra-objs := hda_tegra.o
+snd-hda-loongson-objs := hda_loongson.o
 
 snd-hda-codec-y := hda_bind.o hda_codec.o hda_jack.o hda_auto_parser.o hda_sysfs.o
 snd-hda-codec-y += hda_controller.o
@@ -62,3 +63,4 @@ obj-$(CONFIG_SND_HDA_CS_DSP_CONTROLS) += snd-hda-cs-dsp-ctls.o
 # when built in kernel
 obj-$(CONFIG_SND_HDA_INTEL) += snd-hda-intel.o
 obj-$(CONFIG_SND_HDA_TEGRA) += snd-hda-tegra.o
+obj-$(CONFIG_SND_HDA_LOONGSON) += snd-hda-loongson.o
diff --git a/sound/pci/hda/hda_controller.c b/sound/pci/hda/hda_controller.c
index 406779625f..f2331941b4 100644
--- a/sound/pci/hda/hda_controller.c
+++ b/sound/pci/hda/hda_controller.c
@@ -295,6 +295,23 @@ unsigned int azx_get_position(struct azx *chip,
 	int stream = substream->stream;
 	int delay = 0;
 
+	if (chip->driver_caps & AZX_DCAPS_LS2X_WORKAROUND) {
+		pos = chip->get_position[stream](chip, azx_dev);
+
+		if (pos >= azx_dev->fix_prvpos) {
+			pos = pos - azx_dev->fix_prvpos;
+			pos %= azx_dev->core.bufsize;
+		} else {
+			if (azx_dev->fix_prvpos > azx_dev->core.bufsize)
+				pos = (0x100000000ULL + pos-azx_dev->fix_prvpos)
+					% azx_dev->core.bufsize;
+			else
+				pos = pos + azx_dev->core.bufsize - azx_dev->fix_prvpos;
+		}
+
+		return pos;
+	}
+
 	if (chip->get_position[stream])
 		pos = chip->get_position[stream](chip, azx_dev);
 	else /* use the position buffer as default */
@@ -908,6 +925,8 @@ static int azx_send_cmd(struct hdac_bus *bus, unsigned int val)
 
 	if (chip->disabled)
 		return 0;
+	if (chip->driver_caps & AZX_DCAPS_LS2X_WORKAROUND)
+		udelay(500);
 	if (chip->single_cmd)
 		return azx_single_send_cmd(bus, val);
 	else
@@ -1064,8 +1083,9 @@ static void stream_update(struct hdac_bus *bus, struct hdac_stream *s)
 irqreturn_t azx_interrupt(int irq, void *dev_id)
 {
 	struct azx *chip = dev_id;
+	struct hdac_stream *azx_dev;
 	struct hdac_bus *bus = azx_bus(chip);
-	u32 status;
+	u32 i = 0, status = 0;
 	bool active, handled = false;
 	int repeat = 0; /* count for avoiding endless loop */
 
@@ -1081,8 +1101,21 @@ irqreturn_t azx_interrupt(int irq, void *dev_id)
 		goto unlock;
 
 	do {
-		status = azx_readl(chip, INTSTS);
-		if (status == 0 || status == 0xffffffff)
+		if (chip->driver_caps & AZX_DCAPS_LS2X_WORKAROUND) {
+			i = 0;
+			status = 0;
+			list_for_each_entry(azx_dev, &bus->stream_list, list) {
+				status |= (snd_hdac_stream_readb(azx_dev, SD_STS) & SD_INT_MASK) ?
+				    (1 << i) : 0;
+				i++;
+			}
+			status |= (status & ~0) ? (1 << 31) : 0;
+		}
+		else
+			status = azx_readl(chip, INTSTS);
+
+		if (status == 0 ||
+			(status == 0xffffffff && !(chip->driver_caps & AZX_DCAPS_LS2X_WORKAROUND)))
 			break;
 
 		handled = true;
@@ -1100,7 +1133,10 @@ irqreturn_t azx_interrupt(int irq, void *dev_id)
 			 * remain unserviced by IRQ, eventually falling back
 			 * to polling mode in azx_rirb_get_response.
 			 */
-			azx_writeb(chip, RIRBSTS, RIRB_INT_MASK);
+			if (chip->driver_caps & AZX_DCAPS_LS2X_WORKAROUND)
+				azx_writeb(chip, RIRBSTS, status & RIRB_INT_MASK);
+			else
+				azx_writeb(chip, RIRBSTS, RIRB_INT_MASK);
 			active = true;
 			if (status & RIRB_INT_RESPONSE) {
 				if (chip->driver_caps & AZX_DCAPS_CTX_WORKAROUND)
diff --git a/sound/pci/hda/hda_controller.h b/sound/pci/hda/hda_controller.h
index 8556031bcd..57bfca85e9 100644
--- a/sound/pci/hda/hda_controller.h
+++ b/sound/pci/hda/hda_controller.h
@@ -45,6 +45,7 @@
 #define AZX_DCAPS_CORBRP_SELF_CLEAR (1 << 28)	/* CORBRP clears itself after reset */
 #define AZX_DCAPS_NO_MSI64      (1 << 29)	/* Stick to 32-bit MSIs */
 #define AZX_DCAPS_SEPARATE_STREAM_TAG	(1 << 30) /* capture and playback use separate stream tag */
+#define AZX_DCAPS_LS2X_WORKAROUND (1 << 31)	/* Loongson-2H workaround */
 
 enum {
 	AZX_SNOOP_TYPE_NONE,
@@ -63,6 +64,9 @@ struct azx_dev {
 	 *  when link position is not greater than FIFO size
 	 */
 	unsigned int insufficient:1;
+
+	/* For Loongson */
+	unsigned int fix_prvpos;
 };
 
 #define azx_stream(dev)		(&(dev)->core)
diff --git a/sound/pci/hda/hda_loongson.c b/sound/pci/hda/hda_loongson.c
new file mode 100644
index 0000000000..c1f62c6470
--- /dev/null
+++ b/sound/pci/hda/hda_loongson.c
@@ -0,0 +1,849 @@
+/*
+ *
+ *  hda_loongson.c - Implementation of primary alsa driver code base
+ *                for Intel HD Audio.
+ *
+ *  Copyright (c) 2004 Intel Corporation. All rights reserved.
+ *
+ *  Copyright (c) 2004 Takashi Iwai <tiwai@suse.de>
+ *                     PeiSen Hou <pshou@realtek.com.tw>
+ *
+ *  Copyright (c) 2014 Huacai Chen <chenhc@lemote.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License as published by the Free
+ *  Software Foundation; either version 2 of the License, or (at your option)
+ *  any later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along with
+ *  this program; if not, write to the Free Software Foundation, Inc., 59
+ *  Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ *
+ *  CONTACTS:
+ *
+ *  Matt Jared		matt.jared@intel.com
+ *  Andy Kopp		andy.kopp@intel.com
+ *  Dan Kogan		dan.d.kogan@intel.com
+ *
+ *  CHANGES:
+ *
+ *  2004.12.01	Major rewrite by tiwai, merged the work of pshou
+ *
+ */
+
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/dma-mapping.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/platform_device.h>
+#include <linux/mutex.h>
+#include <linux/reboot.h>
+#include <linux/io.h>
+#include <linux/pm_runtime.h>
+#include <linux/clocksource.h>
+#include <linux/time.h>
+#include <linux/completion.h>
+#include <linux/firmware.h>
+
+#include <sound/core.h>
+#include <sound/initval.h>
+#include <sound/hda_codec.h>
+#include <asm/loongson.h>
+#include "hda_controller.h"
+
+#define LS7A_NUM_CAPTURE	4
+#define LS7A_NUM_PLAYBACK	4
+
+static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;
+static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;
+static bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;
+static char *model[SNDRV_CARDS];
+static int bdl_pos_adj[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS-1)] = -1};
+static int probe_only[SNDRV_CARDS];
+static int jackpoll_ms[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS-1)] = 1200};
+static bool single_cmd;
+static int enable_msi = -1;
+#ifdef CONFIG_SND_HDA_INPUT_BEEP
+static bool beep_mode[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS-1)] =
+					CONFIG_SND_HDA_INPUT_BEEP_MODE};
+#endif
+
+module_param_array(index, int, NULL, 0444);
+MODULE_PARM_DESC(index, "Index value for Intel HD audio interface.");
+module_param_array(id, charp, NULL, 0444);
+MODULE_PARM_DESC(id, "ID string for Intel HD audio interface.");
+module_param_array(enable, bool, NULL, 0444);
+MODULE_PARM_DESC(enable, "Enable Intel HD audio interface.");
+module_param_array(model, charp, NULL, 0444);
+MODULE_PARM_DESC(model, "Use the given board model.");
+module_param_array(bdl_pos_adj, int, NULL, 0644);
+MODULE_PARM_DESC(bdl_pos_adj, "BDL position adjustment offset.");
+module_param_array(probe_only, int, NULL, 0444);
+MODULE_PARM_DESC(probe_only, "Only probing and no codec initialization.");
+module_param_array(jackpoll_ms, int, NULL, 0444);
+MODULE_PARM_DESC(jackpoll_ms, "Ms between polling for jack events (default = 0, using unsol events only)");
+module_param(single_cmd, bool, 0444);
+MODULE_PARM_DESC(single_cmd, "Use single command to communicate with codecs "
+		 "(for debugging only).");
+module_param(enable_msi, bint, 0444);
+MODULE_PARM_DESC(enable_msi, "Enable Message Signaled Interrupt (MSI)");
+#ifdef CONFIG_SND_HDA_INPUT_BEEP
+module_param_array(beep_mode, bool, NULL, 0444);
+MODULE_PARM_DESC(beep_mode, "Select HDA Beep registration mode "
+			    "(0=off, 1=on) (default=1).");
+#endif
+
+#ifdef CONFIG_PM
+static int param_set_xint(const char *val, const struct kernel_param *kp);
+static struct kernel_param_ops param_ops_xint = {
+	.set = param_set_xint,
+	.get = param_get_int,
+};
+#define param_check_xint param_check_int
+
+static int power_save = CONFIG_SND_HDA_POWER_SAVE_DEFAULT;
+module_param(power_save, xint, 0644);
+MODULE_PARM_DESC(power_save, "Automatic power-saving timeout "
+		 "(in second, 0 = disable).");
+
+/* reset the HD-audio controller in power save mode.
+ * this may give more power-saving, but will take longer time to
+ * wake up.
+ */
+static bool power_save_controller = 1;
+module_param(power_save_controller, bool, 0644);
+MODULE_PARM_DESC(power_save_controller, "Reset controller in power save mode.");
+#else
+#define power_save	0
+#endif /* CONFIG_PM */
+
+static int align_buffer_size = -1;
+module_param(align_buffer_size, bint, 0644);
+MODULE_PARM_DESC(align_buffer_size,
+		"Force buffer and period sizes to be multiple of 128 bytes.");
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Loongson LS7A HDA driver");
+
+/* driver types */
+enum {
+	AZX_DRIVER_LS7A,
+	AZX_DRIVER_HDMI,
+	AZX_NUM_DRIVERS, /* keep this as last entry */
+};
+
+static char *driver_short_names[] = {
+	[AZX_DRIVER_LS7A] = "HD-Audio Loongson",
+	[AZX_DRIVER_HDMI] = "HD-Audio Loongson HDMI",
+};
+
+struct hda_loongson {
+	struct azx chip;
+
+	/* for pending irqs */
+	struct work_struct irq_pending_work;
+
+	/* sync probing */
+	struct completion probe_wait;
+	struct work_struct probe_work;
+
+	/* card list (for power_save trigger) */
+	struct list_head list;
+
+	/* extra flags */
+	unsigned int irq_pending_warned:1;
+	unsigned int probe_continued:1;
+};
+
+static int azx_acquire_irq(struct azx *chip, int do_disconnect);
+
+static int azx_position_ok(struct azx *chip, struct azx_dev *azx_dev);
+
+/* called from IRQ */
+static int azx_position_check(struct azx *chip, struct azx_dev *azx_dev)
+{
+	struct hda_loongson *hda = container_of(chip, struct hda_loongson, chip);
+	int ok;
+
+	ok = azx_position_ok(chip, azx_dev);
+	if (ok == 1) {
+		azx_dev->irq_pending = 0;
+		return ok;
+	} else if (ok == 0) {
+		/* bogus IRQ, process it later */
+		azx_dev->irq_pending = 1;
+		schedule_work(&hda->irq_pending_work);
+	}
+	return 0;
+}
+
+/*
+ * Check whether the current DMA position is acceptable for updating
+ * periods.  Returns non-zero if it's OK.
+ *
+ * Many HD-audio controllers appear pretty inaccurate about
+ * the update-IRQ timing.  The IRQ is issued before actually the
+ * data is processed.  So, we need to process it afterwords in a
+ * workqueue.
+ */
+static int azx_position_ok(struct azx *chip, struct azx_dev *azx_dev)
+{
+	return 1; /* OK, it's fine */
+}
+
+/*
+ * The work for pending PCM period updates.
+ */
+static void azx_irq_pending_work(struct work_struct *work)
+{
+	struct hda_loongson *hda = container_of(work, struct hda_loongson, irq_pending_work);
+	struct azx *chip = &hda->chip;
+	struct hdac_bus *bus = azx_bus(chip);
+	struct hdac_stream *s;
+	int pending, ok;
+
+	if (!hda->irq_pending_warned) {
+		dev_info(chip->card->dev,
+			 "IRQ timing workaround is activated for card #%d. Suggest a bigger bdl_pos_adj.\n",
+			 chip->card->number);
+		hda->irq_pending_warned = 1;
+	}
+
+	for (;;) {
+		pending = 0;
+		spin_lock_irq(&bus->reg_lock);
+		list_for_each_entry(s, &bus->stream_list, list) {
+			struct azx_dev *azx_dev = stream_to_azx_dev(s);
+			if (!azx_dev->irq_pending ||
+			    !s->substream ||
+			    !s->running)
+				continue;
+			ok = azx_position_ok(chip, azx_dev);
+			if (ok > 0) {
+				azx_dev->irq_pending = 0;
+				spin_unlock(&bus->reg_lock);
+				snd_pcm_period_elapsed(s->substream);
+				spin_lock(&bus->reg_lock);
+			} else if (ok < 0) {
+				pending = 0;	/* too early */
+			} else
+				pending++;
+		}
+		spin_unlock_irq(&bus->reg_lock);
+		if (!pending)
+			return;
+		msleep(1);
+	}
+}
+
+/* clear irq_pending flags and assure no on-going workq */
+static void azx_clear_irq_pending(struct azx *chip)
+{
+	struct hdac_bus *bus = azx_bus(chip);
+	struct hdac_stream *s;
+
+	spin_lock_irq(&bus->reg_lock);
+	list_for_each_entry(s, &bus->stream_list, list) {
+		struct azx_dev *azx_dev = stream_to_azx_dev(s);
+		azx_dev->irq_pending = 0;
+	}
+	spin_unlock_irq(&bus->reg_lock);
+}
+
+static int azx_acquire_irq(struct azx *chip, int do_disconnect)
+{
+	struct hdac_bus *bus = azx_bus(chip);
+	int irq;
+
+	if (chip->pci)
+		irq = chip->pci->irq;
+	else
+		irq = platform_get_irq(to_platform_device(chip->card->dev), 0);
+
+	if (request_irq(irq, azx_interrupt, chip->msi ? 0 : IRQF_SHARED,
+			KBUILD_MODNAME, chip)) {
+		dev_err(chip->card->dev,
+			"unable to grab IRQ %d, disabling device\n", irq);
+		if (do_disconnect)
+			snd_card_disconnect(chip->card);
+		return -1;
+	}
+	bus->irq = irq;
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static DEFINE_MUTEX(card_list_lock);
+static LIST_HEAD(card_list);
+
+static void azx_add_card_list(struct azx *chip)
+{
+	struct hda_loongson *hda = container_of(chip, struct hda_loongson, chip);
+	mutex_lock(&card_list_lock);
+	list_add(&hda->list, &card_list);
+	mutex_unlock(&card_list_lock);
+}
+
+static void azx_del_card_list(struct azx *chip)
+{
+	struct hda_loongson *hda = container_of(chip, struct hda_loongson, chip);
+	mutex_lock(&card_list_lock);
+	list_del_init(&hda->list);
+	mutex_unlock(&card_list_lock);
+}
+
+/* trigger power-save check at writing parameter */
+static int param_set_xint(const char *val, const struct kernel_param *kp)
+{
+	struct hda_loongson *hda;
+	struct azx *chip;
+	int prev = power_save;
+	int ret = param_set_int(val, kp);
+
+	if (ret || prev == power_save)
+		return ret;
+
+	mutex_lock(&card_list_lock);
+	list_for_each_entry(hda, &card_list, list) {
+		chip = &hda->chip;
+		if (!hda->probe_continued || chip->disabled)
+			continue;
+		snd_hda_set_power_save(&chip->bus, power_save * 1000);
+	}
+	mutex_unlock(&card_list_lock);
+	return 0;
+}
+#else
+#define azx_add_card_list(chip) /* NOP */
+#define azx_del_card_list(chip) /* NOP */
+#endif /* CONFIG_PM */
+
+#if defined(CONFIG_PM_SLEEP)
+/*
+ * power management
+ */
+static int azx_suspend(struct device *dev)
+{
+	struct snd_card *card = dev_get_drvdata(dev);
+	struct azx *chip = card->private_data;
+	struct hdac_bus *bus;
+
+	if (chip->disabled)
+		return 0;
+
+	bus = azx_bus(chip);
+	snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
+	azx_clear_irq_pending(chip);
+	azx_stop_chip(chip);
+	azx_enter_link_reset(chip);
+	if (bus->irq >= 0) {
+		free_irq(bus->irq, chip);
+		bus->irq = -1;
+	}
+	return 0;
+}
+
+static int azx_resume(struct device *dev)
+{
+	struct snd_card *card = dev_get_drvdata(dev);
+	struct azx *chip = card->private_data;
+
+	if (chip->disabled)
+		return 0;
+
+	chip->msi = 0;
+	if (azx_acquire_irq(chip, 1) < 0)
+		return -EIO;
+
+	azx_init_chip(chip, true);
+
+	snd_power_change_state(card, SNDRV_CTL_POWER_D0);
+	return 0;
+}
+#endif /* CONFIG_PM_SLEEP */
+
+#ifdef CONFIG_PM
+static int azx_runtime_suspend(struct device *dev)
+{
+	struct snd_card *card = dev_get_drvdata(dev);
+	struct azx *chip = card->private_data;
+
+	if (chip->disabled)
+		return 0;
+
+	if (!azx_has_pm_runtime(chip))
+		return 0;
+
+	/* enable controller wake up event */
+	azx_writew(chip, WAKEEN, azx_readw(chip, WAKEEN) |
+		  STATESTS_INT_MASK);
+
+	azx_stop_chip(chip);
+	azx_enter_link_reset(chip);
+	azx_clear_irq_pending(chip);
+	return 0;
+}
+
+static int azx_runtime_resume(struct device *dev)
+{
+	struct snd_card *card = dev_get_drvdata(dev);
+	struct azx *chip = card->private_data;
+	struct hda_codec *codec;
+	int status;
+
+	if (chip->disabled)
+		return 0;
+
+	if (!azx_has_pm_runtime(chip))
+		return 0;
+
+	/* Read STATESTS before controller reset */
+	status = azx_readw(chip, STATESTS);
+
+	azx_init_chip(chip, true);
+
+	if (status) {
+		list_for_each_codec(codec, &chip->bus)
+			if (status & (1 << codec->addr))
+				schedule_delayed_work(&codec->jackpoll_work,
+						      codec->jackpoll_interval);
+	}
+
+	/* disable controller Wake Up event*/
+	azx_writew(chip, WAKEEN, azx_readw(chip, WAKEEN) &
+			~STATESTS_INT_MASK);
+
+	return 0;
+}
+
+static int azx_runtime_idle(struct device *dev)
+{
+	struct snd_card *card = dev_get_drvdata(dev);
+	struct azx *chip = card->private_data;
+
+	if (chip->disabled)
+		return 0;
+
+	if (!power_save_controller || !azx_has_pm_runtime(chip) ||
+	    azx_bus(chip)->codec_powered)
+		return -EBUSY;
+
+	return 0;
+}
+
+#endif /* CONFIG_PM */
+
+#ifdef CONFIG_PM
+static const struct dev_pm_ops azx_pm = {
+	SET_SYSTEM_SLEEP_PM_OPS(azx_suspend, azx_resume)
+	SET_RUNTIME_PM_OPS(azx_runtime_suspend, azx_runtime_resume, azx_runtime_idle)
+};
+
+#define AZX_PM_OPS	&azx_pm
+#else
+#define AZX_PM_OPS	NULL
+#endif /* CONFIG_PM */
+
+static int azx_probe_continue(struct azx *chip);
+
+/*
+ * destructor
+ */
+static int azx_free(struct azx *chip)
+{
+	struct device *snddev = chip->card->dev;
+	struct hda_loongson *hda = container_of(chip, struct hda_loongson, chip);
+	struct hdac_bus *bus = azx_bus(chip);
+
+	if (azx_has_pm_runtime(chip) && chip->running)
+		pm_runtime_get_noresume(snddev);
+
+	azx_del_card_list(chip);
+
+	complete_all(&hda->probe_wait);
+
+	if (bus->chip_init) {
+		azx_clear_irq_pending(chip);
+		azx_stop_all_streams(chip);
+		azx_stop_chip(chip);
+	}
+
+	if (bus->irq >= 0)
+		free_irq(bus->irq, (void*)chip);
+	if (bus->remap_addr)
+		iounmap(bus->remap_addr);
+
+	azx_free_stream_pages(chip);
+	azx_free_streams(chip);
+	snd_hdac_bus_exit(bus);
+	kfree(hda);
+
+	return 0;
+}
+
+static int azx_dev_disconnect(struct snd_device *device)
+{
+	struct azx *chip = device->device_data;
+
+	chip->bus.shutdown = 1;
+	return 0;
+}
+
+static int azx_dev_free(struct snd_device *device)
+{
+	return azx_free(device->device_data);
+}
+
+/*
+ * constructor
+ */
+static const struct hda_controller_ops loongson_hda_ops;
+
+static int azx_create(struct snd_card *card, struct pci_dev *pcidev,
+		      struct platform_device *platdev, int dev,
+		      unsigned int driver_caps, struct azx **rchip)
+{
+	static struct snd_device_ops ops = {
+		.dev_disconnect = azx_dev_disconnect,
+		.dev_free = azx_dev_free,
+	};
+	struct hda_loongson *hda;
+	struct azx *chip;
+	int err;
+
+	*rchip = NULL;
+
+	hda = kzalloc(sizeof(*hda), GFP_KERNEL);
+	if (!hda) {
+		dev_err(card->dev, "Cannot allocate hda\n");
+		return -ENOMEM;
+	}
+
+	chip = &hda->chip;
+	mutex_init(&chip->open_mutex);
+	chip->card = card;
+	chip->pci = pcidev;
+	chip->ops = &loongson_hda_ops;
+	chip->driver_caps = driver_caps;
+	chip->driver_type = driver_caps & 0xff;
+	chip->dev_index = dev;
+	if (jackpoll_ms[dev] >= 50 && jackpoll_ms[dev] <= 60000)
+		chip->jackpoll_interval = msecs_to_jiffies(jackpoll_ms[dev]);
+	INIT_LIST_HEAD(&chip->pcm_list);
+	INIT_WORK(&hda->irq_pending_work, azx_irq_pending_work);
+	INIT_LIST_HEAD(&hda->list);
+	init_completion(&hda->probe_wait);
+
+	chip->get_position[0] = chip->get_position[1] = azx_get_pos_lpib;
+
+	chip->snoop = false;
+	chip->single_cmd = single_cmd;
+	azx_bus(chip)->codec_mask = chip->codec_probe_mask = 0xf;
+
+	if (bdl_pos_adj[dev] < 0) {
+		switch (chip->driver_type) {
+		case AZX_DRIVER_LS7A:
+			bdl_pos_adj[dev] = 1;
+			break;
+		default:
+			bdl_pos_adj[dev] = 32;
+			break;
+		}
+	}
+	chip->bdl_pos_adj = bdl_pos_adj[dev];
+
+	err = azx_bus_init(chip, model[dev]);
+	if (err < 0) {
+		kfree(hda);
+		return err;
+	}
+
+	err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops);
+	if (err < 0) {
+		dev_err(card->dev, "Error creating device [card]!\n");
+		azx_free(chip);
+		return err;
+	}
+
+	*rchip = chip;
+
+	return 0;
+}
+
+static int azx_first_init(struct azx *chip)
+{
+	int dev = chip->dev_index;
+	struct snd_card *card = chip->card;
+	struct hdac_bus *bus = azx_bus(chip);
+	int err;
+	unsigned short gcap;
+
+	bus->addr = pci_resource_start(chip->pci, 0);
+	bus->remap_addr = ioremap(bus->addr,
+			   pci_resource_end(chip->pci, 0) - pci_resource_start(chip->pci, 0) + 1);
+	if (bus->remap_addr == NULL) {
+		dev_err(card->dev, "ioremap error\n");
+		return -ENXIO;
+	}
+
+	chip->msi = 0;
+
+	if (azx_acquire_irq(chip, 0) < 0)
+		return -EBUSY;
+
+	synchronize_irq(bus->irq);
+
+	gcap = azx_readw(chip, GCAP);
+	dev_dbg(card->dev, "chipset global capabilities = 0x%x\n", gcap);
+
+	/* disable 64bit DMA address on some devices */
+	if (chip->driver_caps & AZX_DCAPS_NO_64BIT) {
+		dev_dbg(card->dev, "Disabling 64bit DMA\n");
+		gcap &= ~AZX_GCAP_64OK;
+	}
+
+	/* disable buffer size rounding to 128-byte multiples if supported */
+	if (align_buffer_size >= 0)
+		chip->align_buffer_size = !!align_buffer_size;
+	else {
+		if (chip->driver_caps & AZX_DCAPS_NO_ALIGN_BUFSIZE)
+			chip->align_buffer_size = 0;
+		else
+			chip->align_buffer_size = 1;
+	}
+
+	/* allow 64bit DMA address if supported by H/W */
+	if ((gcap & AZX_GCAP_64OK) && !dma_set_mask(chip->card->dev, DMA_BIT_MASK(64)))
+		dma_set_coherent_mask(chip->card->dev, DMA_BIT_MASK(64));
+	else {
+		dma_set_mask(chip->card->dev, DMA_BIT_MASK(32));
+		dma_set_coherent_mask(chip->card->dev, DMA_BIT_MASK(32));
+	}
+
+	/* read number of streams from GCAP register instead of using
+	 * hardcoded value
+	 */
+	chip->capture_streams = (gcap >> 8) & 0x0f;
+	chip->playback_streams = (gcap >> 12) & 0x0f;
+	if (!chip->playback_streams && !chip->capture_streams) {
+		/* gcap didn't give any info, switching to old method */
+		chip->capture_streams = LS7A_NUM_CAPTURE;
+		chip->playback_streams = LS7A_NUM_PLAYBACK;
+	}
+	chip->capture_index_offset = 0;
+	chip->playback_index_offset = chip->capture_streams;
+	chip->num_streams = chip->playback_streams + chip->capture_streams;
+
+	/* initialize streams */
+	err = azx_init_streams(chip);
+	if (err < 0)
+		return err;
+	chip->playback_streams = chip->capture_streams = 1; /* Loongson */
+
+	err = azx_alloc_stream_pages(chip);
+	if (err < 0)
+		return err;
+
+	/* initialize chip */
+	azx_init_chip(chip, (probe_only[dev] & 2) == 0);
+
+	/* codec detection */
+	if (!azx_bus(chip)->codec_mask) {
+		dev_err(card->dev, "no codecs found!\n");
+		return -ENODEV;
+	}
+
+	strcpy(card->driver, "HDA-Loongson");
+	strlcpy(card->shortname, driver_short_names[chip->driver_type],
+		sizeof(card->shortname));
+	snprintf(card->longname, sizeof(card->longname),
+		 "%s at 0x%lx irq %i",
+		 card->shortname, bus->addr, bus->irq);
+
+	return 0;
+}
+
+static const struct hda_controller_ops loongson_hda_ops = {
+	.position_check = azx_position_check,
+};
+
+/* number of codec slots for each chipset: 0 = default slots (i.e. 4) */
+static unsigned int azx_max_codecs[AZX_NUM_DRIVERS] = {};
+
+static int azx_probe_continue(struct azx *chip)
+{
+	struct hda_loongson *hda = container_of(chip, struct hda_loongson, chip);
+	int dev = chip->dev_index;
+	int err;
+	struct device *snddev = chip->card->dev;
+
+	hda->probe_continued = 1;
+
+	err = azx_first_init(chip);
+	if (err < 0)
+		goto out_free;
+
+#ifdef CONFIG_SND_HDA_INPUT_BEEP
+	chip->beep_mode = beep_mode[dev];
+#endif
+
+	/* create codec instances */
+	err = azx_probe_codecs(chip, azx_max_codecs[chip->driver_type]);
+	if (err < 0)
+		goto out_free;
+
+	if ((probe_only[dev] & 1) == 0) {
+		err = azx_codec_configure(chip);
+		if (err < 0)
+			goto out_free;
+	}
+
+	err = snd_card_register(chip->card);
+	if (err < 0)
+		goto out_free;
+
+	chip->running = 1;
+	azx_add_card_list(chip);
+#ifdef CONFIG_PM
+	pm_runtime_forbid(snddev);
+	pm_runtime_set_active(snddev);
+#endif
+	snd_hda_set_power_save(&chip->bus, power_save * 1000);
+	if (azx_has_pm_runtime(chip))
+		pm_runtime_put_noidle(snddev);
+
+out_free:
+	complete_all(&hda->probe_wait);
+	return err;
+}
+
+static const struct pci_device_id azx_ids[] = {
+	{PCI_DEVICE(PCI_VENDOR_ID_LOONGSON, PCI_DEVICE_ID_LOONGSON_HDA),
+	.driver_data = AZX_DRIVER_LS7A | AZX_DCAPS_LS2X_WORKAROUND},
+	{PCI_DEVICE(PCI_VENDOR_ID_LOONGSON, PCI_DEVICE_ID_LOONGSON_HDMI),
+	.driver_data = AZX_DRIVER_HDMI | AZX_DCAPS_LS2X_WORKAROUND},
+	{}
+};
+
+MODULE_DEVICE_TABLE(pci, azx_ids);
+
+static int azx_pci_probe(struct pci_dev *pdev, const struct pci_device_id *pid)
+{
+	int ret;
+	bool probe_now;
+	static int dev;
+	struct snd_card *card;
+	struct azx *chip;
+	struct hda_loongson *hda;
+
+	/* Enable device in PCI config */
+	ret = pci_enable_device(pdev);
+	if (ret < 0) {
+		printk(KERN_ERR "Loongson HDA (%s): Cannot enable PCI device\n",
+		       pci_name(pdev));
+		goto out;
+	}
+
+	/* request the mem regions */
+	ret = pci_request_region(pdev, 0, "Loongson HDA");
+	if (ret < 0) {
+		printk( KERN_ERR "Loongson HDA (%s): cannot request region 0.\n",
+			pci_name(pdev));
+		goto out;
+	}
+
+	if (dev >= SNDRV_CARDS)
+		return -ENODEV;
+	if (!enable[dev]) {
+		dev++;
+		return -ENOENT;
+	}
+
+	ret = snd_card_new(&pdev->dev, index[dev], id[dev], THIS_MODULE,
+			   0, &card);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "Error creating card!\n");
+		return ret;
+	}
+
+	ret = azx_create(card, pdev, NULL, dev, pid->driver_data, &chip);
+	if (ret < 0)
+		goto out_free;
+	card->private_data = chip;
+	hda = container_of(chip, struct hda_loongson, chip);
+
+	dev_set_drvdata(&pdev->dev, card);
+
+	probe_now = !chip->disabled;
+
+	if (probe_now) {
+		ret = azx_probe_continue(chip);
+		if (ret < 0)
+			goto out_free;
+	}
+
+	dev++;
+	if (chip->disabled)
+		complete_all(&hda->probe_wait);
+	return 0;
+
+out_free:
+	snd_card_free(card);
+out:
+	return ret;
+}
+
+static void azx_pci_remove(struct pci_dev *pdev)
+{
+	snd_card_free(dev_get_drvdata(&pdev->dev));
+}
+
+static void azx_pci_shutdown(struct pci_dev *pdev)
+{
+	struct snd_card *card = dev_get_drvdata(&pdev->dev);
+	struct azx *chip;
+
+	if (!card)
+		return;
+	chip = card->private_data;
+	if (chip && chip->running)
+		azx_stop_chip(chip);
+}
+
+/* pci_driver definition */
+static struct pci_driver azx_pci_driver = {
+	.name = "loongson-audio",
+	.id_table = azx_ids,
+	.probe = azx_pci_probe,
+	.remove = azx_pci_remove,
+	.shutdown = azx_pci_shutdown,
+	.driver.pm = AZX_PM_OPS,
+};
+
+static int __init alsa_card_azx_init(void)
+{
+	int ret;
+
+	ret = pci_register_driver(&azx_pci_driver);
+	if (ret)
+		pr_err("hda azx pci driver register\n");
+
+	return ret;
+}
+
+static void __exit alsa_card_azx_exit(void)
+{
+	pci_unregister_driver(&azx_pci_driver);
+}
+
+module_init(alsa_card_azx_init)
+module_exit(alsa_card_azx_exit)
diff --git a/sound/pci/hda/patch_hdmi.c b/sound/pci/hda/patch_hdmi.c
index 5c6980394d..8a0bc6541f 100644
--- a/sound/pci/hda/patch_hdmi.c
+++ b/sound/pci/hda/patch_hdmi.c
@@ -3207,6 +3207,13 @@ static int patch_i915_cpt_hdmi(struct hda_codec *codec)
 	return parse_intel_hdmi(codec);
 }
 
+/* Loongson LS7A2000 */
+static int patch_ls7a_hdmi(struct hda_codec *codec)
+{
+	codec->bus->core.needs_damn_long_delay = 1;
+	return patch_generic_hdmi(codec);
+}
+
 /*
  * Shared non-generic implementations
  */
@@ -4493,6 +4500,7 @@ static int patch_via_hdmi(struct hda_codec *codec)
  * patch entries
  */
 static const struct hda_device_id snd_hda_id_hdmi[] = {
+HDA_CODEC_ENTRY(0x00147a47, "Loongson HDMI",	patch_ls7a_hdmi),
 HDA_CODEC_ENTRY(0x1002793c, "RS600 HDMI",	patch_atihdmi),
 HDA_CODEC_ENTRY(0x10027919, "RS600 HDMI",	patch_atihdmi),
 HDA_CODEC_ENTRY(0x1002791a, "RS690/780 HDMI",	patch_atihdmi),
diff --git a/sound/pci/hda/patch_realtek.c b/sound/pci/hda/patch_realtek.c
index f70d6a3342..3c62ca41ba 100644
--- a/sound/pci/hda/patch_realtek.c
+++ b/sound/pci/hda/patch_realtek.c
@@ -27,6 +27,7 @@
 #include "hda_jack.h"
 #include "hda_generic.h"
 #include "hda_component.h"
+#include "hda_controller.h"
 
 /* keep halting ALC5505 DSP, for power saving */
 #define HALT_REALTEK_ALC5505
@@ -348,6 +349,13 @@ static void alc_fixup_micmute_led(struct hda_codec *codec,
 		snd_hda_gen_add_micmute_led_cdev(codec, NULL);
 }
 
+int has_loongson_workaround(struct hda_codec *codec)
+{
+	struct azx *chip = bus_to_azx(&codec->bus->core);
+
+	return chip->driver_caps & AZX_DCAPS_LS2X_WORKAROUND;
+}
+
 /*
  * Fix hardware PLL issue
  * On some codecs, the analog PLL gating control must be off while
@@ -689,10 +697,10 @@ static int alc_auto_parse_customize_define(struct hda_codec *codec)
 		goto do_sku;
 	}
 
-	if (!codec->bus->pci)
+	if (!codec->bus->pci && !has_loongson_workaround(codec))
 		return -1;
 	ass = codec->core.subsystem_id & 0xffff;
-	if (ass != codec->bus->pci->subsystem_device && (ass & 1))
+	if (codec->bus->pci && ass != codec->bus->pci->subsystem_device && (ass & 1))
 		goto do_sku;
 
 	nid = 0x1d;
-- 
2.39.1

