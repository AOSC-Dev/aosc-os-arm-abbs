From dd8c41afa60ab24175c0165fab544a881e401daa Mon Sep 17 00:00:00 2001
From: "Dr. Chang Liu, PhD" <cl91tp@gmail.com>
Date: Tue, 3 Oct 2023 17:12:23 +0800
Subject: [PATCH] gsgpu: Clean up gsgpu_dc_vbios.c

Improve quality of vendor supplied code:

1. Refactor spaghetti code by defining a table of function pointers
   for each VBIOS resource type.
2. Do not read VBIOS twice. Don't check encoder chip compatibility
   early in the driver loading stage. Do it later, during DC init.
---
 drivers/gpu/drm/gsgpu/bridge/ncs8805_drv.c    |    4 +-
 drivers/gpu/drm/gsgpu/gpu/gsgpu_dc_vbios.c    | 1190 +++++++----------
 drivers/gpu/drm/gsgpu/gpu/gsgpu_drv.c         |    5 -
 drivers/gpu/drm/gsgpu/gpu/gsgpu_pm.c          |    4 +-
 .../gpu/drm/gsgpu/include/gsgpu_dc_resource.h |   23 +-
 .../gpu/drm/gsgpu/include/gsgpu_dc_vbios.h    |  181 +--
 6 files changed, 492 insertions(+), 915 deletions(-)

diff --git a/drivers/gpu/drm/gsgpu/bridge/ncs8805_drv.c b/drivers/gpu/drm/gsgpu/bridge/ncs8805_drv.c
index c606beef7fda..d6bac4545150 100644
--- a/drivers/gpu/drm/gsgpu/bridge/ncs8805_drv.c
+++ b/drivers/gpu/drm/gsgpu/bridge/ncs8805_drv.c
@@ -456,7 +456,7 @@ static struct bridge_phy_helper ncs8805_helper_funcs = {
 	.ddc_funcs = &ncs8805_ddc_funcs,
 };
 
-static bool ncs8805_resources_valid_check(struct ext_encoder_resources *encoder_res)
+static bool ncs8805_resources_valid_check(struct ext_encoder_resource *encoder_res)
 {
 	if (gsgpu_vbios_checksum(encoder_res->data, encoder_res->data_size)
 			== encoder_res->data_checksum)
@@ -467,7 +467,7 @@ static bool ncs8805_resources_valid_check(struct ext_encoder_resources *encoder_
 int bridge_phy_ncs8805_init(struct gsgpu_dc_bridge *dc_bridge)
 {
 	struct gsgpu_bridge_phy *ncs8805_phy;
-	struct ext_encoder_resources  *ext_resource;
+	struct ext_encoder_resource  *ext_resource;
 	u32 feature;
 	int ret = -1;
 
diff --git a/drivers/gpu/drm/gsgpu/gpu/gsgpu_dc_vbios.c b/drivers/gpu/drm/gsgpu/gpu/gsgpu_dc_vbios.c
index ea363f76ef74..ef83f8fb602c 100644
--- a/drivers/gpu/drm/gsgpu/gpu/gsgpu_dc_vbios.c
+++ b/drivers/gpu/drm/gsgpu/gpu/gsgpu_dc_vbios.c
@@ -1,418 +1,155 @@
 #include "gsgpu.h"
 #include "gsgpu_dc_vbios.h"
-#include "gsgpu_dc_resource.h"
 #include <asm/loongson.h>
+#include <linux/acpi.h>
 
 #define VBIOS_START 0x1000
 #define VBIOS_SIZE 0x40000
 #define VBIOS_OFFSET 0x100000
 #define VBIOS_DESC_OFFSET 0x6000
-#define VBIOS_DESC_TOTAL 0xA00
 #define LOONGSON_VBIOS_TITLE "Loongson-VBIOS"
 
-static bool is_valid_vbios(u8 *vbios)
-{
-	struct vbios_info *vb_header = (struct vbios_info *)vbios;
-	char header[VBIOS_HEADER_MAX_TITLE_SIZE] = {0};
-	memcpy(header, vb_header->title, VBIOS_HEADER_MAX_TITLE_SIZE);
-
-	if (memcmp(header, LOONGSON_VBIOS_TITLE, strlen(LOONGSON_VBIOS_TITLE))) {
-		header[VBIOS_HEADER_MAX_TITLE_SIZE-1] = '\0';
-		DRM_WARN("invalid vbios signature, expected %s, got %s\n",
-			 LOONGSON_VBIOS_TITLE, header);
-		return false;
-	}
-
-	return true;
-}
-
-/*
- * Read the VBIOS from mapped PCI ROM
- */
-static u8 *read_vbios_from_mapped_io(u64 phy_addr)
-{
-	void *mapped_vbios = ioremap(phy_addr, VBIOS_SIZE);
-	if (!mapped_vbios) {
-		DRM_WARN("Unable to map VBIOS physical address %p.\n",
-			 (void *)(phy_addr));
-		return false;
-	}
-
-	u8 *vbios = kmalloc(VBIOS_SIZE, GFP_KERNEL);
-	if (IS_ERR_OR_NULL(vbios)) {
-		DRM_WARN("Unable to allocate kernel memory for VBIOS.\n");
-		return false;
-	}
-
-	memcpy(vbios, mapped_vbios, VBIOS_SIZE);
-	iounmap(mapped_vbios);
-
-	DRM_INFO("Got VBIOS from mapped PCI ROM!\n");
-	return vbios;
-}
-
-#ifdef CONFIG_ACPI
-/*
- * Attempt to from the ACPI VIAT table and copy the VBIOS into a kernel-allocated
- * buffer. The caller is responsible for freeing the returned buffer using kfree.
- */
-static u8 *read_vbios_from_acpi(void)
-{
-	struct acpi_table_header *hdr;
-	if (!ACPI_SUCCESS(acpi_get_table("VIAT", 1, &hdr)))
-		return false;
-
-	acpi_size tbl_size = hdr->length;
-	if (tbl_size != sizeof(struct acpi_viat_table)) {
-		DRM_WARN("ACPI viat table present but broken (length error #1)\n");
-		return false;
-	}
-
-	struct acpi_viat_table *viat = (struct acpi_viat_table *)hdr;
-	u8 *vbios = kmalloc(VBIOS_SIZE, GFP_KERNEL);
-	if (IS_ERR_OR_NULL(vbios)) {
-		DRM_WARN("Unable to allocate kernel memory for VBIOS!\n");
-		return false;
-	}
-
-	void *vaddr = phys_to_virt(viat->vbios_addr);
-	memcpy(vbios, vaddr, VBIOS_SIZE);
-	DRM_INFO("Got vbios from ACPI!\n");
-	return vbios;
-}
-#else
-static u8 *read_vbios_from_acpi(void)
-{
-	return NULL;
-}
-#endif
-
-static u8 *read_and_validate_vbios(u64 phy_addr)
-{
-	/* Try reading from mapped PCI ROM first */
-	u8 *vbios = read_vbios_from_mapped_io(phy_addr);
-
-	/* If that didn't work, try ACPI */
-	if (!vbios) {
-		vbios = read_vbios_from_acpi();
-	}
-
-	/* TODO: Add a default VBIOS in case of failure. */
-	if (!vbios) {
-		DRM_ERROR("Unable to locate VBIOS ROM!\n");
-		return NULL;
-	}
-
-	if (!is_valid_vbios(vbios)) {
-		DRM_ERROR("VBIOS Signature Invalid!\n");
-		kfree(vbios);
-		return NULL;
-	}
-
-	return vbios;
-}
-
-static bool dc_get_vbios_data(struct gsgpu_dc *dc)
-{
-	u64 phy_addr = dc->adev->gmc.aper_base + dc->adev->gmc.aper_size - VBIOS_OFFSET;
-
-	dc->vbios->vbios_ptr = read_and_validate_vbios(phy_addr);
-
-	return dc->vbios->vbios_ptr != NULL;
-}
-
-static bool parse_vbios_header(struct vbios_desc *vb_desc, struct gsgpu_vbios *vbios)
-{
-	bool ret = false;
-	u8 *data;
-
-	if (IS_ERR_OR_NULL(vb_desc) || IS_ERR_OR_NULL(vbios))
-		return ret;
-
-	data = (u8 *)vbios->vbios_ptr + vb_desc->offset;
-
-	if (vbios->funcs && vbios->funcs->create_header_resource)
-		ret = vbios->funcs->create_header_resource(vbios, data, vb_desc->size);
-
-	return ret;
-}
-
-static bool parse_vbios_crtc(struct vbios_desc *vb_desc, struct gsgpu_vbios *vbios)
-{
-	bool ret = false;
-	u8 *data;
-
-	if (IS_ERR_OR_NULL(vb_desc) || IS_ERR_OR_NULL(vbios))
-		return ret;
-
-	data = (u8 *)vbios->vbios_ptr + vb_desc->offset;
-
-	if (vbios->funcs && vbios->funcs->create_crtc_resource)
-		ret = vbios->funcs->create_crtc_resource(vbios, data, vb_desc->link,
-							 vb_desc->size);
-
-	return ret;
-}
-
-static bool parse_vbios_connector(struct vbios_desc *vb_desc, struct gsgpu_vbios *vbios)
-{
-	bool ret = false;
-	u8 *data;
-
-	if (IS_ERR_OR_NULL(vb_desc) || IS_ERR_OR_NULL(vbios))
-		return ret;
-
-	data = (u8 *)vbios->vbios_ptr + vb_desc->offset;
-
-	if (vbios->funcs && vbios->funcs->create_connecor_resource)
-		ret = vbios->funcs->create_connecor_resource(vbios, data, vb_desc->link,
-							     vb_desc->size);
-
-	return ret;
-}
+#define VBIOS_DATA_INVAL 0xFF
 
-static bool parse_vbios_encoder(struct vbios_desc *vb_desc, struct gsgpu_vbios *vbios)
-{
-	bool ret = false;
-	u8 *data;
-
-	if (IS_ERR_OR_NULL(vb_desc) || IS_ERR_OR_NULL(vbios))
-		return ret;
-
-	data = (u8 *)vbios->vbios_ptr + vb_desc->offset;
-
-	if (vbios->funcs && vbios->funcs->create_encoder_resource)
-		ret = vbios->funcs->create_encoder_resource(vbios, data, vb_desc->link,
-							    vb_desc->size);
-
-	return ret;
-}
-
-static bool parse_vbios_i2c(struct vbios_desc *vb_desc, struct gsgpu_vbios *vbios)
-{
-	bool ret = false;
-	u8 *data;
-
-	if (IS_ERR_OR_NULL(vb_desc) || IS_ERR_OR_NULL(vbios))
-		return ret;
-
-	data = (u8 *)vbios->vbios_ptr + vb_desc->offset;
-
-	if (vbios->funcs && vbios->funcs->create_i2c_resource)
-		ret = vbios->funcs->create_i2c_resource(vbios, data, vb_desc->link,
-							vb_desc->size);
-
-	return ret;
-}
-
-static bool parse_vbios_pwm(struct vbios_desc *vb_desc, struct gsgpu_vbios *vbios)
-{
-	bool ret = false;
-	u8 *data;
-
-	if (IS_ERR_OR_NULL(vb_desc) || IS_ERR_OR_NULL(vbios))
-		return ret;
-
-	data = (u8 *)vbios->vbios_ptr + vb_desc->offset;
-
-	if (vbios->funcs && vbios->funcs->create_pwm_resource)
-		ret = vbios->funcs->create_pwm_resource(vbios, data, vb_desc->link,
-							vb_desc->size);
-
-	return ret;
-}
-
-static bool parse_vbios_gpu(struct vbios_desc *vb_desc, struct gsgpu_vbios *vbios)
-{
-	bool ret = false;
-	u8 *data;
-
-	if (IS_ERR_OR_NULL(vb_desc) || IS_ERR_OR_NULL(vbios))
-		return ret;
-
-	data = (u8 *)vbios->vbios_ptr + vb_desc->offset;
-
-	if (vbios->funcs && vbios->funcs->create_gpu_resource)
-		ret = vbios->funcs->create_gpu_resource(vbios, data, vb_desc->link,
-							vb_desc->size);
-
-	return ret;
-}
-
-static bool parse_vbios_ext_encoder(struct vbios_desc *vb_desc, struct gsgpu_vbios *vbios)
-{
-	bool ret = false;
-	u8 *data;
-
-	if (IS_ERR_OR_NULL(vb_desc) || IS_ERR_OR_NULL(vbios))
-		return ret;
-
-	data = (u8 *)vbios->vbios_ptr + vb_desc->offset;
-	if (vbios->funcs && vbios->funcs->create_ext_encoder_resource)
-		ret = vbios->funcs->create_ext_encoder_resource(vbios, data, vb_desc->link,
-								vb_desc->size);
-
-	return ret;
-}
-
-static bool parse_vbios_default(struct vbios_desc *vb_desc, struct gsgpu_vbios *vbios)
-{
-	DRM_ERROR("Current descriptor[T-%d][V-%d] cannot be interprete.\n",
-		  vb_desc->type, vb_desc->ver);
-	return false;
-}
-
-#define DESC_PARSER(t, v, f)                                                         \
-	{                                                                     \
-		.type = t, .ver = v, .func = f,                               \
-	}
-
-static struct vbios_desc_parser_table tables[] = {
-	DESC_PARSER(desc_header, ver_v1, parse_vbios_header),
-	DESC_PARSER(desc_crtc, ver_v1, parse_vbios_crtc),
-	DESC_PARSER(desc_encoder, ver_v1, parse_vbios_encoder),
-	DESC_PARSER(desc_connector, ver_v1, parse_vbios_connector),
-	DESC_PARSER(desc_i2c, ver_v1, parse_vbios_i2c),
-	DESC_PARSER(desc_pwm, ver_v1, parse_vbios_pwm),
-	DESC_PARSER(desc_gpu, ver_v1, parse_vbios_gpu),
-	DESC_PARSER(desc_res_encoder, ver_v1, parse_vbios_ext_encoder),
+enum desc_ver {
+	ver_v1,
 };
 
-static inline parse_func *get_parse_func(struct vbios_desc *desc)
-{
-	parse_func *func = parse_vbios_default;
-	u32 tt_num = ARRAY_SIZE(tables);
-	u32 type = desc->type;
-	u32 ver = desc->ver;
-	int i;
-
-	for (i = 0; i < tt_num; i++) {
-		if ((tables[i].ver == ver) && (tables[i].type == type)) {
-			func = tables[i].func;
-			break;
-		}
-	}
-
-	return func;
-}
-
-static inline void parse_vbios_info(struct gsgpu_vbios *vbios)
-{
-	struct vbios_info *vb_info;
-	struct header_resource *header;
-
-	if (IS_ERR_OR_NULL(vbios))
-		return;
-
-	header = vbios->funcs->get_header_resource(vbios);
-	if (IS_ERR_OR_NULL(header))
-		return;
-
-	vb_info = (struct vbios_info *)vbios->vbios_ptr;
-	header->links = vb_info->link_num;
-	header->ver_majro = vb_info->version_major;
-	header->ver_minor = vb_info->version_minor;
-	memcpy(header->name, vb_info->title, 16);
-}
-
-static bool dc_vbios_parse(struct gsgpu_vbios *vbios)
-{
-	struct vbios_header *vb_header;
-	struct vbios_desc *start;
-	struct vbios_desc *desc;
-	enum desc_type type;
-	parse_func *func;
+struct vbios_info {
+	char title[VBIOS_HEADER_MAX_TITLE_SIZE];
+	u32 version_major;
+	u32 version_minor;
+	char information[20];
+	u32 link_num;
+	u32 crtc_offset;
+	u32 connector_num;
+	u32 connector_offset;
+	u32 encoder_num;
+	u32 encoder_offset;
+} __packed;
+
+struct vbios_desc {
+	u16 type;
+	u8 ver;
+	u8 link;
+	u32 offset;
+	u32 size; /* Size of the resource data. Note size of the descriptor! */
+	u64 ext[2];
+} __packed;
+
+struct vbios_header {
+	u32 feature;
+	u8 oem_vendor[VBIOS_OEM_VENDOR_STRING_SIZE];
+	u8 oem_product[VBIOS_OEM_VENDOR_STRING_SIZE];
+	u32 legacy_offset;
+	u32 legacy_size;
+	u32 desc_offset;
+	u32 desc_size;
+	u32 data_offset;
+	u32 data_size;
+} __packed;
+
+struct vbios_gpio {
+	u32 feature;
+	u32 type;
+	u32 level_reg_offset; /* offset of DC */
+	u32 level_reg_mask; /* mask of reg */
+	u32 dir_reg_offset; /* offset of DC */
+	u32 dir_reg_mask; /* mask of reg */
+} __packed;
+
+struct vbios_i2c {
+	u32 feature;
+	u16 id;
+	u8  speed; /* KHZ */
+} __packed;
+
+struct vbios_pwm {
+	u32 feature;
+	u8 pwm;
+	u8 polarity;
+	u32 period;
+} __packed;
+
+struct vbios_encoder {
+	u32 feature;
+	u32 i2c_id;
+	u32 connector_id;
+	enum vbios_encoder_type type;
+	enum vbios_encoder_config config_type;
+	enum vbios_encoder_object chip;
+	u8 chip_addr;
+} __packed;
+
+struct vbios_connector {
+	u32 feature;
+	u32 i2c_id;
+	u8 internal_edid[256];
+	enum vbios_connector_type type;
+	enum vbios_hotplug hotplug;
+	enum vbios_edid_method edid_method;
+	u32 irq_gpio;
+	enum gpio_placement gpio_placement;
+} __packed;
+
+struct vbios_crtc {
+	u32 feature;
+	u32 crtc_id;
+	u32 encoder_id;
+	u32 max_freq;
+	u32 max_width;
+	u32 max_height;
+	bool is_vb_timing;
+} __packed;
+
+struct vbios_gpu {
+	enum vram_type type;
+	u32 bit_width;
+	u32 cap;
+	u32 freq_count;
+	u32 freq;
+	u32 shaders_num;
+	u32 shaders_freq;
+} __packed;
+
+struct vbios_ext_encoder {
+	u32 data_checksum;
+	u32 data_size;
+	u8 data[EXT_ENCODER_DATA_MAX];
+} __packed;
+
+struct gsgpu_vbios {
+	struct gsgpu_dc *dc;
 	u8 *vbios_ptr;
-	bool ret;
-
-	if (IS_ERR_OR_NULL(vbios))
-		return false;
-
-	vbios_ptr = (u8 *)vbios->vbios_ptr;
-	if (IS_ERR_OR_NULL(vbios_ptr))
-		return false;
-
-	/* get header for global information of vbios */
-	desc = (struct vbios_desc *)(vbios_ptr + VBIOS_DESC_OFFSET);
-	if (desc->type != desc_header) {
-		pr_err("vbios first desc not header type\n");
-		return false;
-	}
-
-	func = get_parse_func(desc);
-	if (IS_ERR_OR_NULL(func)) {
-		pr_err("vbios get header parser funcs err %pf \n", func);
-		return false;
-	}
-
-	ret = (*func)(desc, vbios);
-	if (!ret) {
-		pr_err("get vbios header info error \n");
-		return false;
-	}
-
-	vb_header = (struct vbios_header *)(vbios_ptr + desc->offset);
-	DRM_DEBUG("oem-vendor %s oem-product %s\n", vb_header->oem_vendor,
-		 vb_header->oem_product);
-
-	/* start parsing vbios components */
-	start = desc = (struct vbios_desc *)(vbios_ptr + vb_header->desc_offset);
-	while (1) {
-		type = desc->type;
-		if (type == desc_header) {
-			desc++;
-			continue;
-		}
-
-		if (type == desc_max || ((desc - start) > vb_header->desc_size) ||
-		    ((desc - start) > VBIOS_DESC_TOTAL))
-			break;
-
-		func = get_parse_func(desc);
-		if (IS_ERR_OR_NULL(func))
-			continue;
-
-		ret = (*func)(desc, vbios);
-		if (!ret)
-			pr_err("Parse T-%d V-%d failed[%d]\n", desc->ver, desc->type, ret);
-
-		desc++;
-	}
-
-	/* append legacy information to header resource */
-	parse_vbios_info(vbios);
-
-	return true;
-}
-
-static bool vbios_resource_pool_create(struct gsgpu_vbios *vbios)
-{
-	if (IS_ERR_OR_NULL(vbios))
-		return false;
-
-	return dc_vbios_parse(vbios);
-}
-
-static bool vbios_resource_pool_destory(struct gsgpu_vbios *vbios)
-{
-	struct resource_object *entry, *tmp;
-
-	if (IS_ERR_OR_NULL(vbios))
-		return false;
-
-	if (list_empty(&vbios->resource_list))
-		return true;
+	struct list_head resource_list;
+};
 
-	list_for_each_entry_safe (entry, tmp, &vbios->resource_list, node) {
-		list_del(&entry->node);
-		kvfree(entry);
-		entry = NULL;
-	}
+enum desc_type {
+	desc_header = 0,
+	desc_crtc,
+	desc_encoder,
+	desc_connector,
+	desc_i2c,
+	desc_pwm,
+	desc_gpio,
+	desc_backlight,
+	desc_fan,
+	desc_irq_vblank,
+	desc_cfg_encoder,
+	desc_res_encoder,
+	desc_gpu,
+	end_of_desc_table = 0xffff
+};
 
-	return true;
-}
+#ifdef CONFIG_ACPI
+struct acpi_viat_table {
+    struct acpi_table_header header;
+    u64 vbios_addr;
+} __packed;
+#endif
 
-static bool vbios_create_header_resource(struct gsgpu_vbios *vbios, void *data, u32 size)
+static bool vbios_create_header_resource(struct gsgpu_vbios *vbios,
+					 void *data, u32 link, u32 size)
 {
 	struct vbios_header vb_header;
 	struct header_resource *header;
@@ -425,8 +162,10 @@ static bool vbios_create_header_resource(struct gsgpu_vbios *vbios, void *data,
 	memset(&vb_header, VBIOS_DATA_INVAL, header_size);
 	memcpy(&vb_header, data, min(size, header_size));
 
-	memcpy(header->oem_product, vb_header.oem_product, 32);
-	memcpy(header->oem_vendor, vb_header.oem_vendor, 32);
+	memcpy(header->oem_product, vb_header.oem_product, sizeof(vb_header.oem_product));
+	memcpy(header->oem_vendor, vb_header.oem_vendor, sizeof(vb_header.oem_vendor));
+	header->oem_product[sizeof(vb_header.oem_product)-1] = '\0';
+	header->oem_vendor[sizeof(vb_header.oem_vendor)-1] = '\0';
 	header->base.type = GSGPU_RESOURCE_HEADER;
 
 	list_add_tail(&header->base.node, &vbios->resource_list);
@@ -466,7 +205,8 @@ static bool vbios_create_crtc_resource(struct gsgpu_vbios *vbios,
 	return true;
 }
 
-static bool vbios_create_encoder_resource(struct gsgpu_vbios *vbios, void *data, u32 link, u32 size)
+static bool vbios_create_encoder_resource(struct gsgpu_vbios *vbios, void *data,
+					  u32 link, u32 size)
 {
 	struct vbios_encoder vb_encoder;
 	struct encoder_resource *encoder;
@@ -533,7 +273,8 @@ static bool vbios_create_connector_resource(struct gsgpu_vbios *vbios,
 	return true;
 }
 
-static bool vbios_create_i2c_resource(struct gsgpu_vbios *vbios, void *data, u32 link, u32 size)
+static bool vbios_create_i2c_resource(struct gsgpu_vbios *vbios, void *data,
+				      u32 link, u32 size)
 {
 	struct i2c_resource *i2c_resource;
 	struct vbios_i2c vb_i2c;
@@ -568,7 +309,8 @@ static bool vbios_create_gpio_resource(struct gsgpu_vbios *vbios,
 	return false;
 }
 
-static bool vbios_create_pwm_resource(struct gsgpu_vbios *vbios, void *data, u32 link, u32 size)
+static bool vbios_create_pwm_resource(struct gsgpu_vbios *vbios, void *data,
+				      u32 link, u32 size)
 {
 	struct pwm_resource *pwm_resource;
 	struct vbios_pwm vb_pwm;
@@ -598,7 +340,8 @@ static bool vbios_create_pwm_resource(struct gsgpu_vbios *vbios, void *data, u32
 	return true;
 }
 
-static bool vbios_create_gpu_resource(struct gsgpu_vbios *vbios, void *data, u32 link, u32 size)
+static bool vbios_create_gpu_resource(struct gsgpu_vbios *vbios, void *data,
+				      u32 link, u32 size)
 {
 	struct gpu_resource *gpu_resource;
 	struct vbios_gpu vb_gpu;
@@ -621,7 +364,7 @@ static bool vbios_create_gpu_resource(struct gsgpu_vbios *vbios, void *data, u32
 	gpu_resource->vram_type = vb_gpu.type;
 	gpu_resource->bit_width = vb_gpu.bit_width;
 	gpu_resource->cap = vb_gpu.cap;
-	gpu_resource->count_freq = vb_gpu.count_freq;
+	gpu_resource->freq_count = vb_gpu.freq_count;
 	gpu_resource->freq = vb_gpu.freq;
 	gpu_resource->shaders_num = vb_gpu.shaders_num;
 	gpu_resource->shaders_freq = vb_gpu.shaders_freq;
@@ -634,7 +377,7 @@ static bool vbios_create_gpu_resource(struct gsgpu_vbios *vbios, void *data, u32
 static bool vbios_create_ext_encoder_resource(struct gsgpu_vbios *vbios,
 					      void *data, u32 link, u32 size)
 {
-	struct ext_encoder_resources *ext_encoder_resource;
+	struct ext_encoder_resource *ext_encoder_resource;
 	struct vbios_ext_encoder *vb_ext_encoder = kvmalloc(sizeof(struct vbios_ext_encoder),
 							    GFP_KERNEL);
 	if (IS_ERR_OR_NULL(vb_ext_encoder)) {
@@ -667,204 +410,192 @@ static bool vbios_create_ext_encoder_resource(struct gsgpu_vbios *vbios,
 	return true;
 }
 
-static struct header_resource *vbios_get_header_resource(struct gsgpu_vbios *vbios)
-{
-	struct resource_object *entry;
-	struct header_resource *header;
+typedef bool (*vbios_resource_create)(struct gsgpu_vbios *vbios,
+				      void *data, u32 link, u32 size);
 
-	if (IS_ERR_OR_NULL(vbios))
-		return NULL;
+struct vbios_resource_ops {
+	enum desc_type desc_type;
+	u16 desc_ver;
+	enum resource_type res_type;
+	size_t res_offset;
+	bool check_link;
+	vbios_resource_create create;
+};
 
-	if (list_empty(&vbios->resource_list))
-		return NULL;
+#define VBIOS_RESOURCE_OPS(dty, dver, rty_enum, rty, cl, c)		\
+	{ .desc_type = dty, .desc_ver = dver, .res_type = rty_enum,	\
+	  .res_offset = offsetof(struct rty, base),			\
+	  .check_link = cl, .create = c }
+
+static struct vbios_resource_ops vbios_resource_table[] = {
+	VBIOS_RESOURCE_OPS(desc_header, ver_v1, GSGPU_RESOURCE_HEADER,
+			   header_resource, false, vbios_create_header_resource),
+	VBIOS_RESOURCE_OPS(desc_crtc, ver_v1, GSGPU_RESOURCE_CRTC,
+			   crtc_resource, true, vbios_create_crtc_resource),
+	VBIOS_RESOURCE_OPS(desc_encoder, ver_v1, GSGPU_RESOURCE_ENCODER,
+			   encoder_resource, true, vbios_create_encoder_resource),
+	VBIOS_RESOURCE_OPS(desc_connector, ver_v1, GSGPU_RESOURCE_CONNECTOR,
+			   connector_resource, true, vbios_create_connector_resource),
+	VBIOS_RESOURCE_OPS(desc_i2c, ver_v1, GSGPU_RESOURCE_I2C,
+			   i2c_resource, true, vbios_create_i2c_resource),
+	VBIOS_RESOURCE_OPS(desc_gpio, ver_v1, GSGPU_RESOURCE_GPIO,
+			   gpio_resource, true, vbios_create_gpio_resource),
+	VBIOS_RESOURCE_OPS(desc_pwm, ver_v1, GSGPU_RESOURCE_PWM,
+			   pwm_resource, true, vbios_create_pwm_resource),
+	VBIOS_RESOURCE_OPS(desc_gpu, ver_v1, GSGPU_RESOURCE_GPU,
+			   gpu_resource, false, vbios_create_gpu_resource),
+	VBIOS_RESOURCE_OPS(desc_res_encoder, ver_v1, GSGPU_RESOURCE_EXT_ENCODER,
+			   ext_encoder_resource, true, vbios_create_ext_encoder_resource)
+};
 
-	list_for_each_entry (entry, &vbios->resource_list, node) {
-		if (entry->type == GSGPU_RESOURCE_HEADER) {
-			header = container_of(entry, struct header_resource, base);
-			return header;
-		}
-	}
-
-	return NULL;
-}
-
-static struct crtc_resource *vbios_get_crtc_resource(struct gsgpu_vbios *vbios, u32 link)
+static bool parse_vbios_resource(struct gsgpu_vbios *vbios, struct vbios_desc *desc)
 {
-	struct resource_object *entry;
-	struct crtc_resource *crtc;
-
-	if (IS_ERR_OR_NULL(vbios))
-		return NULL;
-
-	if (list_empty(&vbios->resource_list))
-		return NULL;
-
-	list_for_each_entry (entry, &vbios->resource_list, node) {
-		if ((entry->link == link) && entry->type == GSGPU_RESOURCE_CRTC) {
-			crtc = container_of(entry, struct crtc_resource, base);
-			return crtc;
-		}
+	u8 *data = vbios->vbios_ptr + desc->offset;
+	if (!data) {
+		pr_err("Invalid vbios descriptor: data offset 0x%x overflows\n",
+		       desc->offset);
+		return false;
 	}
 
-	return NULL;
-}
-
-static struct encoder_resource *vbios_get_encoder_resource(struct gsgpu_vbios *vbios, u32 link)
-{
-	struct resource_object *entry;
-	struct encoder_resource *encoder;
-
-	if (IS_ERR_OR_NULL(vbios))
-		return NULL;
-
-	if (list_empty(&vbios->resource_list))
-		return NULL;
-
-	list_for_each_entry (entry, &vbios->resource_list, node) {
-		if ((entry->link == link) && entry->type == GSGPU_RESOURCE_ENCODER) {
-			encoder = container_of(entry, struct encoder_resource, base);
-			return encoder;
+	for (int i = 0; i < ARRAY_SIZE(vbios_resource_table); i++) {
+		if ((vbios_resource_table[i].desc_ver == desc->ver) &&
+		    (vbios_resource_table[i].desc_type == desc->type)) {
+			int r = vbios_resource_table[i].create(vbios, data, desc->link,
+							       desc->size);
+			if (!r) {
+				pr_err("Error parsing vbios data. Error = %d", r);
+				return false;
+			}
+			return true;
 		}
 	}
 
-	return NULL;
+	DRM_ERROR("No parser for descriptor type %d, version %d, data %p.\n",
+		  desc->type, desc->ver, data);
+	return false;
 }
 
-static struct connector_resource *vbios_get_connector_resource(struct gsgpu_vbios *vbios, u32 link)
+static void parse_legacy_vbios_info(struct gsgpu_vbios *vbios)
 {
-	struct resource_object *entry;
-	struct connector_resource *connector;
+	struct vbios_info *vb_info;
+	struct header_resource *header;
 
 	if (IS_ERR_OR_NULL(vbios))
-		return NULL;
-
-	if (list_empty(&vbios->resource_list))
-		return NULL;
+		return;
 
-	list_for_each_entry (entry, &vbios->resource_list, node) {
-		if ((entry->link == link) && entry->type == GSGPU_RESOURCE_CONNECTOR) {
-			connector = container_of(entry, struct connector_resource, base);
-			return connector;
-		}
-	}
+	header = dc_get_vbios_resource(vbios, 0, GSGPU_RESOURCE_HEADER);
+	if (IS_ERR_OR_NULL(header))
+		return;
 
-	return NULL;
+	vb_info = (struct vbios_info *)vbios->vbios_ptr;
+	header->links = vb_info->link_num;
+	header->ver_major = vb_info->version_major;
+	header->ver_minor = vb_info->version_minor;
+	memcpy(header->name, vb_info->title, 16);
 }
 
-static struct i2c_resource *vbios_get_i2c_resource(struct gsgpu_vbios *vbios, u32 link)
+/* Return the pointer to the beginning of the vbios resource descriptor table.
+ * The zeroth desciptor always points to the header resource. Diagramatically,
+ *
+ *  |-------------------------------|------------|
+ *  |vbios_desc[0]|vbios_desc[1]|...|vbios_header|
+ *  |-------------------------------|------------|
+ *  |  .offset                      ^
+ *  |     |                         | vbios_header.desc_offset == VBIOS_DESC_OFFSET
+ *  |     |_________________________|
+ *  |     == VBIOS_DESC_OFFSET + vbios_header.desc_size
+ *  |                                            |
+ *  |  .size = size of the resource object,      |
+ *  |          in this case sizeof(vbios_header) |
+ *  |  (Note: this is not sizeof(vbios_desc[0])) |
+ *  |                                            |
+ *  ^                                            |
+ *  VBIOS_DESC_OFFSET                            |
+ *  ^                                            |
+ *  |____________________________________________|
+ *
+ * This table is placed at the fixed offset VBIOS_DESC_OFFSET from the beginning
+ * of the VBIOS. vbios_header.desc_offset points back to the beginning of the
+ * descriptor table, so vbios_header.desc_offset must equal VBIOS_DESC_OFFSET.
+ *
+ * All descriptors have the same size sizeof(vbios_desc[0]). The vbios_header structure
+ * immediately follows the descriptor table. The size of the full descriptor
+ * table is stored in vbios_header.desc_size. This implies that vbios_desc[0].offset
+ * must equal VBIOS_DESC_OFFSET + vbios_header.desc_size. The number of descriptors
+ * is vbios_header.desc_size / sizeof(vbios_desc[0]). vbios_header.desc_size must
+ * be able to divide sizeof(vbios_desc[0]).
+ */
+static inline struct vbios_desc *get_vbios_desc_table(u8 *vbios)
 {
-	struct resource_object *entry;
-	struct i2c_resource *i2c_resource;
-
-	if (IS_ERR_OR_NULL(vbios))
-		return NULL;
-
-	if (list_empty(&vbios->resource_list))
-		return NULL;
-
-	list_for_each_entry (entry, &vbios->resource_list, node) {
-		if ((entry->link == link) && (entry->type == GSGPU_RESOURCE_I2C)) {
-			i2c_resource = container_of(entry, struct i2c_resource, base);
-			return i2c_resource;
-		}
-	}
-
-	return NULL;
+	return (struct vbios_desc *)(vbios + VBIOS_DESC_OFFSET);
 }
 
-static struct gpio_resource
-*vbios_get_gpio_resource(struct gsgpu_vbios *vbios, u32 link)
-{
-	return NULL;
+static inline struct vbios_header *get_vbios_header(u8 *vbios) {
+	return (struct vbios_header *)(vbios + get_vbios_desc_table(vbios)->offset);
 }
 
-static struct pwm_resource *vbios_get_pwm_resource(struct gsgpu_vbios *vbios, u32 link)
+static inline bool validate_vbios_desc_table(u8 *vbios)
 {
-	struct resource_object *entry;
-	struct pwm_resource *pwm_resource;
-
-	if (IS_ERR_OR_NULL(vbios))
-		return NULL;
-
-	if (list_empty(&vbios->resource_list))
-		return NULL;
-
-	list_for_each_entry (entry, &vbios->resource_list, node) {
-		if ((entry->link == link) && (entry->type == GSGPU_RESOURCE_PWM)) {
-			pwm_resource = container_of(entry, struct pwm_resource, base);
-			return pwm_resource;
-		}
+	struct vbios_desc *desc = get_vbios_desc_table(vbios);
+	/* check if the first vbios resource descriptor is the header */
+	if (desc->type != desc_header) {
+		DRM_ERROR("Invalid vbios: first desciptor is not of header type\n");
+		return false;
 	}
 
-	return NULL;
-}
-
-static struct gpu_resource *vbios_get_gpu_resource(struct gsgpu_vbios *vbios, u32 link)
-{
-	struct resource_object *entry;
-	struct gpu_resource *gpu_resource;
-
-	if (IS_ERR_OR_NULL(vbios))
-		return NULL;
-
-	if (list_empty(&vbios->resource_list))
-		return NULL;
-
-	list_for_each_entry (entry, &vbios->resource_list, node) {
-		if ((entry->link == link) && (entry->type == GSGPU_RESOURCE_GPU)) {
-			gpu_resource = container_of(entry, struct gpu_resource, base);
-			return gpu_resource;
-		}
+	struct vbios_header *vb_header = get_vbios_header(vbios);
+	if (vb_header->desc_offset != VBIOS_DESC_OFFSET) {
+		DRM_ERROR("Invalid vbios: vbios_header->desc_offset (0x%x) != VBIOS_DESC_OFFSET\n",
+			  vb_header->desc_offset);
+		return false;
 	}
-
-	return NULL;
+	if (vb_header->desc_size % sizeof(struct vbios_desc) != 0) {
+		DRM_ERROR("Invalid vbios: vb_header->desc_size (0x%x) does not divide 0x%lx\n",
+			  vb_header->desc_size, sizeof(struct vbios_desc));
+		return false;
+	}
+	if (desc->offset != (VBIOS_DESC_OFFSET + vb_header->desc_size)) {
+		DRM_ERROR("Invalid vbios: desc->offset (0x%x) != (VBIOS_DESC_OFFSET + vb_header->desc_size (0x%x))\n",
+			  desc->offset, vb_header->desc_size);
+		return false;
+	}
+	return true;
 }
 
-static struct ext_encoder_resources *vbios_get_ext_encoder_resource(struct gsgpu_vbios *vbios, u32 link)
+static bool dc_vbios_parse(struct gsgpu_vbios *vbios)
 {
-	struct resource_object *entry;
-	struct ext_encoder_resources *ext_encoder_resources;
+	if (IS_ERR_OR_NULL(vbios)) {
+		BUG();
+		return false;
+	}
 
-	if (IS_ERR_OR_NULL(vbios))
-		return NULL;
+	u8 *vbios_ptr = (u8 *)vbios->vbios_ptr;
+	if (IS_ERR_OR_NULL(vbios_ptr)) {
+		BUG();
+		return false;
+	}
 
-	if (list_empty(&vbios->resource_list))
-		return NULL;
+	if (!validate_vbios_desc_table(vbios_ptr)) {
+		BUG();
+		return false;
+	}
 
-	list_for_each_entry (entry, &vbios->resource_list, node) {
-		if ((entry->link == link) && (entry->type == GSGPU_RESOURCE_EXT_ENCODER)) {
-			ext_encoder_resources = container_of(entry, struct ext_encoder_resources, base);
-			return ext_encoder_resources;
+	/* parse vbios resources */
+	struct vbios_desc *desc = get_vbios_desc_table(vbios_ptr);
+	struct vbios_header *vb_header = get_vbios_header(vbios_ptr);
+	int num_desc = vb_header->desc_size / sizeof(struct vbios_desc);
+	for (int i = 0; i < num_desc; i++) {
+		if (desc[i].type == end_of_desc_table) {
+			break;
 		}
+		parse_vbios_resource(vbios, &desc[i]);
 	}
 
-	return NULL;
-}
+	/* append legacy information to the header resource */
+	parse_legacy_vbios_info(vbios);
 
-static struct vbios_funcs vbios_funcs = {
-	.resource_pool_create = vbios_resource_pool_create,
-	.resource_pool_destory = vbios_resource_pool_destory,
-
-	.create_header_resource = vbios_create_header_resource,
-	.create_crtc_resource = vbios_create_crtc_resource,
-	.create_encoder_resource = vbios_create_encoder_resource,
-	.create_connecor_resource = vbios_create_connector_resource,
-	.create_i2c_resource = vbios_create_i2c_resource,
-	.create_gpio_resource = vbios_create_gpio_resource,
-	.create_pwm_resource = vbios_create_pwm_resource,
-	.create_gpu_resource = vbios_create_gpu_resource,
-	.create_ext_encoder_resource = vbios_create_ext_encoder_resource,
-
-	.get_header_resource = vbios_get_header_resource,
-	.get_crtc_resource = vbios_get_crtc_resource,
-	.get_encoder_resource = vbios_get_encoder_resource,
-	.get_connector_resource = vbios_get_connector_resource,
-	.get_i2c_resource = vbios_get_i2c_resource,
-	.get_gpio_resource = vbios_get_gpio_resource,
-	.get_pwm_resource = vbios_get_pwm_resource,
-	.get_gpu_resource = vbios_get_gpu_resource,
-	.get_ext_encoder_resource = vbios_get_ext_encoder_resource,
-};
+	return true;
+}
 
 u8 gsgpu_vbios_checksum(const u8 *data, int size)
 {
@@ -877,7 +608,7 @@ u8 gsgpu_vbios_checksum(const u8 *data, int size)
 
 u32 gsgpu_vbios_version(struct gsgpu_vbios *vbios)
 {
-	struct vbios_info *vb_info = vbios->vbios_ptr;
+	struct vbios_info *vb_info = (struct vbios_info *)vbios->vbios_ptr;
 	u32 minor, major, version;
 
 	major = vb_info->version_major;
@@ -887,228 +618,251 @@ u32 gsgpu_vbios_version(struct gsgpu_vbios *vbios)
 	return version;
 }
 
-static bool dc_vbios_create(struct gsgpu_vbios *vbios)
-{
-	if (IS_ERR_OR_NULL(vbios) || IS_ERR_OR_NULL(vbios->funcs))
-		return false;
-
-	if (vbios->funcs->resource_pool_create)
-		return vbios->funcs->resource_pool_create(vbios);
-
-	return false;
-}
-
 void *dc_get_vbios_resource(struct gsgpu_vbios *vbios, u32 link,
 			    enum resource_type type)
 {
-	if (IS_ERR_OR_NULL(vbios) || IS_ERR_OR_NULL(vbios->funcs)) {
-		DRM_ERROR("GSGPU get vbios resource%d failed\n", type);
-		return NULL;
-	}
-
-	switch (type) {
-	case GSGPU_RESOURCE_HEADER:
-		if (vbios->funcs->get_header_resource)
-			return (void *)vbios->funcs->get_header_resource(vbios);
-		break;
-	case GSGPU_RESOURCE_CRTC:
-		if (vbios->funcs->get_crtc_resource)
-			return (void *)vbios->funcs->get_crtc_resource(vbios, link);
-		break;
-	case GSGPU_RESOURCE_ENCODER:
-		if (vbios->funcs->get_encoder_resource)
-			return (void *)vbios->funcs->get_encoder_resource(vbios, link);
-		break;
-	case GSGPU_RESOURCE_CONNECTOR:
-		if (vbios->funcs->get_connector_resource)
-			return (void *)vbios->funcs->get_connector_resource(vbios, link);
-		break;
-	case GSGPU_RESOURCE_GPIO:
-		if (vbios->funcs->get_gpio_resource)
-			return (void *)vbios->funcs->get_gpio_resource(vbios, link);
-		break;
-	case GSGPU_RESOURCE_I2C:
-		if (vbios->funcs->get_i2c_resource)
-			return (void *)vbios->funcs->get_i2c_resource(vbios, link);
-		break;
-	case GSGPU_RESOURCE_PWM:
-		if (vbios->funcs->get_pwm_resource)
-			return (void *)vbios->funcs->get_pwm_resource(vbios, link);
-		break;
-	case GSGPU_RESOURCE_GPU:
-		if (vbios->funcs->get_gpu_resource)
-			return (void *)vbios->funcs->get_gpu_resource(vbios, 0);
-		break;
-	case GSGPU_RESOURCE_EXT_ENCODER:
-		if (vbios->funcs->get_ext_encoder_resource)
-			return (void *)vbios->funcs->get_ext_encoder_resource(vbios, link);
-		break;
-	default:
-		return NULL;
-		break;
+	BUG_ON(IS_ERR_OR_NULL(vbios));
+
+	for (int i = 0; i < ARRAY_SIZE(vbios_resource_table); i++) {
+		if (type == vbios_resource_table[i].res_type) {
+			bool check_link = vbios_resource_table[i].check_link;
+			struct resource_object *entry;
+			list_for_each_entry(entry, &vbios->resource_list, node) {
+				if ((!check_link || entry->link == link) && entry->type == type) {
+					return (void *)((u8 *)entry - vbios_resource_table[i].res_offset);
+				}
+			}
+		}
 	}
 
 	return NULL;
 }
 
-void dc_vbios_show(struct gsgpu_vbios *vbios)
+static void dc_vbios_show(struct gsgpu_vbios *vbios)
 {
-	struct header_resource *header_res = NULL;
 	struct crtc_resource *crtc_res;
 	struct gpu_resource *gpu_res;
 	char *vram_type[] = {"DDR3", "DDR4", "DDR5"};
 	int i;
 
-	header_res = dc_get_vbios_resource(vbios, 0, GSGPU_RESOURCE_HEADER);
+	struct header_resource *header_res = dc_get_vbios_resource(vbios, 0,
+								   GSGPU_RESOURCE_HEADER);
 	if (header_res == NULL)
 		return;
 
 	DRM_INFO("GSGPU vbios header info:\n");
-	DRM_INFO("ver:%d.%d links%d max_planes%d name %s\n",
-		header_res->ver_majro, header_res->ver_minor,
-		header_res->links, header_res->max_planes, header_res->name);
-	DRM_INFO("oem-vendor %s oem-product %s\n", header_res->oem_vendor,
+	DRM_INFO("ver: %d.%d, links: %d, max_planes: %d, name: %s\n",
+		 header_res->ver_major, header_res->ver_minor,
+		 header_res->links, header_res->max_planes, header_res->name);
+	DRM_INFO("oem-vendor: %s, oem-product: %s\n", header_res->oem_vendor,
 		 header_res->oem_product);
 
 	for (i = 0; i < header_res->links; i++) {
 		crtc_res = dc_get_vbios_resource(vbios, i, GSGPU_RESOURCE_CRTC);
-		DRM_INFO("GSGPU vbios crtc%d max frep%d width%d height%d\n",
-			 i, crtc_res->max_freq,
-			 crtc_res->max_width, crtc_res->max_height);
+		DRM_INFO("GSGPU vbios crtc: %d, max freq: %dHz, width: %d, height: %d\n",
+			 i, crtc_res->max_freq, crtc_res->max_width, crtc_res->max_height);
 	}
 
 	gpu_res = dc_get_vbios_resource(vbios, 0, GSGPU_RESOURCE_GPU);
 	if (!gpu_res)
-		DRM_WARN("Failed to obtain video memory and gpu information from VBIOS! \n");
+		DRM_WARN("Failed to obtain video memory and gpu information from VBIOS!\n");
 	else {
 		dev_info(vbios->dc->adev->dev, "VRAM: %dM %s %dbit %dMhz.\n",
-			gpu_res->cap, vram_type[gpu_res->vram_type],
+			 gpu_res->cap, vram_type[gpu_res->vram_type],
 			 gpu_res->bit_width, gpu_res->freq);
 		dev_info(vbios->dc->adev->dev,
-			 "GSGPU: shaders_num: %d, shaders_freq: %d, freq_count: %d.\n",
-			 gpu_res->shaders_num, gpu_res->shaders_freq, gpu_res->count_freq);
+			 "GSGPU: shaders_num: %d, shaders_freq: %dMHz, freq_count: %d.\n",
+			 gpu_res->shaders_num, gpu_res->shaders_freq, gpu_res->freq_count);
 	}
 }
 
-bool dc_vbios_init(struct gsgpu_dc *dc)
+static bool is_valid_vbios(u8 *vbios)
 {
-	struct vbios_info *header;
-	bool status;
-	bool ret;
-
-	if (IS_ERR_OR_NULL(dc))
-		return false;
+	struct vbios_info *vb_info = (struct vbios_info *)vbios;
+	char header[VBIOS_HEADER_MAX_TITLE_SIZE] = {0};
+	memcpy(header, vb_info->title, VBIOS_HEADER_MAX_TITLE_SIZE);
 
-	dc->vbios = kmalloc(sizeof(*dc->vbios), GFP_KERNEL);
-	if (IS_ERR_OR_NULL(dc->vbios))
+	if (memcmp(header, LOONGSON_VBIOS_TITLE, strlen(LOONGSON_VBIOS_TITLE))) {
+		header[VBIOS_HEADER_MAX_TITLE_SIZE-1] = '\0';
+		DRM_WARN("invalid vbios signature, expected %s, got %s\n",
+			 LOONGSON_VBIOS_TITLE, header);
 		return false;
+	}
 
-	dc->vbios->funcs = &vbios_funcs;
-	dc->vbios->dc = dc;
-	INIT_LIST_HEAD(&dc->vbios->resource_list);
+	return true;
+}
 
-	status = dc_get_vbios_data(dc);
-	if (!status) {
-		DRM_ERROR("GSGPU Can not get vbios from sysconf!!!\n");
-	} else {
-		header = dc->vbios->vbios_ptr;
+/*
+ * Read the VBIOS from mapped PCI ROM
+ */
+static u8 *read_vbios_from_mapped_io(u64 phy_addr)
+{
+	void *mapped_vbios = ioremap(phy_addr, VBIOS_SIZE);
+	if (!mapped_vbios) {
+		DRM_WARN("Unable to map VBIOS physical address %p.\n",
+			 (void *)(phy_addr));
+		return false;
 	}
 
-	ret = dc_vbios_create(dc->vbios);
-	if (ret == false) {
-		pr_err("%s %d failed \n", __func__, __LINE__);
-		kvfree(dc->vbios);
-		dc->vbios = NULL;
+	u8 *vbios = kmalloc(VBIOS_SIZE, GFP_KERNEL);
+	if (IS_ERR_OR_NULL(vbios)) {
+		DRM_WARN("Unable to allocate kernel memory for VBIOS.\n");
+		return false;
 	}
 
-	dc_vbios_show(dc->vbios);
+	memcpy(vbios, mapped_vbios, VBIOS_SIZE);
+	iounmap(mapped_vbios);
 
-	return true;
+	DRM_INFO("Got VBIOS from mapped PCI ROM!\n");
+	return vbios;
 }
 
-void dc_vbios_exit(struct gsgpu_vbios *vbios)
+#ifdef CONFIG_ACPI
+/*
+ * Attempt to read from the ACPI VIAT table and copy the VBIOS data into a kernel
+ * buffer. The caller is responsible for freeing the returned buffer using kfree.
+ */
+static u8 *read_vbios_from_acpi(void)
 {
-	if (IS_ERR_OR_NULL(vbios))
-		return;
+	struct acpi_table_header *hdr;
+	if (!ACPI_SUCCESS(acpi_get_table("VIAT", 1, &hdr)))
+		return false;
 
-	if (!IS_ERR_OR_NULL(vbios->vbios_ptr)) {
-		kvfree(vbios->vbios_ptr);
-		vbios->vbios_ptr = NULL;
+	acpi_size tbl_size = hdr->length;
+	if (tbl_size != sizeof(struct acpi_viat_table)) {
+		DRM_WARN("ACPI viat table present but broken (length error #1)\n");
+		return false;
 	}
 
-	if (!IS_ERR_OR_NULL(vbios->funcs) && (vbios->funcs->resource_pool_destory))
-		vbios->funcs->resource_pool_destory(vbios);
+	struct acpi_viat_table *viat = (struct acpi_viat_table *)hdr;
+	u8 *vbios = kmalloc(VBIOS_SIZE, GFP_KERNEL);
+	if (IS_ERR_OR_NULL(vbios)) {
+		DRM_WARN("Unable to allocate kernel memory for VBIOS!\n");
+		return false;
+	}
 
-	kvfree(vbios);
-	vbios = NULL;
+	void *vaddr = phys_to_virt(viat->vbios_addr);
+	memcpy(vbios, vaddr, VBIOS_SIZE);
+	DRM_INFO("Got vbios from ACPI!\n");
+	return vbios;
 }
+#else
+static u8 *read_vbios_from_acpi(void)
+{
+	return NULL;
+}
+#endif
 
-/*
- * I don't know why the vendor engineer wants to read VBIOS twice, first in
- * this function (called by gsgpu_init) and later during dc_construct().
- * Ideally VBIOS should only be read once. I think eventually we should merge
- * this with the DC initialization code.
- *
- * Vendor coding is very sloppy and the resulting code quality is poor.
- */
-bool check_vbios_info(void)
+static u8 *read_and_validate_vbios(u64 phy_addr)
 {
-	struct pci_dev *pdev = pci_get_device(PCI_VENDOR_ID_LOONGSON, LG100_DEVICE_ID, NULL);
-	int r = pci_enable_device(pdev);
-	if (r) {
-		return false;
+	/* Try reading from mapped PCI ROM first */
+	u8 *vbios = read_vbios_from_mapped_io(phy_addr);
+
+	/* If that didn't work, try ACPI */
+	if (!vbios) {
+		vbios = read_vbios_from_acpi();
 	}
-	resource_size_t vram_base = pci_resource_start(pdev, 2);
-	resource_size_t vram_size = pci_resource_len(pdev, 2);
-	u64 phy_addr = vram_base + vram_size - VBIOS_OFFSET;
 
-	u8 *vbios = read_and_validate_vbios(phy_addr);
+	/* TODO: Add a default VBIOS in case of failure. */
 	if (!vbios) {
-		return false;
+		DRM_ERROR("Unable to locate VBIOS ROM!\n");
+		return NULL;
 	}
 
-	struct vbios_desc *desc = (struct vbios_desc *)(vbios + 0x6000);
-	struct vbios_header *vb_header = (struct vbios_header *)(vbios + desc->offset);
-	struct vbios_desc *start = (struct vbios_desc *)(vbios + vb_header->desc_offset);
-	desc = (struct vbios_desc *)(vbios + vb_header->desc_offset);
-	bool supported = false;
-	while (1) {
-		enum desc_type desc_type = desc->type;
-		if (desc_type != desc_encoder) {
-			desc++;
-			continue;
-		}
+	if (!is_valid_vbios(vbios)) {
+		DRM_ERROR("VBIOS Signature Invalid!\n");
+		kfree(vbios);
+		return NULL;
+	}
 
-		if (desc_type == desc_max ||
-		    ((desc - start) > vb_header->desc_size) ||
-		    ((desc - start) > VBIOS_DESC_TOTAL))
-			break;
+	return vbios;
+}
 
-		void *data = vbios + desc->offset;
-		u32 encoder_size = sizeof(struct vbios_encoder);
-		struct vbios_encoder vb_encoder;
-		memset(&vb_encoder, 0xff, min(desc->size, encoder_size));
-		memcpy(&vb_encoder, data, min(desc->size, encoder_size));
-		DRM_DEBUG_DRIVER("vbios desc type:%d encoder_chip:0x%x\n",
-				 desc->type, vb_encoder.chip);
+static bool dc_get_vbios_data(struct gsgpu_dc *dc)
+{
+	u64 phy_addr = dc->adev->gmc.aper_base + dc->adev->gmc.aper_size - VBIOS_OFFSET;
 
-		switch (vb_encoder.chip) {
+	dc->vbios->vbios_ptr = read_and_validate_vbios(phy_addr);
+
+	return dc->vbios->vbios_ptr != NULL;
+}
+
+bool dc_vbios_init(struct gsgpu_dc *dc)
+{
+	bool status;
+	bool ret;
+
+	if (IS_ERR_OR_NULL(dc))
+		return false;
+
+	dc->vbios = kmalloc(sizeof(*dc->vbios), GFP_KERNEL);
+	if (IS_ERR_OR_NULL(dc->vbios))
+		return false;
+
+	dc->vbios->dc = dc;
+	INIT_LIST_HEAD(&dc->vbios->resource_list);
+
+	status = dc_get_vbios_data(dc);
+	if (!status) {
+		DRM_ERROR("Failed to get DC VBIOS data!\n");
+		return false;
+	}
+
+	ret = dc_vbios_parse(dc->vbios);
+	if (!ret) {
+		pr_err("Failed to parse DC VBIOS!\n");
+		kvfree(dc->vbios);
+		dc->vbios = NULL;
+	}
+
+	dc_vbios_show(dc->vbios);
+
+	/* Check if the encoder is one of the chips we support */
+	struct header_resource *header = dc_get_vbios_resource(dc->vbios, 0,
+							       GSGPU_RESOURCE_HEADER);
+	for (int i = 0; i < header->links; i++) {
+		struct encoder_resource *enc = dc_get_vbios_resource(dc->vbios, i,
+								     GSGPU_RESOURCE_ENCODER);
+		switch (enc->chip) {
 		case INTERNAL_DVO:
 		case INTERNAL_HDMI:
 		case EDP_LT9721:
 		case EDP_LT6711:
 		case LVDS_LT8619:
 		case EDP_NCS8805:
-			supported = true;
+			/* We support them, so continue. */
 			break;
 		default:
-			kfree(vbios);
+			DRM_ERROR("Unsupported encoder chip type %d\n", enc->chip);
 			return false;
 		}
+	}
+
+	return true;
+}
+
+static void vbios_resource_pool_destory(struct gsgpu_vbios *vbios)
+{
+	struct resource_object *entry, *tmp;
+	list_for_each_entry_safe(entry, tmp, &vbios->resource_list, node) {
+		list_del(&entry->node);
+		kvfree(entry);
+		entry = NULL;
+	}
+}
 
-		desc++;
+void dc_vbios_exit(struct gsgpu_vbios *vbios)
+{
+	if (IS_ERR_OR_NULL(vbios))
+		return;
+
+	if (!IS_ERR_OR_NULL(vbios->vbios_ptr)) {
+		kvfree(vbios->vbios_ptr);
+		vbios->vbios_ptr = NULL;
 	}
 
-	kfree(vbios);
-	return supported;
+	vbios_resource_pool_destory(vbios);
+
+	kvfree(vbios);
+	vbios = NULL;
 }
diff --git a/drivers/gpu/drm/gsgpu/gpu/gsgpu_drv.c b/drivers/gpu/drm/gsgpu/gpu/gsgpu_drv.c
index 0a39c8a71129..852b2a296033 100644
--- a/drivers/gpu/drm/gsgpu/gpu/gsgpu_drv.c
+++ b/drivers/gpu/drm/gsgpu/gpu/gsgpu_drv.c
@@ -539,11 +539,6 @@ static int __init gsgpu_init(void)
 		}
 	}
 
-	if (!check_vbios_info()) {
-		DRM_ERROR("gsgpu does not support this board!\n");
-		return -EINVAL;
-	}
-
 	r = gsgpu_sync_init();
 	if (r)
 		goto error_sync;
diff --git a/drivers/gpu/drm/gsgpu/gpu/gsgpu_pm.c b/drivers/gpu/drm/gsgpu/gpu/gsgpu_pm.c
index 5fa0cbb13b40..8002203452fd 100644
--- a/drivers/gpu/drm/gsgpu/gpu/gsgpu_pm.c
+++ b/drivers/gpu/drm/gsgpu/gpu/gsgpu_pm.c
@@ -45,7 +45,7 @@ static ssize_t gsgpu_get_gpu_clk(struct device *dev,
 		regular_freq_count = default_freq_count;
 		max_freq_value = default_freq_value;
 	} else {
-		regular_freq_count = gpu_res->count_freq;
+		regular_freq_count = gpu_res->freq_count;
 		max_freq_value = gpu_res->shaders_freq;
 
 	}
@@ -137,7 +137,7 @@ static ssize_t gsgpu_set_gpu_clk(struct device *dev,
 	if (NULL == gpu_res)
 		regular_freq_count = default_freq_count;
 	else
-		regular_freq_count = gpu_res->count_freq;
+		regular_freq_count = gpu_res->freq_count;
 
 	level = gsgpu_read_level(buf, count, regular_freq_count);
 
diff --git a/drivers/gpu/drm/gsgpu/include/gsgpu_dc_resource.h b/drivers/gpu/drm/gsgpu/include/gsgpu_dc_resource.h
index 7788aa02e845..13817140f8e4 100644
--- a/drivers/gpu/drm/gsgpu/include/gsgpu_dc_resource.h
+++ b/drivers/gpu/drm/gsgpu/include/gsgpu_dc_resource.h
@@ -1,6 +1,11 @@
 #ifndef __DC_RESOURCE_H__
 #define __DC_RESOURCE_H__
-#define ENCODER_DATA_MAX  (1024*8)
+
+#define EXT_ENCODER_DATA_MAX  (1023*8)
+
+#define VBIOS_OEM_VENDOR_STRING_SIZE	32
+#define VBIOS_OEM_PRODUCT_STRING_SIZE	32
+#define VBIOS_HEADER_MAX_TITLE_SIZE	16
 
 enum resource_type {
 	GSGPU_RESOURCE_DEFAULT,
@@ -26,11 +31,11 @@ struct header_resource {
 	struct resource_object base;
 	u32 links;
 	u32 max_planes;
-	u8 ver_majro;
+	u8 ver_major;
 	u8 ver_minor;
-	u8 name[16];
-	u8 oem_vendor[32];
-	u8 oem_product[32];
+	u8 name[VBIOS_HEADER_MAX_TITLE_SIZE];
+	u8 oem_vendor[VBIOS_OEM_VENDOR_STRING_SIZE];
+	u8 oem_product[VBIOS_OEM_PRODUCT_STRING_SIZE];
 };
 
 struct gpio_resource {
@@ -96,17 +101,17 @@ struct gpu_resource {
 	u32 vram_type;
 	u32 bit_width;
 	u32 cap;
-	u32 count_freq;
-	u32 freq;
+	u32 freq;	   /* VRAM Frequency */
+	u32 freq_count;	   /* Number of valid GPU clock frequencies */
 	u32 shaders_num;
 	u32 shaders_freq;
 };
 
-struct ext_encoder_resources {
+struct ext_encoder_resource {
 	struct resource_object base;
 	u32 data_checksum;
 	u32 data_size;
-	u8 data[ENCODER_DATA_MAX-8];
+	u8 data[EXT_ENCODER_DATA_MAX];
 };
 
 enum gpio_placement {
diff --git a/drivers/gpu/drm/gsgpu/include/gsgpu_dc_vbios.h b/drivers/gpu/drm/gsgpu/include/gsgpu_dc_vbios.h
index 7eef8c7bef01..bdbca1a3f54a 100644
--- a/drivers/gpu/drm/gsgpu/include/gsgpu_dc_vbios.h
+++ b/drivers/gpu/drm/gsgpu/include/gsgpu_dc_vbios.h
@@ -1,55 +1,9 @@
 #ifndef __DC_VBIOS_H__
 #define __DC_VBIOS_H__
 
-#include <linux/acpi.h>
 #include "gsgpu_dc_resource.h"
 
-struct gsgpu_vbios;
-struct vbios_desc;
-struct gsgpu_dc;
-
 #define VBIOS_VERSION_V1_1 (11)
-#define VBIOS_DATA_INVAL 0xFF
-
-enum desc_ver {
-	ver_v1,
-};
-
-#define VBIOS_HEADER_MAX_TITLE_SIZE	16
-
-struct vbios_info {
-	char title[VBIOS_HEADER_MAX_TITLE_SIZE];
-	u32 version_major;
-	u32 version_minor;
-	char information[20];
-	u32 link_num;
-	u32 crtc_offset;
-	u32 connector_num;
-	u32 connector_offset;
-	u32 encoder_num;
-	u32 encoder_offset;
-} __packed;
-
-struct vbios_desc {
-	u16 type;
-	u8 ver;
-	u8 link;
-	u32 offset;
-	u32 size;
-	u64 ext[2];
-} __packed;
-
-struct vbios_header {
-	u32 feature;
-	u8 oem_vendor[32];
-	u8 oem_product[32];
-	u32 legacy_offset;
-	u32 legacy_size;
-	u32 desc_offset;
-	u32 desc_size;
-	u32 data_offset;
-	u32 data_size;
-} __packed;
 
 enum gsgpu_edid_method {
 	via_null = 0,
@@ -59,140 +13,9 @@ enum gsgpu_edid_method {
 	via_max = 0xffff,
 } __packed;
 
-struct vbios_gpio {
-	u32 feature;
-	u32 type;
-	u32 level_reg_offset; /* offset of DC */
-	u32 level_reg_mask; /* mask of reg */
-	u32 dir_reg_offset; /* offset of DC */
-	u32 dir_reg_mask; /* mask of reg */
-} __packed;
-
-struct vbios_i2c {
-	u32 feature;
-	u16 id;
-	u8  speed; /* KHZ */
-} __packed;
-
-struct vbios_pwm {
-	u32 feature;
-	u8 pwm;
-	u8 polarity;
-	u32 period;
-} __packed;
-
-struct vbios_encoder {
-	u32 feature;
-	u32 i2c_id;
-	u32 connector_id;
-	enum vbios_encoder_type type;
-	enum vbios_encoder_config config_type;
-	enum vbios_encoder_object chip;
-	u8 chip_addr;
-} __packed;
-
-struct vbios_connector {
-	u32 feature;
-	u32 i2c_id;
-	u8 internal_edid[256];
-	enum vbios_connector_type type;
-	enum vbios_hotplug hotplug;
-	enum vbios_edid_method edid_method;
-	u32 irq_gpio;
-	enum gpio_placement gpio_placement;
-} __packed;
-
-struct vbios_crtc {
-	u32 feature;
-	u32 crtc_id;
-	u32 encoder_id;
-	u32 max_freq;
-	u32 max_width;
-	u32 max_height;
-	bool is_vb_timing;
-} __packed;
-
-struct vbios_gpu {
-	enum vram_type type;
-	u32 bit_width;
-	u32 cap;
-	u32 count_freq;
-	u32 freq;
-	u32 shaders_num;
-	u32 shaders_freq;
-} __packed;
-
-struct vbios_ext_encoder {
-	u32 data_checksum;
-	u32 data_size;
-	u8 data[ENCODER_DATA_MAX-8];
-} __packed;
-
 struct gsgpu_vbios;
-
-struct vbios_funcs {
-	bool (*resource_pool_create)(struct gsgpu_vbios *vbios);
-	bool (*resource_pool_destory)(struct gsgpu_vbios *vbios);
-
-	bool (*create_header_resource)(struct gsgpu_vbios *vbios, void *data, u32 size);
-	bool (*create_i2c_resource)(struct gsgpu_vbios *vbios, void *data, u32 link, u32 size);
-	bool (*create_gpio_resource)(struct gsgpu_vbios *vbios, void *data, u32 link, u32 size);
-	bool (*create_gpu_resource)(struct gsgpu_vbios *vbios, void *data, u32 link, u32 size);
-	bool (*create_pwm_resource)(struct gsgpu_vbios *vbios, void *data, u32 link, u32 size);
-	bool (*create_crtc_resource)(struct gsgpu_vbios *vbios, void *data, u32 link, u32 size);
-	bool (*create_encoder_resource)(struct gsgpu_vbios *vbios, void *data, u32 link, u32 size);
-	bool (*create_connecor_resource)(struct gsgpu_vbios *vbios, void *data, u32 link, u32 size);
-	bool (*create_ext_encoder_resource)(struct gsgpu_vbios *vbios, void *data, u32 link, u32 size);
-
-	struct header_resource *(*get_header_resource)(struct gsgpu_vbios *vbios);
-	struct i2c_resource *(*get_i2c_resource)(struct gsgpu_vbios *vbios, u32 link);
-	struct pwm_resource *(*get_pwm_resource)(struct gsgpu_vbios *vbios, u32 link);
-	struct gpu_resource *(*get_gpu_resource)(struct gsgpu_vbios *vbios, u32 link);
-	struct gpio_resource *(*get_gpio_resource)(struct gsgpu_vbios *vbios, u32 link);
-	struct crtc_resource *(*get_crtc_resource)(struct gsgpu_vbios *vbios, u32 link);
-	struct connector_resource *(*get_connector_resource)(struct gsgpu_vbios *vbios, u32 link);
-	struct encoder_resource *(*get_encoder_resource)(struct gsgpu_vbios *vbios, u32 link);
-	struct ext_encoder_resources *(*get_ext_encoder_resource)(struct gsgpu_vbios *vbios, u32 link);
-};
-
-struct gsgpu_vbios {
-	struct gsgpu_dc *dc;
-	void *vbios_ptr;
-	struct list_head resource_list;
-	struct vbios_funcs *funcs;
-};
-
-enum desc_type {
-	desc_header = 0,
-	desc_crtc,
-	desc_encoder,
-	desc_connector,
-	desc_i2c,
-	desc_pwm,
-	desc_gpio,
-	desc_backlight,
-	desc_fan,
-	desc_irq_vblank,
-	desc_cfg_encoder,
-	desc_res_encoder,
-	desc_gpu,
-	desc_max = 0xffff
-};
-
-#ifdef CONFIG_ACPI
-struct acpi_viat_table {
-    struct acpi_table_header header;
-    u64 vbios_addr;
-} __packed;
-#endif
-
-typedef bool(parse_func)(struct vbios_desc *, struct gsgpu_vbios *);
-
-struct vbios_desc_parser_table {
-	enum desc_type type;
-	u16 ver;
-	parse_func *func;
-};
+struct vbios_desc;
+struct gsgpu_dc;
 
 void *dc_get_vbios_resource(struct gsgpu_vbios *vbios, u32 link,
 			    enum resource_type type);
-- 
2.39.1

