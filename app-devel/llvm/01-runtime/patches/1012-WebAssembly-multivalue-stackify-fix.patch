From 477e7285b12f876ad105188cfcfc8adda7dc29aa Mon Sep 17 00:00:00 2001
From: Samuel Parker <sam.parker@arm.com>
Date: Tue, 15 Nov 2022 09:15:32 +0000
Subject: [PATCH 1012/1013] [WebAssembly] multivalue stackify fix

Don't attempt to move a multivalue def past one of it's prior uses.

Differential Revision: https://reviews.llvm.org/D137824
---
 .../WebAssembly/WebAssemblyRegStackify.cpp    |  15 ++-
 .../multivalue-dont-move-def-past-use.mir     | 106 ++++++++++++++++++
 2 files changed, 116 insertions(+), 5 deletions(-)
 create mode 100644 llvm/test/CodeGen/WebAssembly/multivalue-dont-move-def-past-use.mir

diff --git a/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp b/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp
index f9ef45bfb41c..61cd0c2d7b33 100644
--- a/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp
+++ b/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp
@@ -336,12 +336,17 @@ static bool isSafeToMove(const MachineOperand *Def, const MachineOperand *Use,
   // instruction in which the current value is used, we cannot
   // stackify. Stackifying in this case would require that def moving below the
   // current def in the stack, which cannot be achieved, even with locals.
+  // Also ensure we don't sink the def past any other prior uses.
   for (const auto &SubsequentDef : drop_begin(DefI->defs())) {
-    for (const auto &PriorUse : UseI->uses()) {
-      if (&PriorUse == Use)
-        break;
-      if (PriorUse.isReg() && SubsequentDef.getReg() == PriorUse.getReg())
-        return false;
+    auto I = std::next(MachineBasicBlock::const_iterator(DefI));
+    auto E = std::next(MachineBasicBlock::const_iterator(UseI));
+    for (; I != E; ++I) {
+      for (const auto &PriorUse : I->uses()) {
+        if (&PriorUse == Use)
+          break;
+        if (PriorUse.isReg() && SubsequentDef.getReg() == PriorUse.getReg())
+          return false;
+      }
     }
   }
 
diff --git a/llvm/test/CodeGen/WebAssembly/multivalue-dont-move-def-past-use.mir b/llvm/test/CodeGen/WebAssembly/multivalue-dont-move-def-past-use.mir
new file mode 100644
index 000000000000..4b4661b14466
--- /dev/null
+++ b/llvm/test/CodeGen/WebAssembly/multivalue-dont-move-def-past-use.mir
@@ -0,0 +1,106 @@
+# NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
+# RUN: llc -mtriple=wasm32-unknown-unknown -mattr=+multivalue -run-pass=wasm-reg-stackify -verify-machineinstrs %s -o - | FileCheck %s
+
+--- |
+  target datalayout = "e-m:e-p:32:32-p10:8:8-p20:8:8-i64:64-n32:64-S128-ni:1:10:20"
+  target triple = "wasm32-unknown-wasi"
+
+  declare { i32, i32 } @foo() #0
+
+  define i32 @dont_move_call_past_first_add() #0 {
+  entry:
+    %foo1 = call { i32, i32 } @foo()
+    %foo2 = call { i32, i32 } @foo()
+    %foo1_0 = extractvalue { i32, i32 } %foo2, 0
+    %foo1_1 = extractvalue { i32, i32 } %foo2, 1
+    %foo2_0 = extractvalue { i32, i32 } %foo1, 0
+    %a = add i32 %foo2_0, %foo1_1
+    %b = add i32 %a, %foo1_0
+    ret i32 %b
+  }
+
+  attributes #0 = { "target-features"="+multivalue,+mutable-globals,+sign-ext," }
+
+  !llvm.module.flags = !{!0, !1, !2}
+
+  !0 = !{i32 1, !"wasm-feature-multivalue", i32 43}
+  !1 = !{i32 1, !"wasm-feature-mutable-globals", i32 43}
+  !2 = !{i32 1, !"wasm-feature-sign-ext", i32 43}
+
+...
+---
+name:            dont_move_call_past_first_add
+alignment:       1
+exposesReturnsTwice: false
+legalized:       false
+regBankSelected: false
+selected:        false
+failedISel:      false
+tracksRegLiveness: true
+hasWinCFI:       false
+callsEHReturn:   false
+callsUnwindInit: false
+hasEHCatchret:   false
+hasEHScopes:     false
+hasEHFunclets:   false
+failsVerification: false
+tracksDebugUserValues: false
+registers:
+  - { id: 0, class: i32, preferred-register: '' }
+  - { id: 1, class: i32, preferred-register: '' }
+  - { id: 2, class: i32, preferred-register: '' }
+  - { id: 3, class: i32, preferred-register: '' }
+  - { id: 4, class: i32, preferred-register: '' }
+  - { id: 5, class: i32, preferred-register: '' }
+liveins:
+  - { reg: '$arguments', virtual-reg: '' }
+frameInfo:
+  isFrameAddressTaken: false
+  isReturnAddressTaken: false
+  hasStackMap:     false
+  hasPatchPoint:   false
+  stackSize:       0
+  offsetAdjustment: 0
+  maxAlignment:    1
+  adjustsStack:    false
+  hasCalls:        true
+  stackProtector:  ''
+  functionContext: ''
+  maxCallFrameSize: 0
+  cvBytesOfCalleeSavedRegisters: 0
+  hasOpaqueSPAdjustment: false
+  hasVAStart:      false
+  hasMustTailInVarArgFunc: false
+  hasTailCall:     false
+  localFrameSize:  0
+  savePoint:       ''
+  restorePoint:    ''
+fixedStack:      []
+stack:           []
+callSites:       []
+debugValueSubstitutions: []
+constants:       []
+machineFunctionInfo:
+  params:          [  ]
+  results:         [ i32 ]
+  isCFGStackified: false
+  wasmEHFuncInfo:  {}
+body:             |
+  bb.0.entry:
+    liveins: $arguments
+
+    ; CHECK-LABEL: name: dont_move_call_past_first_add
+    ; CHECK: liveins: $arguments, $value_stack
+    ; CHECK-NEXT: {{  $}}
+    ; CHECK-NEXT: %0:i32, dead %1:i32 = CALL @foo, implicit-def dead $arguments, implicit $sp32, implicit $sp64, implicit-def dead $arguments, implicit $sp32, implicit $sp64
+    ; CHECK-NEXT: [[CALL:%[0-9]+]]:i32, [[CALL1:%[0-9]+]]:i32 = CALL @foo, implicit-def dead $arguments, implicit $sp32, implicit $sp64, implicit-def dead $arguments, implicit $sp32, implicit $sp64
+    ; CHECK-NEXT: [[ADD_I32_:%[0-9]+]]:i32 = ADD_I32 %0, [[CALL1]], implicit-def dead $arguments, implicit-def $value_stack, implicit $value_stack
+    ; CHECK-NEXT: [[ADD_I32_1:%[0-9]+]]:i32 = ADD_I32 [[CALL]], [[ADD_I32_]], implicit-def dead $arguments, implicit-def $value_stack, implicit $value_stack
+    ; CHECK-NEXT: RETURN [[ADD_I32_1]], implicit-def dead $arguments, implicit-def $value_stack, implicit $value_stack
+    %0:i32, dead %1:i32 = CALL @foo, implicit-def dead $arguments, implicit $sp32, implicit $sp64, implicit-def dead $arguments, implicit $sp32, implicit $sp64
+    %2:i32, %3:i32 = CALL @foo, implicit-def dead $arguments, implicit $sp32, implicit $sp64, implicit-def dead $arguments, implicit $sp32, implicit $sp64
+    %4:i32 = ADD_I32 %0, %3, implicit-def dead $arguments
+    %5:i32 = ADD_I32 %4, %2, implicit-def dead $arguments
+    RETURN %5, implicit-def dead $arguments
+
+...
-- 
2.40.0

