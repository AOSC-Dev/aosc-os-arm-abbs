From 4ffc9fdd99912bc2f183451fb6a6a0e698336826 Mon Sep 17 00:00:00 2001
From: Feiyang Chen <chenfeiyang@loongson.cn>
Date: Mon, 21 Mar 2022 14:40:05 +0800
Subject: [PATCH v4 031/123] loongarch64: Add support for emitting floating
 point trinary instructions

---
 VEX/priv/host_loongarch64_defs.c | 84 ++++++++++++++++++++++++++++++++
 VEX/priv/host_loongarch64_defs.h | 13 ++++-
 2 files changed, 96 insertions(+), 1 deletion(-)

diff --git a/VEX/priv/host_loongarch64_defs.c b/VEX/priv/host_loongarch64_defs.c
index 1acbdafec..ce09fbcee 100644
--- a/VEX/priv/host_loongarch64_defs.c
+++ b/VEX/priv/host_loongarch64_defs.c
@@ -660,6 +660,25 @@ static inline const HChar* showLOONGARCH64FpBinOp ( LOONGARCH64FpBinOp op )
    return ret;
 }
 
+static inline const HChar* showLOONGARCH64FpTriOp ( LOONGARCH64FpTriOp op )
+{
+   const HChar* ret;
+   switch (op) {
+      case LAfpbin_FMADD_S:
+         return "fmadd.s";
+      case LAfpbin_FMADD_D:
+         return "fmadd.d";
+      case LAfpbin_FMSUB_S:
+         return "fmsub.s";
+      case LAfpbin_FMSUB_D:
+         return "fmsub.d";
+      default:
+         vpanic("showLOONGARCH64FpTriOp");
+         break;
+   }
+   return ret;
+}
+
 LOONGARCH64Instr* LOONGARCH64Instr_LI ( ULong imm, HReg dst )
 {
    LOONGARCH64Instr* i = LibVEX_Alloc_inline(sizeof(LOONGARCH64Instr));
@@ -759,6 +778,20 @@ LOONGARCH64Instr* LOONGARCH64Instr_FpBinary ( LOONGARCH64FpBinOp op, HReg src2,
    return i;
 }
 
+LOONGARCH64Instr* LOONGARCH64Instr_FpTrinary ( LOONGARCH64FpTriOp op,
+                                               HReg src3, HReg src2,
+                                               HReg src1, HReg dst )
+{
+   LOONGARCH64Instr* i    = LibVEX_Alloc_inline(sizeof(LOONGARCH64Instr));
+   i->tag                 = LAin_FpTri;
+   i->LAin.FpTrinary.op   = op;
+   i->LAin.FpTrinary.src3 = src3;
+   i->LAin.FpTrinary.src2 = src2;
+   i->LAin.FpTrinary.src1 = src1;
+   i->LAin.FpTrinary.dst  = dst;
+   return i;
+}
+
 
 /* -------- Pretty Print instructions ------------- */
 
@@ -839,6 +872,19 @@ static inline void ppFpBinary ( LOONGARCH64FpBinOp op, HReg src2,
    ppHRegLOONGARCH64(src2);
 }
 
+static inline void ppFpTrinary ( LOONGARCH64FpTriOp op, HReg src3,
+                                HReg src2, HReg src1, HReg dst )
+{
+   vex_printf("%s ", showLOONGARCH64FpTriOp(op));
+   ppHRegLOONGARCH64(dst);
+   vex_printf(", ");
+   ppHRegLOONGARCH64(src1);
+   vex_printf(", ");
+   ppHRegLOONGARCH64(src2);
+   vex_printf(", ");
+   ppHRegLOONGARCH64(src3);
+}
+
 void ppLOONGARCH64Instr ( const LOONGARCH64Instr* i, Bool mode64 )
 {
    vassert(mode64 == True);
@@ -873,6 +919,11 @@ void ppLOONGARCH64Instr ( const LOONGARCH64Instr* i, Bool mode64 )
          ppFpBinary(i->LAin.FpBinary.op, i->LAin.FpBinary.src2,
                     i->LAin.FpBinary.src1, i->LAin.FpBinary.dst);
          break;
+      case LAin_FpTri:
+         ppFpTrinary(i->LAin.FpTrinary.op, i->LAin.FpTrinary.src3,
+                     i->LAin.FpTrinary.src2, i->LAin.FpTrinary.src1,
+                     i->LAin.FpTrinary.dst);
+         break;
       default:
          vpanic("ppLOONGARCH64Instr");
          break;
@@ -927,6 +978,12 @@ void getRegUsage_LOONGARCH64Instr ( HRegUsage* u, const LOONGARCH64Instr* i,
          addHRegUse(u, HRmRead, i->LAin.FpBinary.src1);
          addHRegUse(u, HRmWrite, i->LAin.FpBinary.dst);
          break;
+      case LAin_FpTri:
+         addHRegUse(u, HRmRead, i->LAin.FpTrinary.src3);
+         addHRegUse(u, HRmRead, i->LAin.FpTrinary.src2);
+         addHRegUse(u, HRmRead, i->LAin.FpTrinary.src1);
+         addHRegUse(u, HRmWrite, i->LAin.FpTrinary.dst);
+         break;
       default:
          ppLOONGARCH64Instr(i, mode64);
          vpanic("getRegUsage_LOONGARCH64Instr");
@@ -975,6 +1032,12 @@ void mapRegs_LOONGARCH64Instr ( HRegRemap* m, LOONGARCH64Instr* i,
          mapReg(m, &i->LAin.FpBinary.src1);
          mapReg(m, &i->LAin.FpBinary.dst);
          break;
+      case LAin_FpTri:
+         mapReg(m, &i->LAin.FpTrinary.src3);
+         mapReg(m, &i->LAin.FpTrinary.src2);
+         mapReg(m, &i->LAin.FpTrinary.src1);
+         mapReg(m, &i->LAin.FpTrinary.dst);
+         break;
       default:
          ppLOONGARCH64Instr(i, mode64);
          vpanic("mapRegs_LOONGARCH64Instr");
@@ -1504,6 +1567,22 @@ static inline UInt* mkFpBinary ( UInt* p, LOONGARCH64FpBinOp op, HReg src2,
    }
 }
 
+static inline UInt* mkFpTrinary ( UInt* p, LOONGARCH64FpTriOp op, HReg src3,
+                                  HReg src2, HReg src1, HReg dst )
+{
+   switch (op) {
+      case LAfpbin_FMADD_S:
+      case LAfpbin_FMADD_D:
+      case LAfpbin_FMSUB_S:
+      case LAfpbin_FMSUB_D:
+         *p++ = emit_op_fa_fk_fj_fd(op, fregEnc(src3), fregEnc(src2),
+                                    fregEnc(src1), fregEnc(dst));
+         return p;
+      default:
+         return NULL;
+   }
+}
+
 /* Emit an instruction into buf and return the number of bytes used.
    Note that buf is not the insn's final place, and therefore it is
    imperative to emit position-independent code.  If the emitted
@@ -1560,6 +1639,11 @@ Int emit_LOONGARCH64Instr ( /*MB_MOD*/Bool* is_profInc,
          p = mkFpBinary(p, i->LAin.FpBinary.op, i->LAin.FpBinary.src2,
                         i->LAin.FpBinary.src1, i->LAin.FpBinary.dst);
          break;
+      case LAin_FpTri:
+         p = mkFpTrinary(p, i->LAin.FpTrinary.op, i->LAin.FpTrinary.src3,
+                         i->LAin.FpTrinary.src2, i->LAin.FpTrinary.src1,
+                         i->LAin.FpTrinary.dst);
+         break;
       default:
          p = NULL;
          break;
diff --git a/VEX/priv/host_loongarch64_defs.h b/VEX/priv/host_loongarch64_defs.h
index 24c7d70cb..839717649 100644
--- a/VEX/priv/host_loongarch64_defs.h
+++ b/VEX/priv/host_loongarch64_defs.h
@@ -387,7 +387,8 @@ typedef enum {
 
    /* Floating point insns */
    LAin_FpUn,       /* floating point unary */
-   LAin_FpBin       /* floating point binary */
+   LAin_FpBin,      /* floating point binary */
+   LAin_FpTri       /* floating point trinary */
 } LOONGARCH64InstrTag;
 
 typedef struct {
@@ -439,6 +440,13 @@ typedef struct {
          HReg                 src1;
          HReg                 dst;
       } FpBinary;
+      struct {
+         LOONGARCH64FpTriOp   op;
+         HReg                 src3;
+         HReg                 src2;
+         HReg                 src1;
+         HReg                 dst;
+      } FpTrinary;
    } LAin;
 } LOONGARCH64Instr;
 
@@ -465,6 +473,9 @@ extern LOONGARCH64Instr* LOONGARCH64Instr_FpUnary   ( LOONGARCH64FpUnOp op,
 extern LOONGARCH64Instr* LOONGARCH64Instr_FpBinary  ( LOONGARCH64FpBinOp op,
                                                       HReg src2, HReg src1,
                                                       HReg dst );
+extern LOONGARCH64Instr* LOONGARCH64Instr_FpTrinary ( LOONGARCH64FpTriOp op,
+                                                      HReg src3, HReg src2,
+                                                      HReg src1, HReg dst );
 
 extern void ppLOONGARCH64Instr ( const LOONGARCH64Instr* i, Bool mode64 );
 
-- 
2.39.1

