From f89e5c6743b038f24d9467fe79a473e96b5bf1de Mon Sep 17 00:00:00 2001
From: Feiyang Chen <chenfeiyang@loongson.cn>
Date: Wed, 23 Mar 2022 16:27:55 +0800
Subject: [PATCH v4 079/123] loongarch64: Add support for memcheck

---
 memcheck/mc_machine.c   | 113 +++++++++++++++++++++++++++++++++++++++-
 memcheck/mc_translate.c |   3 ++
 2 files changed, 114 insertions(+), 2 deletions(-)

diff --git a/memcheck/mc_machine.c b/memcheck/mc_machine.c
index 697321c5f..6652edd69 100644
--- a/memcheck/mc_machine.c
+++ b/memcheck/mc_machine.c
@@ -1400,7 +1400,113 @@ static Int get_otrack_shadow_offset_wrk ( Int offset, Int szB )
 
 #  elif defined(VGA_loongarch64)
 
-   /* TODO */
+#  define GOF(_fieldname) \
+      (offsetof(VexGuestLOONGARCH64State,guest_##_fieldname))
+#  define SZB(_fieldname) \
+      (sizeof(((VexGuestLOONGARCH64State*)0)->guest_##_fieldname))
+
+   Int  o      = offset;
+   Int  sz     = szB;
+   Bool is48   = sz == 8 || sz == 4;
+   Bool is1248 = sz == 8 || sz == 4 || sz == 2 || sz == 1;
+
+   tl_assert(sz > 0);
+   tl_assert(host_is_little_endian());
+
+   if (o == GOF(R0)  && is1248) return o;
+   if (o == GOF(R1)  && is1248) return o;
+   if (o == GOF(R2)  && is1248) return o;
+   if (o == GOF(R3)  && is1248) return o;
+   if (o == GOF(R4)  && is1248) return o;
+   if (o == GOF(R5)  && is1248) return o;
+   if (o == GOF(R6)  && is1248) return o;
+   if (o == GOF(R7)  && is1248) return o;
+   if (o == GOF(R8)  && is1248) return o;
+   if (o == GOF(R9)  && is1248) return o;
+   if (o == GOF(R10) && is1248) return o;
+   if (o == GOF(R11) && is1248) return o;
+   if (o == GOF(R12) && is1248) return o;
+   if (o == GOF(R13) && is1248) return o;
+   if (o == GOF(R14) && is1248) return o;
+   if (o == GOF(R15) && is1248) return o;
+   if (o == GOF(R16) && is1248) return o;
+   if (o == GOF(R17) && is1248) return o;
+   if (o == GOF(R18) && is1248) return o;
+   if (o == GOF(R19) && is1248) return o;
+   if (o == GOF(R20) && is1248) return o;
+   if (o == GOF(R21) && is1248) return o;
+   if (o == GOF(R22) && is1248) return o;
+   if (o == GOF(R23) && is1248) return o;
+   if (o == GOF(R24) && is1248) return o;
+   if (o == GOF(R25) && is1248) return o;
+   if (o == GOF(R26) && is1248) return o;
+   if (o == GOF(R27) && is1248) return o;
+   if (o == GOF(R28) && is1248) return o;
+   if (o == GOF(R29) && is1248) return o;
+   if (o == GOF(R30) && is1248) return o;
+   if (o == GOF(R31) && is1248) return o;
+
+   if (o == GOF(PC)  && sz == 8) return -1;  /* slot unused */
+
+   if (o >= GOF(F0)  && o + sz <= GOF(F0)  + SZB(F0))  return GOF(F0);
+   if (o >= GOF(F1)  && o + sz <= GOF(F1)  + SZB(F1))  return GOF(F1);
+   if (o >= GOF(F2)  && o + sz <= GOF(F2)  + SZB(F2))  return GOF(F2);
+   if (o >= GOF(F3)  && o + sz <= GOF(F3)  + SZB(F3))  return GOF(F3);
+   if (o >= GOF(F4)  && o + sz <= GOF(F4)  + SZB(F4))  return GOF(F4);
+   if (o >= GOF(F5)  && o + sz <= GOF(F5)  + SZB(F5))  return GOF(F5);
+   if (o >= GOF(F6)  && o + sz <= GOF(F6)  + SZB(F6))  return GOF(F6);
+   if (o >= GOF(F7)  && o + sz <= GOF(F7)  + SZB(F7))  return GOF(F7);
+   if (o >= GOF(F8)  && o + sz <= GOF(F8)  + SZB(F8))  return GOF(F8);
+   if (o >= GOF(F9)  && o + sz <= GOF(F9)  + SZB(F9))  return GOF(F9);
+   if (o >= GOF(F10) && o + sz <= GOF(F10) + SZB(F10)) return GOF(F10);
+   if (o >= GOF(F11) && o + sz <= GOF(F11) + SZB(F11)) return GOF(F11);
+   if (o >= GOF(F12) && o + sz <= GOF(F12) + SZB(F12)) return GOF(F12);
+   if (o >= GOF(F13) && o + sz <= GOF(F13) + SZB(F13)) return GOF(F13);
+   if (o >= GOF(F14) && o + sz <= GOF(F14) + SZB(F14)) return GOF(F14);
+   if (o >= GOF(F15) && o + sz <= GOF(F15) + SZB(F15)) return GOF(F15);
+   if (o >= GOF(F16) && o + sz <= GOF(F16) + SZB(F16)) return GOF(F16);
+   if (o >= GOF(F17) && o + sz <= GOF(F17) + SZB(F17)) return GOF(F17);
+   if (o >= GOF(F18) && o + sz <= GOF(F18) + SZB(F18)) return GOF(F18);
+   if (o >= GOF(F19) && o + sz <= GOF(F19) + SZB(F19)) return GOF(F19);
+   if (o >= GOF(F20) && o + sz <= GOF(F20) + SZB(F20)) return GOF(F20);
+   if (o >= GOF(F21) && o + sz <= GOF(F21) + SZB(F21)) return GOF(F21);
+   if (o >= GOF(F22) && o + sz <= GOF(F22) + SZB(F22)) return GOF(F22);
+   if (o >= GOF(F23) && o + sz <= GOF(F23) + SZB(F23)) return GOF(F23);
+   if (o >= GOF(F24) && o + sz <= GOF(F24) + SZB(F24)) return GOF(F24);
+   if (o >= GOF(F25) && o + sz <= GOF(F25) + SZB(F25)) return GOF(F25);
+   if (o >= GOF(F26) && o + sz <= GOF(F26) + SZB(F26)) return GOF(F26);
+   if (o >= GOF(F27) && o + sz <= GOF(F27) + SZB(F27)) return GOF(F27);
+   if (o >= GOF(F28) && o + sz <= GOF(F28) + SZB(F28)) return GOF(F28);
+   if (o >= GOF(F29) && o + sz <= GOF(F29) + SZB(F29)) return GOF(F29);
+   if (o >= GOF(F30) && o + sz <= GOF(F30) + SZB(F30)) return GOF(F30);
+   if (o >= GOF(F31) && o + sz <= GOF(F31) + SZB(F31)) return GOF(F31);
+
+   if (o == GOF(FCC0) && sz == 1) return -1;  /* slot unused */
+   if (o == GOF(FCC1) && sz == 1) return -1;  /* slot unused */
+   if (o == GOF(FCC2) && sz == 1) return -1;  /* slot unused */
+   if (o == GOF(FCC3) && sz == 1) return -1;  /* slot unused */
+   if (o == GOF(FCC4) && sz == 1) return -1;  /* slot unused */
+   if (o == GOF(FCC5) && sz == 1) return -1;  /* slot unused */
+   if (o == GOF(FCC6) && sz == 1) return -1;  /* slot unused */
+   if (o == GOF(FCC7) && sz == 1) return -1;  /* slot unused */
+   if (o == GOF(FCSR) && sz == 4) return -1;  /* slot unused */
+
+   if (o == GOF(EMNOTE) && sz == 4) return -1;  /* slot unused */
+
+   if (o == GOF(CMSTART) && sz == 8) return -1;  /* slot unused */
+   if (o == GOF(CMLEN)   && sz == 8) return -1;  /* slot unused */
+
+   if (o == GOF(NRADDR)  && sz == 8) return -1;  /* slot unused */
+
+   if (o == GOF(LLSC_SIZE) && sz == 8) return -1;  /* slot unused */
+   if (o == GOF(LLSC_ADDR) && sz == 8) return -1;  /* slot unused */
+   if (o == GOF(LLSC_DATA) && is48)    return -1;  /* slot unused */
+
+   VG_(printf)("MC_(get_otrack_shadow_offset)(loongarch64)(off=%d,sz=%d)\n",
+               offset,szB);
+   tl_assert(0);
+#  undef GOF
+#  undef SZB
 
 #  else
 #    error "FIXME: not implemented for this architecture"
@@ -1525,7 +1631,10 @@ IRType MC_(get_otrack_reg_array_equiv_int_type) ( IRRegArray* arr )
 
    /* ----------------- loongarch64 ----------------- */
 #  elif defined(VGA_loongarch64)
-   /* TODO */
+   VG_(printf)("get_reg_array_equiv_int_type(loongarch64): unhandled: ");
+   ppIRRegArray(arr);
+   VG_(printf)("\n");
+   tl_assert(0);
 
 #  else
 #    error "FIXME: not implemented for this architecture"
diff --git a/memcheck/mc_translate.c b/memcheck/mc_translate.c
index 106696f4e..4e441f069 100644
--- a/memcheck/mc_translate.c
+++ b/memcheck/mc_translate.c
@@ -8658,6 +8658,9 @@ IRSB* MC_(instrument) ( VgCallbackClosure* closure,
       mce.dlbo.dl_CmpEQ64_CmpNE64 = DLexpensive;
 #     elif defined(VGA_arm)
       mce.dlbo.dl_CmpEQ32_CmpNE32 = DLexpensive;
+#     elif defined(VGA_loongarch64)
+      mce.dlbo.dl_CmpEQ32_CmpNE32 = DLexpensive;
+      mce.dlbo.dl_CmpEQ64_CmpNE64 = DLexpensive;
 #     endif
 
       /* preInstrumentationAnalysis() will allocate &mce.tmpHowUsed and then
-- 
2.39.1

