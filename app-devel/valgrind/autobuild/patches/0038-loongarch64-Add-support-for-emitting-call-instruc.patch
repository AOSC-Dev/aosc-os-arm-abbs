From d719e47494ee51e9b6d867ffaea7fb50944aa274 Mon Sep 17 00:00:00 2001
From: Feiyang Chen <chenfeiyang@loongson.cn>
Date: Mon, 21 Mar 2022 15:57:59 +0800
Subject: [PATCH v4 038/123] loongarch64: Add support for emitting call
 instructions

---
 VEX/priv/host_loongarch64_defs.c | 117 +++++++++++++++++++++++++++++++
 VEX/priv/host_loongarch64_defs.h |  20 +++++-
 2 files changed, 136 insertions(+), 1 deletion(-)

diff --git a/VEX/priv/host_loongarch64_defs.c b/VEX/priv/host_loongarch64_defs.c
index eafe52d5b..4dbb4f833 100644
--- a/VEX/priv/host_loongarch64_defs.c
+++ b/VEX/priv/host_loongarch64_defs.c
@@ -957,6 +957,18 @@ LOONGARCH64Instr* LOONGARCH64Instr_CMove ( HReg cond, HReg r0, HReg r1,
    return i;
 }
 
+LOONGARCH64Instr* LOONGARCH64Instr_Call ( HReg cond, Addr64 target,
+                                          UInt nArgRegs, RetLoc rloc )
+{
+   LOONGARCH64Instr* i   = LibVEX_Alloc_inline(sizeof(LOONGARCH64Instr));
+   i->tag                = LAin_Call;
+   i->LAin.Call.cond     = cond;
+   i->LAin.Call.target   = target;
+   i->LAin.Call.nArgRegs = nArgRegs;
+   i->LAin.Call.rloc     = rloc;
+   return i;
+}
+
 
 /* -------- Pretty Print instructions ------------- */
 
@@ -1144,6 +1156,21 @@ static inline void ppCMove ( HReg cond, HReg r0, HReg r1,
    }
 }
 
+static inline void ppCall ( HReg cond, Addr64 target,
+                            UInt nArgRegs, RetLoc rloc )
+{
+   if (!hregIsInvalid(cond)) {
+      vex_printf("if (");
+      ppHRegLOONGARCH64(cond);
+      vex_printf(") { ");
+   }
+   vex_printf("call 0x%llx [nArgRegs=%u, ", target, nArgRegs);
+   ppRetLoc(rloc);
+   vex_printf("]");
+   if (!hregIsInvalid(cond))
+      vex_printf(" }");
+}
+
 void ppLOONGARCH64Instr ( const LOONGARCH64Instr* i, Bool mode64 )
 {
    vassert(mode64 == True);
@@ -1211,6 +1238,10 @@ void ppLOONGARCH64Instr ( const LOONGARCH64Instr* i, Bool mode64 )
                  i->LAin.CMove.r1, i->LAin.CMove.dst,
                  i->LAin.CMove.isInt);
          break;
+      case LAin_Call:
+         ppCall(i->LAin.Call.cond, i->LAin.Call.target,
+                i->LAin.Call.nArgRegs, i->LAin.Call.rloc);
+         break;
       default:
          vpanic("ppLOONGARCH64Instr");
          break;
@@ -1305,6 +1336,43 @@ void getRegUsage_LOONGARCH64Instr ( HRegUsage* u, const LOONGARCH64Instr* i,
          addHRegUse(u, HRmRead, i->LAin.CMove.r1);
          addHRegUse(u, HRmWrite, i->LAin.CMove.dst);
          break;
+      case LAin_Call:
+         /* logic and comments copied/modified from mips and arm64 back end */
+         /* This is a bit subtle. */
+         /* First off, we need to consider the cond register. */
+         if (!hregIsInvalid(i->LAin.Call.cond))
+            addHRegUse(u, HRmRead, i->LAin.Call.cond);
+         /* Then, claim it trashes all the caller-saved regs
+            which fall within the register allocator's jurisdiction. */
+         addHRegUse(u, HRmWrite, hregLOONGARCH64_R14());
+         addHRegUse(u, HRmWrite, hregLOONGARCH64_R15());
+         addHRegUse(u, HRmWrite, hregLOONGARCH64_R16());
+         addHRegUse(u, HRmWrite, hregLOONGARCH64_R17());
+         addHRegUse(u, HRmWrite, hregLOONGARCH64_R18());
+         addHRegUse(u, HRmWrite, hregLOONGARCH64_R19());
+         addHRegUse(u, HRmWrite, hregLOONGARCH64_R20());
+         /* Now we have to state any parameter-carrying registers
+            which might be read.  This depends on nArgRegs. */
+            switch (i->LAin.Call.nArgRegs) {
+            case 8: addHRegUse(u, HRmRead, hregLOONGARCH64_R11()); /* fallthrough */
+            case 7: addHRegUse(u, HRmRead, hregLOONGARCH64_R10()); /* fallthrough */
+            case 6: addHRegUse(u, HRmRead, hregLOONGARCH64_R9());  /* fallthrough */
+            case 5: addHRegUse(u, HRmRead, hregLOONGARCH64_R8());  /* fallthrough */
+            case 4: addHRegUse(u, HRmRead, hregLOONGARCH64_R7());  /* fallthrough */
+            case 3: addHRegUse(u, HRmRead, hregLOONGARCH64_R6());  /* fallthrough */
+            case 2: addHRegUse(u, HRmRead, hregLOONGARCH64_R5());  /* fallthrough */
+            case 1: addHRegUse(u, HRmRead, hregLOONGARCH64_R4());  /* fallthrough */
+            case 0: break;
+            default: vpanic("getRegUsage_LOONGARCH64:Call:regparms"); break;
+         }
+         /* Finally, there is the issue that the insn trashes a
+            register because the literal target address has to be
+            loaded into a register.  However, we reserve $t0 for that
+            purpose so there's no further complexity here.  Stating $t0
+            as trashed is pointless since it's not under the control
+            of the allocator, but what the hell. */
+         addHRegUse(u, HRmWrite, hregT0());
+         break;
       default:
          ppLOONGARCH64Instr(i, mode64);
          vpanic("getRegUsage_LOONGARCH64Instr");
@@ -1393,6 +1461,11 @@ void mapRegs_LOONGARCH64Instr ( HRegRemap* m, LOONGARCH64Instr* i,
          mapReg(m, &i->LAin.CMove.r1);
          mapReg(m, &i->LAin.CMove.dst);
          break;
+      case LAin_Call:
+         if (!hregIsInvalid(i->LAin.Call.cond))
+            mapReg(m, &i->LAin.Call.cond);
+         /* Hardwires $r12. */
+         break;
       default:
          ppLOONGARCH64Instr(i, mode64);
          vpanic("mapRegs_LOONGARCH64Instr");
@@ -2156,6 +2229,46 @@ static inline UInt* mkCMove ( UInt* p, HReg cond, HReg r0,
    return p;
 }
 
+static inline UInt* mkCall ( UInt* p, HReg cond, Addr64 target, RetLoc rloc )
+{
+   if (!hregIsInvalid(cond) && rloc.pri != RLPri_None) {
+      /* The call might not happen (it isn't unconditional) and
+         it returns a result.  In this case we will need to
+         generate a control flow diamond to put 0x555..555 in
+         the return register(s) in the case where the call
+         doesn't happen.  If this ever becomes necessary, maybe
+         copy code from the 32-bit ARM equivalent.  Until that
+         day, just give up. */
+      return NULL;
+   }
+
+   UInt* ptmp = NULL;
+   if (!hregIsInvalid(cond)) {
+      /* Create a hole to put a conditional branch in.  We'll
+         patch it once we know the branch length. */
+      ptmp = p;
+      p++;
+   }
+
+   /*
+      $t0 = target
+      jirl $ra, $t0, 0
+    */
+   p = mkLoadImm(p, hregT0(), target);
+   *p++ = emit_op_offs16_rj_rd(LAextra_JIRL, 0, 12, 1);
+
+   /* Patch the hole if necessary */
+   if (!hregIsInvalid(cond)) {
+      vassert(ptmp != NULL);
+      UInt offs = (UInt)(p - ptmp);
+      vassert(offs >= 3 && offs <= 6);
+      /* beq cond, $zero, offs */
+      *ptmp++ = emit_op_offs16_rj_rd(LAextra_BEQ, offs, iregEnc(cond), 0);
+   }
+
+   return p;
+}
+
 /* Emit an instruction into buf and return the number of bytes used.
    Note that buf is not the insn's final place, and therefore it is
    imperative to emit position-independent code.  If the emitted
@@ -2246,6 +2359,10 @@ Int emit_LOONGARCH64Instr ( /*MB_MOD*/Bool* is_profInc,
                      i->LAin.CMove.r1, i->LAin.CMove.dst,
                      i->LAin.CMove.isInt);
          break;
+      case LAin_Call:
+         p = mkCall(p, i->LAin.Call.cond, i->LAin.Call.target,
+                    i->LAin.Call.rloc);
+         break;
       default:
          p = NULL;
          break;
diff --git a/VEX/priv/host_loongarch64_defs.h b/VEX/priv/host_loongarch64_defs.h
index 5c5c0ad82..8f6ce7091 100644
--- a/VEX/priv/host_loongarch64_defs.h
+++ b/VEX/priv/host_loongarch64_defs.h
@@ -93,6 +93,12 @@ ST_IN HReg hregLOONGARCH64_FCSR3 ( void ) { return mkHReg(False, HRcInt32, 3, 40
 
 #undef ST_IN
 
+#define hregZERO() hregLOONGARCH64_R0()
+#define hregSP()   hregLOONGARCH64_R3()
+#define hregT0()   hregLOONGARCH64_R12()
+#define hregT1()   hregLOONGARCH64_R13()
+#define hregGSP()  hregLOONGARCH64_R31()
+
 extern UInt ppHRegLOONGARCH64 ( HReg reg );
 
 /* Number of registers used arg passing in function calls */
@@ -401,7 +407,11 @@ typedef enum {
    /* Pseudo-insn */
    LAin_Cas,        /* compare and swap */
    LAin_Cmp,        /* word compare */
-   LAin_CMove       /* condition move */
+   LAin_CMove,      /* condition move */
+
+   /* Call target (an absolute address), on given
+      condition (which could be LAcc_AL). */
+   LAin_Call        /* call */
 } LOONGARCH64InstrTag;
 
 typedef struct {
@@ -501,6 +511,12 @@ typedef struct {
          HReg                 dst;
          Bool                 isInt;
       } CMove;
+      struct {
+         HReg                 cond;
+         Addr64               target;
+         UInt                 nArgRegs;
+         RetLoc               rloc;
+      } Call;
    } LAin;
 } LOONGARCH64Instr;
 
@@ -549,6 +565,8 @@ extern LOONGARCH64Instr* LOONGARCH64Instr_Cmp       ( LOONGARCH64CondCode cond,
                                                       HReg dst );
 extern LOONGARCH64Instr* LOONGARCH64Instr_CMove     ( HReg cond, HReg r0, HReg r1,
                                                       HReg dst, Bool isInt );
+extern LOONGARCH64Instr* LOONGARCH64Instr_Call      ( HReg cond, Addr64 target,
+                                                      UInt nArgRegs, RetLoc rloc );
 
 extern void ppLOONGARCH64Instr ( const LOONGARCH64Instr* i, Bool mode64 );
 
-- 
2.39.1

