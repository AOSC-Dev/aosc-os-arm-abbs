From d8113be6be4dc6e6b55f55a22a809187cc72c741 Mon Sep 17 00:00:00 2001
From: Feiyang Chen <chenfeiyang@loongson.cn>
Date: Mon, 21 Mar 2022 16:14:40 +0800
Subject: [PATCH v4 042/123] loongarch64: Implement
 chainXDirect_LOONGARCH64()/unchainXDirect_LOONGARCH64()

---
 VEX/priv/host_loongarch64_defs.c | 52 ++++++++++++++++++++++++++++++--
 1 file changed, 50 insertions(+), 2 deletions(-)

diff --git a/VEX/priv/host_loongarch64_defs.c b/VEX/priv/host_loongarch64_defs.c
index 8fef2ffbd..b52f2d4db 100644
--- a/VEX/priv/host_loongarch64_defs.c
+++ b/VEX/priv/host_loongarch64_defs.c
@@ -2890,7 +2890,31 @@ VexInvalRange chainXDirect_LOONGARCH64 ( VexEndness endness_host,
 {
    vassert(endness_host == VexEndnessLE);
 
-   VexInvalRange vir = { (HWord)place_to_chain, 0 };
+   /* What we're expecting to see is:
+    *  la $t0, disp_cp_chain_me_to_EXPECTED
+    *  jirl $ra, $t0, 0
+    * viz
+    *  <16 bytes generated by mkLoadImm_EXACTLY4>
+    *  jirl $ra, $t0, 0
+    */
+   UInt* p = (UInt*)place_to_chain;
+   vassert(((HWord)p & 3) == 0);
+   vassert(is_LoadImm_EXACTLY4(p, hregT0(), (ULong)(Addr)disp_cp_chain_me_EXPECTED));
+   vassert(p[4] == emit_op_offs16_rj_rd(LAextra_JIRL, 0, 12, 1));
+
+   /* And what we want to change it to is:
+    *  la $t0, place_to_jump_to
+    *  jirl $ra, $t0, 0
+    * viz
+    *  <16 bytes generated by mkLoadImm_EXACTLY4>
+    *  jirl $ra, $t0, 0
+    *
+    * The replacement has the same length as the original.
+    */
+   p = mkLoadImm_EXACTLY4(p, hregT0(), (ULong)(Addr)place_to_jump_to);
+   *p++ = emit_op_offs16_rj_rd(LAextra_JIRL, 0, 12, 1);
+
+   VexInvalRange vir = { (HWord)place_to_chain, 4 * 4 + 4 };
    return vir;
 }
 
@@ -2903,7 +2927,31 @@ VexInvalRange unchainXDirect_LOONGARCH64 ( VexEndness endness_host,
 {
    vassert(endness_host == VexEndnessLE);
 
-   VexInvalRange vir = { (HWord)place_to_unchain, 0 };
+   /* What we're expecting to see is:
+    *  la $t0, place_to_jump_to_EXPECTED
+    *  jirl $ra, $t0, 0
+    * viz
+    *  <16 bytes generated by mkLoadImm_EXACTLY4>
+    *  jirl $ra, $t0, 0
+    */
+   UInt* p = (UInt*)place_to_unchain;
+   vassert(((HWord)p & 3) == 0);
+   vassert(is_LoadImm_EXACTLY4(p, hregT0(), (ULong)(Addr)place_to_jump_to_EXPECTED));
+   vassert(p[4] == emit_op_offs16_rj_rd(LAextra_JIRL, 0, 12, 1));
+
+   /* And what we want to change it to is:
+    *  la $t0, disp_cp_chain_me
+    *  jirl $ra, $t0, 0
+    * viz
+    *  <16 bytes generated by mkLoadImm_EXACTLY4>
+    *  jirl $ra, $t0, 0
+    *
+    * The replacement has the same length as the original.
+    */
+   p = mkLoadImm_EXACTLY4(p, hregT0(), (ULong)(Addr)disp_cp_chain_me);
+   *p++ = emit_op_offs16_rj_rd(LAextra_JIRL, 0, 12, 1);
+
+   VexInvalRange vir = { (HWord)place_to_unchain, 4 * 4 + 4 };
    return vir;
 }
 
-- 
2.39.1

