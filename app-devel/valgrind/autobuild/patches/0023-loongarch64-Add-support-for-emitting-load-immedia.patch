From 16ea91b846498a3c42dada4b8ac6aa5df98decd1 Mon Sep 17 00:00:00 2001
From: Feiyang Chen <chenfeiyang@loongson.cn>
Date: Mon, 8 Aug 2022 11:23:43 +0800
Subject: [PATCH v4 023/123] loongarch64: Add support for emitting load
 immediate instructions

---
 VEX/priv/host_loongarch64_defs.c | 85 ++++++++++++++++++++++++++++++++
 VEX/priv/host_loongarch64_defs.h |  2 +
 2 files changed, 87 insertions(+)

diff --git a/VEX/priv/host_loongarch64_defs.c b/VEX/priv/host_loongarch64_defs.c
index 7b6882939..cced18bf3 100644
--- a/VEX/priv/host_loongarch64_defs.c
+++ b/VEX/priv/host_loongarch64_defs.c
@@ -362,12 +362,34 @@ static inline void mapRegs_LOONGARCH64RI( HRegRemap* m, LOONGARCH64RI* ri )
 }
 
 
+/* --------- Instructions. --------- */
+
+LOONGARCH64Instr* LOONGARCH64Instr_LI ( ULong imm, HReg dst )
+{
+   LOONGARCH64Instr* i = LibVEX_Alloc_inline(sizeof(LOONGARCH64Instr));
+   i->tag              = LAin_LI;
+   i->LAin.LI.imm      = imm;
+   i->LAin.LI.dst      = dst;
+   return i;
+}
+
+
 /* -------- Pretty Print instructions ------------- */
 
+static inline void ppLI ( ULong imm, HReg dst )
+{
+   vex_printf("li ");
+   ppHRegLOONGARCH64(dst);
+   vex_printf(", 0x%llx", imm);
+}
+
 void ppLOONGARCH64Instr ( const LOONGARCH64Instr* i, Bool mode64 )
 {
    vassert(mode64 == True);
    switch (i->tag) {
+      case LAin_LI:
+         ppLI(i->LAin.LI.imm, i->LAin.LI.dst);
+         break;
       default:
          vpanic("ppLOONGARCH64Instr");
          break;
@@ -383,6 +405,9 @@ void getRegUsage_LOONGARCH64Instr ( HRegUsage* u, const LOONGARCH64Instr* i,
    vassert(mode64 == True);
    initHRegUsage(u);
    switch (i->tag) {
+      case LAin_LI:
+         addHRegUse(u, HRmWrite, i->LAin.LI.dst);
+         break;
       default:
          ppLOONGARCH64Instr(i, mode64);
          vpanic("getRegUsage_LOONGARCH64Instr");
@@ -395,6 +420,9 @@ void mapRegs_LOONGARCH64Instr ( HRegRemap* m, LOONGARCH64Instr* i,
 {
    vassert(mode64 == True);
    switch (i->tag) {
+      case LAin_LI:
+         mapReg(m, &i->LAin.LI.dst);
+         break;
       default:
          ppLOONGARCH64Instr(i, mode64);
          vpanic("mapRegs_LOONGARCH64Instr");
@@ -643,6 +671,60 @@ static inline UInt emit_op_hint15 ( UInt op, UInt hint )
    return op | hint;
 }
 
+static UInt* mkLoadImm_EXACTLY4 ( UInt* p, HReg dst, ULong imm )
+{
+   /*
+      lu12i.w dst, imm[31:12]
+      ori     dst, dst, imm[11:0]
+      lu32i.d dst, imm[51:32]
+      lu52i.d dst, dst, imm[63:52]
+    */
+   UInt d = iregEnc(dst);
+   *p++ = emit_op_si20_rd(LAextra_LU12I_W, (imm >> 12) & 0xfffff, d);
+   *p++ = emit_op_si12_rj_rd(LAbin_ORI, imm & 0xfff, d, d);
+   *p++ = emit_op_si20_rd(LAextra_LU32I_D, (imm >> 32) & 0xfffff, d);
+   *p++ = emit_op_si12_rj_rd(LAextra_LU52I_D, (imm >> 52) & 0xfff, d, d);
+   return p;
+}
+
+static inline UInt* mkLoadImm_EXACTLY2 ( UInt* p, HReg dst, ULong imm )
+{
+   /*
+      lu12i.w dst, imm[31:12]
+      ori     dst, dst, imm[11:0]
+    */
+   UInt d = iregEnc(dst);
+   *p++ = emit_op_si20_rd(LAextra_LU12I_W, (imm >> 12) & 0xfffff, d);
+   *p++ = emit_op_si12_rj_rd(LAbin_ORI, imm & 0xfff, d, d);
+   return p;
+}
+
+static inline UInt* mkLoadImm_EXACTLY1 ( UInt* p, HReg dst, ULong imm )
+{
+   /* ori dst, $zero, imm[11:0] */
+   *p++ = emit_op_si12_rj_rd(LAbin_ORI, imm, 0, iregEnc(dst));
+   return p;
+}
+
+static UInt* mkLoadImm ( UInt* p, HReg dst, ULong imm )
+{
+   if ((imm >> 12) == 0)
+      p = mkLoadImm_EXACTLY1(p, dst, imm);
+   else if (imm < 0x80000000 || (imm >> 31) == 0x1ffffffffUL)
+      p = mkLoadImm_EXACTLY2(p, dst, imm);
+   else
+      p = mkLoadImm_EXACTLY4(p, dst, imm);
+   return p;
+}
+
+static Bool is_LoadImm_EXACTLY4 ( UInt* p, HReg dst, ULong imm )
+{
+   UInt expect[4];
+   mkLoadImm_EXACTLY4(expect, dst, imm);
+   return toBool(p[0] == expect[0] && p[1] == expect[1] &&
+                 p[2] == expect[2] && p[3] == expect[3]);
+}
+
 /* Emit an instruction into buf and return the number of bytes used.
    Note that buf is not the insn's final place, and therefore it is
    imperative to emit position-independent code.  If the emitted
@@ -666,6 +748,9 @@ Int emit_LOONGARCH64Instr ( /*MB_MOD*/Bool* is_profInc,
    vassert((((HWord)buf) & 3) == 0);
 
    switch (i->tag) {
+      case LAin_LI:
+         p = mkLoadImm(p, i->LAin.LI.dst, i->LAin.LI.imm);
+         break;
       default:
          p = NULL;
          break;
diff --git a/VEX/priv/host_loongarch64_defs.h b/VEX/priv/host_loongarch64_defs.h
index f0631fad6..3920302ea 100644
--- a/VEX/priv/host_loongarch64_defs.h
+++ b/VEX/priv/host_loongarch64_defs.h
@@ -388,6 +388,8 @@ typedef struct {
    } LAin;
 } LOONGARCH64Instr;
 
+extern LOONGARCH64Instr* LOONGARCH64Instr_LI        ( ULong imm, HReg dst );
+
 extern void ppLOONGARCH64Instr ( const LOONGARCH64Instr* i, Bool mode64 );
 
 /* Some functions that insulate the register allocator from details
-- 
2.39.1

