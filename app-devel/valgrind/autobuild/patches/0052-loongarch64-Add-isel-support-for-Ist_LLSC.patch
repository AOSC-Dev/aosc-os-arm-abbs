From 3e9fb179780c7fab9c193f4dabb920e9857c83f6 Mon Sep 17 00:00:00 2001
From: Feiyang Chen <chenfeiyang@loongson.cn>
Date: Tue, 22 Mar 2022 09:58:58 +0800
Subject: [PATCH v4 052/123] loongarch64: Add isel support for Ist_LLSC

---
 VEX/priv/host_loongarch64_isel.c | 57 ++++++++++++++++++++++++++++++++
 1 file changed, 57 insertions(+)

diff --git a/VEX/priv/host_loongarch64_isel.c b/VEX/priv/host_loongarch64_isel.c
index e63515169..0ac5bfb55 100644
--- a/VEX/priv/host_loongarch64_isel.c
+++ b/VEX/priv/host_loongarch64_isel.c
@@ -964,6 +964,58 @@ static void iselStmtDirty ( ISelEnv* env, IRStmt* stmt )
    }
 }
 
+static void iselStmtLLSC ( ISelEnv* env, IRStmt* stmt )
+{
+   IRTemp res = stmt->Ist.LLSC.result;
+   IRType tya = typeOfIRExpr(env->type_env, stmt->Ist.LLSC.addr);
+
+   /* Temporary solution; this need to be rewritten again for LOONGARCH64.
+      On LOONGARCH64 you can not read from address that is locked with LL
+      before SC. If you read from address that is locked than SC will fall.
+    */
+   if (stmt->Ist.LLSC.storedata == NULL) {
+      /* LL */
+      IRType ty = typeOfIRTemp(env->type_env, res);
+      LOONGARCH64LLSCOp op;
+      switch (ty) {
+         case Ity_I32:
+            op = LAllsc_LL_W;
+            break;
+         case Ity_I64:
+            op = LAllsc_LL_D;
+            break;
+         default:
+            vpanic("iselStmt(loongarch64): Ist_LLSC");
+            break;
+      }
+      LOONGARCH64AMode* addr = iselIntExpr_AMode(env, stmt->Ist.LLSC.addr, tya);
+      HReg               val = lookupIRTemp(env, res);
+      addInstr(env, LOONGARCH64Instr_LLSC(op, True, addr, val));
+   } else {
+      /* SC */
+      IRType tyd = typeOfIRExpr(env->type_env, stmt->Ist.LLSC.storedata);
+      LOONGARCH64LLSCOp op;
+      switch (tyd) {
+         case Ity_I32:
+            op = LAllsc_SC_W;
+            break;
+         case Ity_I64:
+            op = LAllsc_SC_D;
+            break;
+         default:
+            vpanic("iselStmt(loongarch64): Ist_LLSC");
+            break;
+      }
+      LOONGARCH64AMode* addr = iselIntExpr_AMode(env, stmt->Ist.LLSC.addr, tya);
+      HReg               val = iselIntExpr_R(env, stmt->Ist.LLSC.storedata);
+      HReg               dst = lookupIRTemp(env, res);
+      HReg               tmp = newVRegI(env);
+      addInstr(env, LOONGARCH64Instr_Move(tmp, val));
+      addInstr(env, LOONGARCH64Instr_LLSC(op, False, addr, tmp));
+      addInstr(env, LOONGARCH64Instr_Move(dst, tmp));
+   }
+}
+
 static void iselStmtExit ( ISelEnv* env, IRStmt* stmt )
 {
    if (stmt->Ist.Exit.dst->tag != Ico_U64)
@@ -1051,6 +1103,11 @@ static void iselStmt(ISelEnv* env, IRStmt* stmt)
          iselStmtDirty(env, stmt);
          break;
 
+      /* --------- Load Linked and Store Conditional --------- */
+      case Ist_LLSC:
+         iselStmtLLSC(env, stmt);
+         break;
+
       /* --------- INSTR MARK --------- */
       /* Doesn't generate any executable code ... */
       case Ist_IMark:
-- 
2.39.1

