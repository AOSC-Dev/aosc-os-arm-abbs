From f135af5cafdcb573ee29252f54741bd16df452c7 Mon Sep 17 00:00:00 2001
From: Feiyang Chen <chenfeiyang@loongson.cn>
Date: Mon, 21 Mar 2022 15:37:11 +0800
Subject: [PATCH v4 034/123] loongarch64: Add support for emitting floating
 point compare instructions

---
 VEX/priv/host_loongarch64_defs.c | 88 ++++++++++++++++++++++++++++++++
 VEX/priv/host_loongarch64_defs.h | 12 ++++-
 2 files changed, 99 insertions(+), 1 deletion(-)

diff --git a/VEX/priv/host_loongarch64_defs.c b/VEX/priv/host_loongarch64_defs.c
index b8e71e173..63e8f8d77 100644
--- a/VEX/priv/host_loongarch64_defs.c
+++ b/VEX/priv/host_loongarch64_defs.c
@@ -738,6 +738,29 @@ static inline const HChar* showLOONGARCH64FpMoveOp ( LOONGARCH64FpMoveOp op )
    }
 }
 
+static inline const HChar* showLOONGARCH64FpCmpOp ( LOONGARCH64FpCmpOp op )
+{
+   const HChar* ret;
+   switch (op) {
+      case LAfpcmp_FCMP_CLT_S:
+         return "fcmp.clt.s";
+      case LAfpcmp_FCMP_CLT_D:
+         return "fcmp.clt.d";
+      case LAfpcmp_FCMP_CEQ_S:
+         return "fcmp.ceq.s";
+      case LAfpcmp_FCMP_CEQ_D:
+         return "fcmp.ceq.d";
+      case LAfpcmp_FCMP_CUN_S:
+         return "fcmp.cun.s";
+      case LAfpcmp_FCMP_CUN_D:
+         return "fcmp.cun.d";
+      default:
+         vpanic("showLOONGARCH64FpCmpOp");
+         break;
+   }
+   return ret;
+}
+
 LOONGARCH64Instr* LOONGARCH64Instr_LI ( ULong imm, HReg dst )
 {
    LOONGARCH64Instr* i = LibVEX_Alloc_inline(sizeof(LOONGARCH64Instr));
@@ -884,6 +907,18 @@ LOONGARCH64Instr* LOONGARCH64Instr_FpMove ( LOONGARCH64FpMoveOp op,
    return i;
 }
 
+LOONGARCH64Instr* LOONGARCH64Instr_FpCmp ( LOONGARCH64FpCmpOp op, HReg src2,
+                                           HReg src1, HReg dst )
+{
+   LOONGARCH64Instr* i   = LibVEX_Alloc_inline(sizeof(LOONGARCH64Instr));
+   i->tag                = LAin_FpCmp;
+   i->LAin.FpCmp.op      = op;
+   i->LAin.FpCmp.src2    = src2;
+   i->LAin.FpCmp.src1    = src1;
+   i->LAin.FpCmp.dst     = dst;
+   return i;
+}
+
 
 /* -------- Pretty Print instructions ------------- */
 
@@ -1003,6 +1038,19 @@ static inline void ppFpMove ( LOONGARCH64FpMoveOp op, HReg src, HReg dst )
    ppHRegLOONGARCH64(src);
 }
 
+static inline void ppFpCmp ( LOONGARCH64FpCmpOp op, HReg src2,
+                             HReg src1, HReg dst )
+{
+   vex_printf("%s ", showLOONGARCH64FpCmpOp(op));
+   vex_printf("$fcc0, ");
+   ppHRegLOONGARCH64(src1);
+   vex_printf(", ");
+   ppHRegLOONGARCH64(src2);
+   vex_printf("; movcf2gr ");
+   ppHRegLOONGARCH64(dst);
+   vex_printf(", $fcc0");
+}
+
 void ppLOONGARCH64Instr ( const LOONGARCH64Instr* i, Bool mode64 )
 {
    vassert(mode64 == True);
@@ -1053,6 +1101,10 @@ void ppLOONGARCH64Instr ( const LOONGARCH64Instr* i, Bool mode64 )
          ppFpMove(i->LAin.FpMove.op, i->LAin.FpMove.src,
                    i->LAin.FpMove.dst);
          break;
+      case LAin_FpCmp:
+         ppFpCmp(i->LAin.FpCmp.op, i->LAin.FpCmp.src2,
+                 i->LAin.FpCmp.src1, i->LAin.FpCmp.dst);
+         break;
       default:
          vpanic("ppLOONGARCH64Instr");
          break;
@@ -1125,6 +1177,11 @@ void getRegUsage_LOONGARCH64Instr ( HRegUsage* u, const LOONGARCH64Instr* i,
          addHRegUse(u, HRmRead, i->LAin.FpMove.src);
          addHRegUse(u, HRmWrite, i->LAin.FpMove.dst);
          break;
+      case LAin_FpCmp:
+         addHRegUse(u, HRmRead, i->LAin.FpCmp.src2);
+         addHRegUse(u, HRmRead, i->LAin.FpCmp.src1);
+         addHRegUse(u, HRmWrite, i->LAin.FpCmp.dst);
+         break;
       default:
          ppLOONGARCH64Instr(i, mode64);
          vpanic("getRegUsage_LOONGARCH64Instr");
@@ -1191,6 +1248,11 @@ void mapRegs_LOONGARCH64Instr ( HRegRemap* m, LOONGARCH64Instr* i,
          mapReg(m, &i->LAin.FpMove.src);
          mapReg(m, &i->LAin.FpMove.dst);
          break;
+      case LAin_FpCmp:
+         mapReg(m, &i->LAin.FpCmp.src2);
+         mapReg(m, &i->LAin.FpCmp.src1);
+         mapReg(m, &i->LAin.FpCmp.dst);
+         break;
       default:
          ppLOONGARCH64Instr(i, mode64);
          vpanic("mapRegs_LOONGARCH64Instr");
@@ -1804,6 +1866,28 @@ static inline UInt* mkFpMove ( UInt* p, LOONGARCH64FpMoveOp op, HReg src, HReg d
    }
 }
 
+static inline UInt* mkFpCmp ( UInt* p, LOONGARCH64FpCmpOp op, HReg src2,
+                              HReg src1, HReg dst )
+{
+   /*
+      fcmp.cond.[sd] $fcc0, src1, src2
+      movcf2gr       dst, $fcc0
+    */
+   switch (op) {
+      case LAfpcmp_FCMP_CLT_S:
+      case LAfpcmp_FCMP_CLT_D:
+      case LAfpcmp_FCMP_CEQ_S:
+      case LAfpcmp_FCMP_CEQ_D:
+      case LAfpcmp_FCMP_CUN_S:
+      case LAfpcmp_FCMP_CUN_D:
+         *p++ = emit_op_fk_fj_cd(op, fregEnc(src2), fregEnc(src1), 0);
+         *p++ = emit_op_cj_rd(LAextra_MOVCF2GR, 0, iregEnc(dst));
+         return p;
+      default:
+         return NULL;
+   }
+}
+
 /* Emit an instruction into buf and return the number of bytes used.
    Note that buf is not the insn's final place, and therefore it is
    imperative to emit position-independent code.  If the emitted
@@ -1877,6 +1961,10 @@ Int emit_LOONGARCH64Instr ( /*MB_MOD*/Bool* is_profInc,
          p = mkFpMove(p, i->LAin.FpMove.op, i->LAin.FpMove.src,
                       i->LAin.FpMove.dst);
          break;
+      case LAin_FpCmp:
+         p = mkFpCmp(p, i->LAin.FpCmp.op, i->LAin.FpCmp.src2,
+                     i->LAin.FpCmp.src1, i->LAin.FpCmp.dst);
+         break;
       default:
          p = NULL;
          break;
diff --git a/VEX/priv/host_loongarch64_defs.h b/VEX/priv/host_loongarch64_defs.h
index 821a5d59b..6766ebd10 100644
--- a/VEX/priv/host_loongarch64_defs.h
+++ b/VEX/priv/host_loongarch64_defs.h
@@ -391,7 +391,8 @@ typedef enum {
    LAin_FpTri,      /* floating point trinary */
    LAin_FpLoad,     /* floating point load */
    LAin_FpStore,    /* floating point store */
-   LAin_FpMove      /* floating point move */
+   LAin_FpMove,     /* floating point move */
+   LAin_FpCmp       /* floating point compare */
 } LOONGARCH64InstrTag;
 
 typedef struct {
@@ -465,6 +466,12 @@ typedef struct {
          HReg                 src;
          HReg                 dst;
       } FpMove;
+      struct {
+         LOONGARCH64FpCmpOp   op;
+         HReg                 src2;
+         HReg                 src1;
+         HReg                 dst;
+      } FpCmp;
    } LAin;
 } LOONGARCH64Instr;
 
@@ -502,6 +509,9 @@ extern LOONGARCH64Instr* LOONGARCH64Instr_FpStore   ( LOONGARCH64FpStoreOp op,
                                                       HReg src );
 extern LOONGARCH64Instr* LOONGARCH64Instr_FpMove    ( LOONGARCH64FpMoveOp op,
                                                       HReg src, HReg dst );
+extern LOONGARCH64Instr* LOONGARCH64Instr_FpCmp     ( LOONGARCH64FpCmpOp op,
+                                                      HReg src2, HReg src1,
+                                                      HReg dst );
 
 extern void ppLOONGARCH64Instr ( const LOONGARCH64Instr* i, Bool mode64 );
 
-- 
2.39.1

