From 23ee2cbb57839eaf5cbe910e3ea636df22bde68f Mon Sep 17 00:00:00 2001
From: Feiyang Chen <chenfeiyang@loongson.cn>
Date: Mon, 21 Mar 2022 15:18:00 +0800
Subject: [PATCH v4 033/123] loongarch64: Add support for emitting floating
 point move instructions

---
 VEX/priv/host_loongarch64_defs.c | 86 ++++++++++++++++++++++++++++++++
 VEX/priv/host_loongarch64_defs.h | 10 +++-
 2 files changed, 95 insertions(+), 1 deletion(-)

diff --git a/VEX/priv/host_loongarch64_defs.c b/VEX/priv/host_loongarch64_defs.c
index 5b8a8eb99..b8e71e173 100644
--- a/VEX/priv/host_loongarch64_defs.c
+++ b/VEX/priv/host_loongarch64_defs.c
@@ -713,6 +713,31 @@ static inline const HChar* showLOONGARCH64FpStoreOp ( LOONGARCH64FpStoreOp op )
    }
 }
 
+static inline const HChar* showLOONGARCH64FpMoveOp ( LOONGARCH64FpMoveOp op )
+{
+   switch (op) {
+      case LAfpmove_FMOV_S:
+         return "fmov.s";
+      case LAfpmove_FMOV_D:
+         return "fmov.d";
+      case LAfpmove_MOVGR2FR_W:
+         return "movgr2fr.w";
+      case LAfpmove_MOVGR2FR_D:
+         return "movgr2fr.d";
+      case LAfpmove_MOVFR2GR_S:
+         return "movfr2gr.s";
+      case LAfpmove_MOVFR2GR_D:
+         return "movfr2gr.d";
+      case LAfpmove_MOVGR2FCSR:
+         return "movgr2fcsr";
+      case LAfpmove_MOVFCSR2GR:
+         return "movfcsr2gr";
+      default:
+         vpanic("showLOONGARCH64FpMoveOp");
+         break;
+   }
+}
+
 LOONGARCH64Instr* LOONGARCH64Instr_LI ( ULong imm, HReg dst )
 {
    LOONGARCH64Instr* i = LibVEX_Alloc_inline(sizeof(LOONGARCH64Instr));
@@ -848,6 +873,17 @@ LOONGARCH64Instr* LOONGARCH64Instr_FpStore ( LOONGARCH64FpStoreOp op,
    return i;
 }
 
+LOONGARCH64Instr* LOONGARCH64Instr_FpMove ( LOONGARCH64FpMoveOp op,
+                                            HReg src, HReg dst )
+{
+   LOONGARCH64Instr* i = LibVEX_Alloc_inline(sizeof(LOONGARCH64Instr));
+   i->tag              = LAin_FpMove;
+   i->LAin.FpMove.op   = op;
+   i->LAin.FpMove.src  = src;
+   i->LAin.FpMove.dst  = dst;
+   return i;
+}
+
 
 /* -------- Pretty Print instructions ------------- */
 
@@ -959,6 +995,14 @@ static inline void ppFpStore ( LOONGARCH64FpStoreOp op, LOONGARCH64AMode* dst,
    ppLOONGARCH64AMode(dst);
 }
 
+static inline void ppFpMove ( LOONGARCH64FpMoveOp op, HReg src, HReg dst )
+{
+   vex_printf("%s ", showLOONGARCH64FpMoveOp(op));
+   ppHRegLOONGARCH64(dst);
+   vex_printf(", ");
+   ppHRegLOONGARCH64(src);
+}
+
 void ppLOONGARCH64Instr ( const LOONGARCH64Instr* i, Bool mode64 )
 {
    vassert(mode64 == True);
@@ -1005,6 +1049,10 @@ void ppLOONGARCH64Instr ( const LOONGARCH64Instr* i, Bool mode64 )
          ppFpStore(i->LAin.FpStore.op, i->LAin.FpStore.dst,
                    i->LAin.FpStore.src);
          break;
+      case LAin_FpMove:
+         ppFpMove(i->LAin.FpMove.op, i->LAin.FpMove.src,
+                   i->LAin.FpMove.dst);
+         break;
       default:
          vpanic("ppLOONGARCH64Instr");
          break;
@@ -1073,6 +1121,10 @@ void getRegUsage_LOONGARCH64Instr ( HRegUsage* u, const LOONGARCH64Instr* i,
          addRegUsage_LOONGARCH64AMode(u, i->LAin.FpStore.dst);
          addHRegUse(u, HRmRead, i->LAin.FpStore.src);
          break;
+      case LAin_FpMove:
+         addHRegUse(u, HRmRead, i->LAin.FpMove.src);
+         addHRegUse(u, HRmWrite, i->LAin.FpMove.dst);
+         break;
       default:
          ppLOONGARCH64Instr(i, mode64);
          vpanic("getRegUsage_LOONGARCH64Instr");
@@ -1135,6 +1187,10 @@ void mapRegs_LOONGARCH64Instr ( HRegRemap* m, LOONGARCH64Instr* i,
          mapRegs_LOONGARCH64AMode(m, i->LAin.FpStore.dst);
          mapReg(m, &i->LAin.FpStore.src);
          break;
+      case LAin_FpMove:
+         mapReg(m, &i->LAin.FpMove.src);
+         mapReg(m, &i->LAin.FpMove.dst);
+         break;
       default:
          ppLOONGARCH64Instr(i, mode64);
          vpanic("mapRegs_LOONGARCH64Instr");
@@ -1722,6 +1778,32 @@ static inline UInt* mkFpStore ( UInt* p, LOONGARCH64FpStoreOp op,
    }
 }
 
+static inline UInt* mkFpMove ( UInt* p, LOONGARCH64FpMoveOp op, HReg src, HReg dst )
+{
+   switch (op) {
+      case LAfpmove_FMOV_S:
+      case LAfpmove_FMOV_D:
+         *p++ = emit_op_fj_fd(op, fregEnc(src), fregEnc(dst));
+         return p;
+      case LAfpmove_MOVGR2FR_W:
+      case LAfpmove_MOVGR2FR_D:
+         *p++ = emit_op_rj_fd(op, iregEnc(src), fregEnc(dst));
+         return p;
+      case LAfpmove_MOVFR2GR_S:
+      case LAfpmove_MOVFR2GR_D:
+         *p++ = emit_op_fj_rd(op, fregEnc(src), iregEnc(dst));
+         return p;
+      case LAfpmove_MOVGR2FCSR:
+         *p++ = emit_op_rj_fcsr(op, iregEnc(src), fcsrEnc(dst));
+         return p;
+      case LAfpmove_MOVFCSR2GR:
+         *p++ = emit_op_fcsr_rd(op, fcsrEnc(src), iregEnc(dst));
+         return p;
+      default:
+         return NULL;
+   }
+}
+
 /* Emit an instruction into buf and return the number of bytes used.
    Note that buf is not the insn's final place, and therefore it is
    imperative to emit position-independent code.  If the emitted
@@ -1791,6 +1873,10 @@ Int emit_LOONGARCH64Instr ( /*MB_MOD*/Bool* is_profInc,
          p = mkFpStore(p, i->LAin.FpStore.op, i->LAin.FpStore.dst,
                        i->LAin.FpStore.src);
          break;
+      case LAin_FpMove:
+         p = mkFpMove(p, i->LAin.FpMove.op, i->LAin.FpMove.src,
+                      i->LAin.FpMove.dst);
+         break;
       default:
          p = NULL;
          break;
diff --git a/VEX/priv/host_loongarch64_defs.h b/VEX/priv/host_loongarch64_defs.h
index 1029bb827..821a5d59b 100644
--- a/VEX/priv/host_loongarch64_defs.h
+++ b/VEX/priv/host_loongarch64_defs.h
@@ -390,7 +390,8 @@ typedef enum {
    LAin_FpBin,      /* floating point binary */
    LAin_FpTri,      /* floating point trinary */
    LAin_FpLoad,     /* floating point load */
-   LAin_FpStore     /* floating point store */
+   LAin_FpStore,    /* floating point store */
+   LAin_FpMove      /* floating point move */
 } LOONGARCH64InstrTag;
 
 typedef struct {
@@ -459,6 +460,11 @@ typedef struct {
          LOONGARCH64AMode*    dst;
          HReg                 src;
       } FpStore;
+      struct {
+         LOONGARCH64FpMoveOp  op;
+         HReg                 src;
+         HReg                 dst;
+      } FpMove;
    } LAin;
 } LOONGARCH64Instr;
 
@@ -494,6 +500,8 @@ extern LOONGARCH64Instr* LOONGARCH64Instr_FpLoad    ( LOONGARCH64FpLoadOp op,
 extern LOONGARCH64Instr* LOONGARCH64Instr_FpStore   ( LOONGARCH64FpStoreOp op,
                                                       LOONGARCH64AMode* dst,
                                                       HReg src );
+extern LOONGARCH64Instr* LOONGARCH64Instr_FpMove    ( LOONGARCH64FpMoveOp op,
+                                                      HReg src, HReg dst );
 
 extern void ppLOONGARCH64Instr ( const LOONGARCH64Instr* i, Bool mode64 );
 
-- 
2.39.1

