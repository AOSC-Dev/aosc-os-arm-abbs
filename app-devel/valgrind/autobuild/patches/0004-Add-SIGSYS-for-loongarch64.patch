From 83fdd056ac2c92f29ef381ce82d5d6fd6ba974f8 Mon Sep 17 00:00:00 2001
From: Feiyang Chen <chenfeiyang@loongson.cn>
Date: Fri, 15 Jul 2022 10:37:48 +0800
Subject: [PATCH v4 004/123] Add SIGSYS for loongarch64

---
 VEX/priv/ir_defs.c                |  1 +
 VEX/pub/libvex_ir.h               |  1 +
 VEX/pub/libvex_trc_values.h       |  1 +
 coregrind/m_scheduler/scheduler.c |  5 +++++
 coregrind/m_signals.c             | 24 ++++++++++++++++++++++++
 coregrind/pub_core_signals.h      |  1 +
 include/vki/vki-linux.h           |  1 +
 7 files changed, 34 insertions(+)

diff --git a/VEX/priv/ir_defs.c b/VEX/priv/ir_defs.c
index c86e7a3eb..382c283f2 100644
--- a/VEX/priv/ir_defs.c
+++ b/VEX/priv/ir_defs.c
@@ -2091,6 +2091,7 @@ void ppIRJumpKind ( IRJumpKind kind )
       case Ijk_SigFPE:        vex_printf("SigFPE"); break;
       case Ijk_SigFPE_IntDiv: vex_printf("SigFPE_IntDiv"); break;
       case Ijk_SigFPE_IntOvf: vex_printf("SigFPE_IntOvf"); break;
+      case Ijk_SigSYS:        vex_printf("SigSYS"); break;
       case Ijk_Sys_syscall:   vex_printf("Sys_syscall"); break;
       case Ijk_Sys_int32:     vex_printf("Sys_int32"); break;
       case Ijk_Sys_int128:    vex_printf("Sys_int128"); break;
diff --git a/VEX/pub/libvex_ir.h b/VEX/pub/libvex_ir.h
index 53ad6813a..afe8dfd29 100644
--- a/VEX/pub/libvex_ir.h
+++ b/VEX/pub/libvex_ir.h
@@ -2507,6 +2507,7 @@ typedef
       Ijk_SigFPE,         /* current instruction synths generic SIGFPE */
       Ijk_SigFPE_IntDiv,  /* current instruction synths SIGFPE - IntDiv */
       Ijk_SigFPE_IntOvf,  /* current instruction synths SIGFPE - IntOvf */
+      Ijk_SigSYS,         /* current instruction synths SIGSYS */
       /* Unfortunately, various guest-dependent syscall kinds.  They
 	 all mean: do a syscall before continuing. */
       Ijk_Sys_syscall,    /* amd64/x86 'syscall', ppc 'sc', arm 'svc #0' */
diff --git a/VEX/pub/libvex_trc_values.h b/VEX/pub/libvex_trc_values.h
index cfd54ded3..90e2b60af 100644
--- a/VEX/pub/libvex_trc_values.h
+++ b/VEX/pub/libvex_trc_values.h
@@ -57,6 +57,7 @@
                                       continuing */
 #define VEX_TRC_JMP_SIGBUS     93  /* deliver SIGBUS before continuing */
 #define VEX_TRC_JMP_SIGFPE    105  /* deliver SIGFPE before continuing */
+#define VEX_TRC_JMP_SIGSYS    115  /* deliver SIGSYS before continuing */
 
 #define VEX_TRC_JMP_SIGFPE_INTDIV     97  /* deliver SIGFPE (integer divide
                                              by zero) before continuing */
diff --git a/coregrind/m_scheduler/scheduler.c b/coregrind/m_scheduler/scheduler.c
index 788018c3e..a61320b21 100644
--- a/coregrind/m_scheduler/scheduler.c
+++ b/coregrind/m_scheduler/scheduler.c
@@ -271,6 +271,7 @@ const HChar* name_of_sched_event ( UInt event )
       case VEX_TRC_JMP_SIGBUS:         return "SIGBUS";
       case VEX_TRC_JMP_SIGFPE_INTOVF:
       case VEX_TRC_JMP_SIGFPE_INTDIV:  return "SIGFPE";
+      case VEX_TRC_JMP_SIGSYS:         return "SIGSYS";
       case VEX_TRC_JMP_EMWARN:         return "EMWARN";
       case VEX_TRC_JMP_EMFAIL:         return "EMFAIL";
       case VEX_TRC_JMP_CLIENTREQ:      return "CLIENTREQ";
@@ -1657,6 +1658,10 @@ VgSchedReturnCode VG_(scheduler) ( ThreadId tid )
          VG_(synth_sigfpe)(tid, VKI_FPE_INTOVF);
          break;
 
+      case VEX_TRC_JMP_SIGSYS:
+         VG_(synth_sigsys)(tid);
+         break;
+
       case VEX_TRC_JMP_NODECODE: {
          Addr addr = VG_(get_IP)(tid);
 
diff --git a/coregrind/m_signals.c b/coregrind/m_signals.c
index b3c94fcc9..8162a101f 100644
--- a/coregrind/m_signals.c
+++ b/coregrind/m_signals.c
@@ -2319,6 +2319,30 @@ void VG_(synth_sigfpe)(ThreadId tid, UInt code)
 #endif
 }
 
+// Synthesise a SIGSYS.
+void VG_(synth_sigsys)(ThreadId tid)
+{
+// Only tested on loongarch64-linux.
+#if !defined(VGP_loongarch64_linux)
+   vg_assert(0);
+#else
+   vki_siginfo_t info;
+
+   vg_assert(VG_(threads)[tid].status == VgTs_Runnable);
+
+   VG_(memset)(&info, 0, sizeof(info));
+   info.si_signo = VKI_SIGSYS;
+   info.si_code  = VKI_SI_KERNEL;
+
+   if (VG_(gdbserver_report_signal) (&info, tid)) {
+      resume_scheduler(tid);
+      deliver_signal(tid, &info, NULL);
+   }
+   else
+      resume_scheduler(tid);
+#endif
+}
+
 /* Make a signal pending for a thread, for later delivery.
    VG_(poll_signals) will arrange for it to be delivered at the right
    time. 
diff --git a/coregrind/pub_core_signals.h b/coregrind/pub_core_signals.h
index ae8555ba8..c53323fbe 100644
--- a/coregrind/pub_core_signals.h
+++ b/coregrind/pub_core_signals.h
@@ -77,6 +77,7 @@ extern void VG_(synth_sigill)       (ThreadId tid, Addr addr);
 extern void VG_(synth_sigtrap)      (ThreadId tid);
 extern void VG_(synth_sigbus)       (ThreadId tid);
 extern void VG_(synth_sigfpe)       (ThreadId tid, UInt code);
+extern void VG_(synth_sigsys)       (ThreadId tid);
 
 /* Extend the stack to cover addr, if possible */
 extern Bool VG_(extend_stack)(ThreadId tid, Addr addr);
diff --git a/include/vki/vki-linux.h b/include/vki/vki-linux.h
index c96383701..6de21d1b7 100644
--- a/include/vki/vki-linux.h
+++ b/include/vki/vki-linux.h
@@ -531,6 +531,7 @@ typedef struct vki_siginfo {
  * Digital reserves positive values for kernel-generated signals.
  */
 #define VKI_SI_USER	0		/* sent by kill, sigsend, raise */
+#define VKI_SI_KERNEL	0x80		/* sent by the kernel from somewhere */
 #define VKI_SI_TKILL	-6		/* sent by tkill system call */
 
 /*
-- 
2.39.1

