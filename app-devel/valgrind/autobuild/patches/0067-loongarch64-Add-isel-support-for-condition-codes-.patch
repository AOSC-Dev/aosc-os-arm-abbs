From 1a4c2a83d494620c6a50ac999333841346453474 Mon Sep 17 00:00:00 2001
From: Feiyang Chen <chenfeiyang@loongson.cn>
Date: Mon, 8 Aug 2022 17:01:59 +0800
Subject: [PATCH v4 067/123] loongarch64: Add isel support for condition codes
 expressions

---
 VEX/priv/host_loongarch64_isel.c | 147 +++++++++++++++++++++++++++++++
 1 file changed, 147 insertions(+)

diff --git a/VEX/priv/host_loongarch64_isel.c b/VEX/priv/host_loongarch64_isel.c
index 128a01cfb..5bc17f0eb 100644
--- a/VEX/priv/host_loongarch64_isel.c
+++ b/VEX/priv/host_loongarch64_isel.c
@@ -1439,6 +1439,153 @@ static HReg iselCondCode_R ( ISelEnv* env, IRExpr* e )
 /* DO NOT CALL THIS DIRECTLY ! */
 static HReg iselCondCode_R_wrk ( ISelEnv* env, IRExpr* e )
 {
+   vassert(e);
+   vassert(typeOfIRExpr(env->type_env, e) == Ity_I1);
+
+   HReg dst = newVRegI(env);
+
+   /* var */
+   if (e->tag == Iex_RdTmp) {
+      HReg tmp = newVRegI(env);
+      dst = lookupIRTemp(env, e->Iex.RdTmp.tmp);
+      addInstr(env, LOONGARCH64Instr_LI(1, tmp));
+      addInstr(env, LOONGARCH64Instr_Cmp(LAcc_EQ, dst, tmp, dst));
+      return dst;
+   }
+
+   /* const */
+   if (e->tag == Iex_Const && e->Iex.Const.con->tag == Ico_U1) {
+      UInt imm = e->Iex.Const.con->Ico.U1;
+      addInstr(env, LOONGARCH64Instr_LI(imm, dst));
+      return dst;
+   }
+
+   if (e->tag == Iex_Unop) {
+      if (e->Iex.Unop.op == Iop_Not1) {
+         HReg          src = iselCondCode_R(env, e->Iex.Unop.arg);
+         LOONGARCH64RI* ri = LOONGARCH64RI_R(hregZERO());
+         addInstr(env, LOONGARCH64Instr_Binary(LAbin_NOR, ri, src, dst));
+         return dst;
+      }
+
+      LOONGARCH64CondCode cc;
+      switch (e->Iex.Unop.op) {
+         case Iop_CmpNEZ16:
+            cc = LAcc_NE;
+            break;
+         case Iop_CmpNEZ32:
+            cc = LAcc_NE;
+            break;
+         case Iop_CmpNEZ64:
+            cc = LAcc_NE;
+            break;
+         case Iop_CmpNEZ8:
+            cc = LAcc_NE;
+            break;
+         default:
+            goto irreducible;
+      }
+      HReg src = iselIntExpr_R(env, e->Iex.Unop.arg);
+      addInstr(env, LOONGARCH64Instr_Cmp(cc, hregZERO(), src, dst));
+      return dst;
+   }
+
+   if (e->tag == Iex_Binop) {
+      if (e->Iex.Binop.op == Iop_And1) {
+         HReg           src1 = iselCondCode_R(env, e->Iex.Binop.arg1);
+         HReg           src2 = iselCondCode_R(env, e->Iex.Binop.arg2);
+         LOONGARCH64RI*   ri = LOONGARCH64RI_R(src2);
+         addInstr(env, LOONGARCH64Instr_Binary(LAbin_AND, ri, src1, dst));
+         return dst;
+      } else if (e->Iex.Binop.op == Iop_Or1) {
+         HReg           src1 = iselCondCode_R(env, e->Iex.Binop.arg1);
+         HReg           src2 = iselCondCode_R(env, e->Iex.Binop.arg2);
+         LOONGARCH64RI*   ri = LOONGARCH64RI_R(src2);
+         addInstr(env, LOONGARCH64Instr_Binary(LAbin_OR, ri, src1, dst));
+         return dst;
+      }
+
+      Bool extend  = False;
+      Bool reverse = False;
+      LOONGARCH64CondCode cc;
+      switch (e->Iex.Binop.op) {
+         case Iop_CasCmpEQ32:
+            cc = LAcc_EQ;
+            break;
+         case Iop_CasCmpEQ64:
+            cc = LAcc_EQ;
+            break;
+         case Iop_CasCmpNE32:
+            cc = LAcc_NE;
+            break;
+         case Iop_CasCmpNE64:
+            cc = LAcc_NE;
+            break;
+         case Iop_CmpEQ32:
+            cc = LAcc_EQ;
+            break;
+         case Iop_CmpEQ64:
+            cc = LAcc_EQ;
+            break;
+         case Iop_CmpLE32S:
+            cc = LAcc_GE;
+            reverse = True;
+            break;
+         case Iop_CmpLE32U:
+            cc = LAcc_GEU;
+            reverse = True;
+            break;
+         case Iop_CmpLE64S:
+            cc = LAcc_GE;
+            reverse = True;
+            break;
+         case Iop_CmpLE64U:
+            cc = LAcc_GEU;
+            reverse = True;
+            break;
+         case Iop_CmpLT32S:
+            cc = LAcc_LT;
+            extend = True;
+            break;
+         case Iop_CmpLT32U:
+            cc = LAcc_LTU;
+            extend = True;
+            break;
+         case Iop_CmpLT64S:
+            cc = LAcc_LT;
+            break;
+         case Iop_CmpLT64U:
+            cc = LAcc_LTU;
+            break;
+         case Iop_CmpNE32:
+            cc = LAcc_NE;
+            break;
+         case Iop_CmpNE64:
+            cc = LAcc_NE;
+            break;
+         default:
+            goto irreducible;
+      }
+      HReg src1 = iselIntExpr_R(env, e->Iex.Binop.arg1);
+      HReg src2 = iselIntExpr_R(env, e->Iex.Binop.arg2);
+      if (extend) {
+         /* Sign-extend */
+         LOONGARCH64RI* ri = LOONGARCH64RI_I(0, 5, False);
+         addInstr(env, LOONGARCH64Instr_Binary(LAbin_SLLI_W, ri, src1, src1));
+         addInstr(env, LOONGARCH64Instr_Binary(LAbin_SLLI_W, ri, src2, src2));
+      }
+      if (reverse) {
+         addInstr(env, LOONGARCH64Instr_Cmp(cc, src1, src2, dst));
+      } else {
+         addInstr(env, LOONGARCH64Instr_Cmp(cc, src2, src1, dst));
+      }
+      return dst;
+   }
+
+   /* We get here if no pattern matched. */
+irreducible:
+   ppIRExpr(e);
+   vpanic("iselCondCode(loongarch64): cannot reduce tree");
 }
 
 
-- 
2.39.1

