From bfa9685e1589d3b34817ea06696c91487ffa688f Mon Sep 17 00:00:00 2001
From: Feiyang Chen <chenfeiyang@loongson.cn>
Date: Mon, 8 Aug 2022 10:00:27 +0800
Subject: [PATCH v4 013/123] loongarch64: Add support to decode fixed point
 extra insns

---
 VEX/priv/guest_loongarch64_defs.h    |   3 +
 VEX/priv/guest_loongarch64_helpers.c |  94 ++++++++++++
 VEX/priv/guest_loongarch64_toIR.c    | 222 +++++++++++++++++++++++++--
 3 files changed, 303 insertions(+), 16 deletions(-)

diff --git a/VEX/priv/guest_loongarch64_defs.h b/VEX/priv/guest_loongarch64_defs.h
index 8abe6b319..f54228718 100644
--- a/VEX/priv/guest_loongarch64_defs.h
+++ b/VEX/priv/guest_loongarch64_defs.h
@@ -70,6 +70,7 @@ extern VexGuestLayout loongarch64Guest_layout;
 /*--- loongarch64 guest helpers                         ---*/
 /*---------------------------------------------------------*/
 
+extern ULong loongarch64_calculate_cpucfg    ( ULong src );
 extern ULong loongarch64_calculate_revb_2h   ( ULong src );
 extern ULong loongarch64_calculate_revb_4h   ( ULong src );
 extern ULong loongarch64_calculate_revb_2w   ( ULong src );
@@ -80,6 +81,8 @@ extern ULong loongarch64_calculate_bitrev_4b ( ULong src );
 extern ULong loongarch64_calculate_bitrev_8b ( ULong src );
 extern ULong loongarch64_calculate_bitrev_w  ( ULong src );
 extern ULong loongarch64_calculate_bitrev_d  ( ULong src );
+extern ULong loongarch64_calculate_crc       ( ULong old, ULong msg, ULong len );
+extern ULong loongarch64_calculate_crcc      ( ULong old, ULong msg, ULong len );
 
 #endif /* ndef __VEX_GUEST_LOONGARCH64_DEFS_H */
 
diff --git a/VEX/priv/guest_loongarch64_helpers.c b/VEX/priv/guest_loongarch64_helpers.c
index 5590fed2c..eb30e9606 100644
--- a/VEX/priv/guest_loongarch64_helpers.c
+++ b/VEX/priv/guest_loongarch64_helpers.c
@@ -236,6 +236,68 @@ VexGuestLayout loongarch64Guest_layout = {
 /*--- loongarch64 guest helpers                           ---*/
 /*-----------------------------------------------------------*/
 
+/* Claim to be the following CPU, which is probably representative of
+   the earliest loongarch64 offerings.
+
+   CPU Family          : Loongson-64bit
+   Model Name          : Loongson-3A5000LL
+   CPU Revision        : 0x10
+   FPU Revision        : 0x00
+   CPU MHz             : 2300.00
+   BogoMIPS            : 4600.00
+   TLB Entries         : 2112
+   Address Sizes       : 48 bits physical, 48 bits virtual
+   ISA                 : loongarch32 loongarch64
+   Features            : cpucfg lam ual fpu lsx lasx complex crypto lvz
+   Hardware Watchpoint : yes, iwatch count: 8, dwatch count: 8
+*/
+ULong loongarch64_calculate_cpucfg ( ULong src )
+{
+   ULong res;
+   switch (src) {
+      case 0x0:
+         res = 0x0014c010;
+         break;
+      case 0x1:
+         res = 0x03f2f2fe;
+         break;
+      case 0x2:
+         res = 0x007ccfc7;
+         break;
+      case 0x3:
+         res = 0x0000fcff;
+         break;
+      case 0x4:
+         res = 0x05f5e100;
+         break;
+      case 0x5:
+         res = 0x00010001;
+         break;
+      case 0x6:
+         res = 0x00007f33;
+         break;
+      case 0x10:
+         res = 0x00002c3d;
+         break;
+      case 0x11:
+         res = 0x06080003;
+         break;
+      case 0x12:
+         res = 0x06080003;
+         break;
+      case 0x13:
+         res = 0x0608000f;
+         break;
+      case 0x14:
+         res = 0x060e000f;
+         break;
+      default:
+         res = 0x00000000;
+         break;
+   }
+   return (ULong)(Long)(Int)res;
+}
+
 static void swap_UChar ( UChar* a, UChar* b )
 {
    UChar t = *a;
@@ -346,6 +408,38 @@ ULong loongarch64_calculate_bitrev_d ( ULong src )
    return bitrev(src, 0, 64);
 }
 
+static ULong crc32 ( ULong old, ULong msg, ULong width, ULong poly )
+{
+   int i;
+   ULong new;
+   if (width == 8)
+      msg &= 0xff;
+   else if (width == 16)
+      msg &= 0xffff;
+   else if (width == 32)
+      msg &= 0xffffffff;
+   new = (old & 0xffffffff) ^ msg;
+   for (i = 0; i < width; i++) {
+      if (new & 1)
+         new = (new >> 1) ^ poly;
+      else
+         new >>= 1;
+   }
+   return new;
+}
+
+ULong loongarch64_calculate_crc ( ULong old, ULong msg, ULong len )
+{
+   ULong res = crc32(old, msg, len, 0xedb88320);
+   return (ULong)(Long)(Int)res;
+}
+
+ULong loongarch64_calculate_crcc ( ULong old, ULong msg, ULong len )
+{
+   ULong res = crc32(old, msg, len, 0x82f63b78);
+   return (ULong)(Long)(Int)res;
+}
+
 
 /*---------------------------------------------------------------*/
 /*--- end                         guest_loongarch64_helpers.c ---*/
diff --git a/VEX/priv/guest_loongarch64_toIR.c b/VEX/priv/guest_loongarch64_toIR.c
index 098b80bc0..d4d7fc155 100644
--- a/VEX/priv/guest_loongarch64_toIR.c
+++ b/VEX/priv/guest_loongarch64_toIR.c
@@ -3986,112 +3986,302 @@ static Bool gen_crc_w_b_w ( DisResult* dres, UInt insn,
                             const VexArchInfo* archinfo,
                             const VexAbiInfo* abiinfo )
 {
-   return False;
+   UInt rk = get_rk(insn);
+   UInt rj = get_rj(insn);
+   UInt rd = get_rd(insn);
+
+   DIP("crc.w.b.w %s, %s, %s\n", nameIReg(rd), nameIReg(rj), nameIReg(rk));
+
+   IRExpr** arg = mkIRExprVec_3(getIReg64(rk), getIReg64(rj), mkU64(8));
+   IRExpr* call = mkIRExprCCall(Ity_I64, 0/*regparms*/,
+                                "loongarch64_calculate_crc",
+                                &loongarch64_calculate_crc,
+                                arg);
+   putIReg(rd, call);
+
+   return True;
 }
 
 static Bool gen_crc_w_h_w ( DisResult* dres, UInt insn,
                             const VexArchInfo* archinfo,
                             const VexAbiInfo* abiinfo )
 {
-   return False;
+   UInt rk = get_rk(insn);
+   UInt rj = get_rj(insn);
+   UInt rd = get_rd(insn);
+
+   DIP("crc.w.h.w %s, %s, %s\n", nameIReg(rd), nameIReg(rj), nameIReg(rk));
+
+   IRExpr** arg = mkIRExprVec_3(getIReg64(rk), getIReg64(rj), mkU64(16));
+   IRExpr* call = mkIRExprCCall(Ity_I64, 0/*regparms*/,
+                                "loongarch64_calculate_crc",
+                                &loongarch64_calculate_crc,
+                                arg);
+   putIReg(rd, call);
+
+   return True;
 }
 
 static Bool gen_crc_w_w_w ( DisResult* dres, UInt insn,
                             const VexArchInfo* archinfo,
                             const VexAbiInfo* abiinfo )
 {
-   return False;
+   UInt rk = get_rk(insn);
+   UInt rj = get_rj(insn);
+   UInt rd = get_rd(insn);
+
+   DIP("crc.w.w.w %s, %s, %s\n", nameIReg(rd), nameIReg(rj), nameIReg(rk));
+
+   IRExpr** arg = mkIRExprVec_3(getIReg64(rk), getIReg64(rj), mkU64(32));
+   IRExpr* call = mkIRExprCCall(Ity_I64, 0/*regparms*/,
+                                "loongarch64_calculate_crc",
+                                &loongarch64_calculate_crc,
+                                arg);
+   putIReg(rd, call);
+
+   return True;
 }
 
 static Bool gen_crc_w_d_w ( DisResult* dres, UInt insn,
                             const VexArchInfo* archinfo,
                             const VexAbiInfo* abiinfo )
 {
-   return False;
+   UInt rk = get_rk(insn);
+   UInt rj = get_rj(insn);
+   UInt rd = get_rd(insn);
+
+   DIP("crc.w.d.w %s, %s, %s\n", nameIReg(rd), nameIReg(rj), nameIReg(rk));
+
+   IRExpr** arg = mkIRExprVec_3(getIReg64(rk), getIReg64(rj), mkU64(64));
+   IRExpr* call = mkIRExprCCall(Ity_I64, 0/*regparms*/,
+                                "loongarch64_calculate_crc",
+                                &loongarch64_calculate_crc,
+                                arg);
+   putIReg(rd, call);
+
+   return True;
 }
 
 static Bool gen_crcc_w_b_w ( DisResult* dres, UInt insn,
                              const VexArchInfo* archinfo,
                              const VexAbiInfo* abiinfo )
 {
-   return False;
+   UInt rk = get_rk(insn);
+   UInt rj = get_rj(insn);
+   UInt rd = get_rd(insn);
+
+   DIP("crcc.w.b.w %s, %s, %s\n", nameIReg(rd), nameIReg(rj), nameIReg(rk));
+
+   IRExpr** arg = mkIRExprVec_3(getIReg64(rk), getIReg64(rj), mkU64(8));
+   IRExpr* call = mkIRExprCCall(Ity_I64, 0/*regparms*/,
+                                "loongarch64_calculate_crcc",
+                                &loongarch64_calculate_crcc,
+                                arg);
+   putIReg(rd, call);
+
+   return True;
 }
 
 static Bool gen_crcc_w_h_w ( DisResult* dres, UInt insn,
                              const VexArchInfo* archinfo,
                              const VexAbiInfo* abiinfo )
 {
-   return False;
+   UInt rk = get_rk(insn);
+   UInt rj = get_rj(insn);
+   UInt rd = get_rd(insn);
+
+   DIP("crcc.w.h.w %s, %s, %s\n", nameIReg(rd), nameIReg(rj), nameIReg(rk));
+
+   IRExpr** arg = mkIRExprVec_3(getIReg64(rk), getIReg64(rj), mkU64(16));
+   IRExpr* call = mkIRExprCCall(Ity_I64, 0/*regparms*/,
+                                "loongarch64_calculate_crcc",
+                                &loongarch64_calculate_crcc,
+                                arg);
+   putIReg(rd, call);
+
+   return True;
 }
 
 static Bool gen_crcc_w_w_w ( DisResult* dres, UInt insn,
                              const VexArchInfo* archinfo,
                              const VexAbiInfo* abiinfo )
 {
-   return False;
+   UInt rk = get_rk(insn);
+   UInt rj = get_rj(insn);
+   UInt rd = get_rd(insn);
+
+   DIP("crcc.w.w.w %s, %s, %s\n", nameIReg(rd), nameIReg(rj), nameIReg(rk));
+
+   IRExpr** arg = mkIRExprVec_3(getIReg64(rk), getIReg64(rj), mkU64(32));
+   IRExpr* call = mkIRExprCCall(Ity_I64, 0/*regparms*/,
+                                "loongarch64_calculate_crcc",
+                                &loongarch64_calculate_crcc,
+                                arg);
+   putIReg(rd, call);
+
+   return True;
 }
 
 static Bool gen_crcc_w_d_w ( DisResult* dres, UInt insn,
                              const VexArchInfo* archinfo,
                              const VexAbiInfo* abiinfo )
 {
-   return False;
+   UInt rk = get_rk(insn);
+   UInt rj = get_rj(insn);
+   UInt rd = get_rd(insn);
+
+   DIP("crcc.w.d.w %s, %s, %s\n", nameIReg(rd), nameIReg(rj), nameIReg(rk));
+
+   IRExpr** arg = mkIRExprVec_3(getIReg64(rk), getIReg64(rj), mkU64(64));
+   IRExpr* call = mkIRExprCCall(Ity_I64, 0/*regparms*/,
+                                "loongarch64_calculate_crcc",
+                                &loongarch64_calculate_crcc,
+                                arg);
+   putIReg(rd, call);
+
+   return True;
 }
 
 static Bool gen_break ( DisResult* dres, UInt insn,
                         const VexArchInfo* archinfo,
                         const VexAbiInfo* abiinfo )
 {
-   return False;
+   UInt code = get_code(insn);
+
+   DIP("break %u\n", code);
+
+   putPC(mkU64(guest_PC_curr_instr + 4));
+
+   /* On LoongArch, most instructions do not raise exceptions;
+      instead, gcc notifies the kernel with a trap instruction.
+      We simulate the behavior of the linux kernel here.
+      See arch/loongarch/kernel/traps.c.
+    */
+   switch (code) {
+      case 6: /* BRK_OVERFLOW */
+         dres->jk_StopHere = Ijk_SigFPE_IntOvf;
+         break;
+      case 7: /* BRK_DIVZERO */
+         dres->jk_StopHere = Ijk_SigFPE_IntDiv;
+         break;
+      default:
+         dres->jk_StopHere = Ijk_SigTRAP;
+         break;
+   }
+   dres->whatNext    = Dis_StopHere;
+
+   return True;
 }
 
 static Bool gen_syscall ( DisResult* dres, UInt insn,
                           const VexArchInfo* archinfo,
                           const VexAbiInfo* abiinfo )
 {
-   return False;
+   UInt hint = get_hint15(insn);
+
+   DIP("syscall %u\n", hint);
+
+   putPC(mkU64(guest_PC_curr_instr + 4));
+
+   dres->jk_StopHere = Ijk_Sys_syscall;
+   dres->whatNext    = Dis_StopHere;
+
+   return True;
 }
 
 static Bool gen_asrtle_d ( DisResult* dres, UInt insn,
                            const VexArchInfo* archinfo,
                            const VexAbiInfo* abiinfo )
 {
-   return False;
+   UInt rk = get_rk(insn);
+   UInt rj = get_rj(insn);
+
+   DIP("asrtle.d %s, %s\n", nameIReg(rj), nameIReg(rk));
+
+   gen_SIGSYS(binop(Iop_CmpLT64U, getIReg64(rk), getIReg64(rj)));
+
+   return True;
 }
 
 static Bool gen_asrtgt_d ( DisResult* dres, UInt insn,
                            const VexArchInfo* archinfo,
                            const VexAbiInfo* abiinfo )
 {
-   return False;
+   UInt rk = get_rk(insn);
+   UInt rj = get_rj(insn);
+
+   DIP("asrtgt.d %s, %s\n", nameIReg(rj), nameIReg(rk));
+
+   gen_SIGSYS(binop(Iop_CmpLE64U, getIReg64(rj), getIReg64(rk)));
+
+   return True;
 }
 
 static Bool gen_rdtimel_w ( DisResult* dres, UInt insn,
                             const VexArchInfo* archinfo,
                             const VexAbiInfo* abiinfo )
 {
-   return False;
+   UInt rj = get_rj(insn);
+   UInt rd = get_rd(insn);
+
+   DIP("rdtimel.w %s, %s\n", nameIReg(rd), nameIReg(rj));
+
+   putIReg(rd, mkU64(0));
+
+   return True;
 }
 
 static Bool gen_rdtimeh_w ( DisResult* dres, UInt insn,
                             const VexArchInfo* archinfo,
                             const VexAbiInfo* abiinfo )
 {
-   return False;
+   UInt rj = get_rj(insn);
+   UInt rd = get_rd(insn);
+
+   DIP("rdtimeh.w %s, %s\n", nameIReg(rd), nameIReg(rj));
+
+   putIReg(rd, mkU64(0));
+
+   return True;
 }
 
 static Bool gen_rdtime_d ( DisResult* dres, UInt insn,
                            const VexArchInfo* archinfo,
                            const VexAbiInfo* abiinfo )
 {
-   return False;
+   UInt rj = get_rj(insn);
+   UInt rd = get_rd(insn);
+
+   DIP("rdtime.d %s, %s\n", nameIReg(rd), nameIReg(rj));
+
+   putIReg(rd, mkU64(0));
+
+   return True;
 }
 
 static Bool gen_cpucfg ( DisResult* dres, UInt insn,
                          const VexArchInfo* archinfo,
                          const VexAbiInfo* abiinfo )
 {
-   return False;
+   UInt rj = get_rj(insn);
+   UInt rd = get_rd(insn);
+
+   DIP("cpucfg %s, %s\n", nameIReg(rd), nameIReg(rj));
+
+   if (!(archinfo->hwcaps & VEX_HWCAPS_LOONGARCH_CPUCFG)) {
+      dres->jk_StopHere = Ijk_SigILL;
+      dres->whatNext    = Dis_StopHere;
+      return True;
+   }
+
+   IRExpr** arg = mkIRExprVec_1(getIReg64(rj));
+   IRExpr* call = mkIRExprCCall(Ity_I64, 0/*regparms*/,
+                                "loongarch64_calculate_cpucfg",
+                                &loongarch64_calculate_cpucfg,
+                                arg);
+   putIReg(rd, call);
+
+   return True;
 }
 
 
-- 
2.39.1

