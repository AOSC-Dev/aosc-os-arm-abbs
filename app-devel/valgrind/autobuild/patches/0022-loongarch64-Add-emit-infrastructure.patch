From 0d9d1f9bbcf2b83213e5873cb99209ac9906d0a8 Mon Sep 17 00:00:00 2001
From: Feiyang Chen <chenfeiyang@loongson.cn>
Date: Mon, 8 Aug 2022 11:18:24 +0800
Subject: [PATCH v4 022/123] loongarch64: Add emit infrastructure

---
 VEX/priv/host_loongarch64_defs.c | 371 +++++++++++++++++++++++++++++++
 VEX/priv/host_loongarch64_defs.h | 270 ++++++++++++++++++++++
 2 files changed, 641 insertions(+)

diff --git a/VEX/priv/host_loongarch64_defs.c b/VEX/priv/host_loongarch64_defs.c
index e1068f3a6..7b6882939 100644
--- a/VEX/priv/host_loongarch64_defs.c
+++ b/VEX/priv/host_loongarch64_defs.c
@@ -183,6 +183,185 @@ UInt ppHRegLOONGARCH64 ( HReg reg )
 }
 
 
+/* --------- Condition codes, LOONGARCH64 encoding. --------- */
+
+static inline const HChar* showLOONGARCH64CondCode ( LOONGARCH64CondCode cond )
+{
+   const HChar* ret;
+   switch (cond) {
+      case LAcc_EQ:
+         ret = "eq";  /* equal */
+         break;
+      case LAcc_NE:
+         ret = "ne";  /* not equal */
+         break;
+      case LAcc_LT:
+         ret = "lt";  /* less than (signed) */
+         break;
+      case LAcc_GE:
+         ret = "ge";  /* great equal (signed) */
+         break;
+      case LAcc_LTU:
+         ret = "ltu"; /* less than (unsigned) */
+         break;
+      case LAcc_GEU:
+         ret = "geu"; /* great equal (unsigned) */
+         break;
+      case LAcc_AL:
+         ret = "al";  /* always (unconditional) */
+         break;
+      default:
+         vpanic("showLOONGARCH64CondCode");
+         break;
+   }
+   return ret;
+}
+
+
+/* --------- Memory address expressions (amodes). --------- */
+
+LOONGARCH64AMode* LOONGARCH64AMode_RI ( HReg reg, UShort imm )
+{
+   LOONGARCH64AMode* am = LibVEX_Alloc_inline(sizeof(LOONGARCH64AMode));
+   am->tag = LAam_RI;
+   am->LAam.RI.base = reg;
+   am->LAam.RI.index = imm;
+   return am;
+}
+
+LOONGARCH64AMode* LOONGARCH64AMode_RR ( HReg base, HReg index )
+{
+   LOONGARCH64AMode* am = LibVEX_Alloc_inline(sizeof(LOONGARCH64AMode));
+   am->tag = LAam_RR;
+   am->LAam.RR.base = base;
+   am->LAam.RR.index = index;
+   return am;
+}
+
+static inline void ppLOONGARCH64AMode ( LOONGARCH64AMode* am )
+{
+   switch (am->tag) {
+      case LAam_RI:
+         ppHRegLOONGARCH64(am->LAam.RI.base);
+         vex_printf(", ");
+         vex_printf("%d", extend((UInt)am->LAam.RI.index, 12));
+         break;
+      case LAam_RR:
+         ppHRegLOONGARCH64(am->LAam.RR.base);
+         vex_printf(", ");
+         ppHRegLOONGARCH64(am->LAam.RR.index);
+         break;
+      default:
+         vpanic("ppLOONGARCH64AMode");
+         break;
+   }
+}
+
+static inline void addRegUsage_LOONGARCH64AMode( HRegUsage* u,
+                                                 LOONGARCH64AMode* am )
+{
+   switch (am->tag) {
+      case LAam_RI:
+         addHRegUse(u, HRmRead, am->LAam.RI.base);
+         break;
+      case LAam_RR:
+         addHRegUse(u, HRmRead, am->LAam.RR.base);
+         addHRegUse(u, HRmRead, am->LAam.RR.index);
+         break;
+      default:
+         vpanic("addRegUsage_LOONGARCH64AMode");
+         break;
+   }
+}
+
+static inline void mapRegs_LOONGARCH64AMode( HRegRemap* m,
+                                             LOONGARCH64AMode* am )
+{
+   switch (am->tag) {
+      case LAam_RI:
+         mapReg(m, &am->LAam.RI.base);
+         break;
+      case LAam_RR:
+         mapReg(m, &am->LAam.RR.base);
+         mapReg(m, &am->LAam.RR.index);
+         break;
+      default:
+         vpanic("mapRegs_LOONGARCH64AMode");
+         break;
+   }
+}
+
+
+/* --------- Operand, which can be reg or imm. --------- */
+
+LOONGARCH64RI* LOONGARCH64RI_R ( HReg reg )
+{
+   LOONGARCH64RI* op = LibVEX_Alloc_inline(sizeof(LOONGARCH64RI));
+   op->tag = LAri_Reg;
+   op->LAri.R.reg = reg;
+   return op;
+}
+
+LOONGARCH64RI* LOONGARCH64RI_I ( UShort imm, UChar size, Bool isSigned )
+{
+   LOONGARCH64RI* op = LibVEX_Alloc_inline(sizeof(LOONGARCH64RI));
+   op->tag = LAri_Imm;
+   op->LAri.I.imm = imm;
+   op->LAri.I.size = size;
+   op->LAri.I.isSigned = isSigned;
+   vassert(imm < (1 << size));
+   vassert(size == 5 || size == 6 || size == 12);
+   return op;
+}
+
+static inline void ppLOONGARCH64RI ( LOONGARCH64RI* ri )
+{
+   switch (ri->tag) {
+      case LAri_Reg:
+         ppHRegLOONGARCH64(ri->LAri.R.reg);
+         break;
+      case LAri_Imm:
+         if (ri->LAri.I.isSigned) {
+            vex_printf("%d", extend((UInt)ri->LAri.I.imm, ri->LAri.I.size));
+         } else {
+            vex_printf("%u", (UInt)ri->LAri.I.imm);
+         }
+         break;
+      default:
+         vpanic("ppLOONGARCH64RI");
+         break;
+   }
+}
+
+static inline void addRegUsage_LOONGARCH64RI( HRegUsage* u, LOONGARCH64RI* ri )
+{
+   switch (ri->tag) {
+      case LAri_Reg:
+         addHRegUse(u, HRmRead, ri->LAri.R.reg);
+         break;
+      case LAri_Imm:
+         break;
+      default:
+         vpanic("addRegUsage_LOONGARCH64RI");
+         break;
+   }
+}
+
+static inline void mapRegs_LOONGARCH64RI( HRegRemap* m, LOONGARCH64RI* ri )
+{
+   switch (ri->tag) {
+      case LAri_Reg:
+         mapReg(m, &ri->LAri.R.reg);
+         break;
+      case LAri_Imm:
+         break;
+      default:
+         vpanic("mapRegs_LOONGARCH64RI");
+         break;
+   }
+}
+
+
 /* -------- Pretty Print instructions ------------- */
 
 void ppLOONGARCH64Instr ( const LOONGARCH64Instr* i, Bool mode64 )
@@ -272,6 +451,198 @@ LOONGARCH64Instr* genMove_LOONGARCH64 ( HReg from, HReg to, Bool mode64 )
 
 /* --------- The loongarch64 assembler --------- */
 
+static inline UInt iregEnc ( HReg r )
+{
+   vassert(hregClass(r) == HRcInt64);
+   vassert(!hregIsVirtual(r));
+   UInt n = hregEncoding(r);
+   vassert(n < 32);
+   return n;
+}
+
+static inline UInt fregEnc ( HReg r )
+{
+   vassert(hregClass(r) == HRcFlt64);
+   vassert(!hregIsVirtual(r));
+   UInt n = hregEncoding(r);
+   vassert(n < 32);
+   return n;
+}
+
+static inline UInt fcsrEnc ( HReg r )
+{
+   vassert(hregClass(r) == HRcInt32);
+   vassert(!hregIsVirtual(r));
+   UInt n = hregEncoding(r);
+   vassert(n < 32);
+   return n;
+}
+
+static inline UInt emit_op_rj_rd ( UInt op, UInt rj, UInt rd )
+{
+   vassert(rj < (1 << 5));
+   vassert(rd < (1 << 5));
+   return op | (rj << 5) | rd;
+}
+
+static inline UInt emit_op_rk_rj_rd ( UInt op, UInt rk, UInt rj, UInt rd )
+{
+   vassert(rk < (1 << 5));
+   vassert(rj < (1 << 5));
+   vassert(rd < (1 << 5));
+   return op | (rk << 10) | (rj << 5) | rd;
+}
+
+static inline UInt emit_op_fj_fd ( UInt op, UInt fj, UInt fd )
+{
+   vassert(fj < (1 << 5));
+   vassert(fd < (1 << 5));
+   return op | (fj << 5) | fd;
+}
+
+static inline UInt emit_op_fa_fk_fj_fd ( UInt op, UInt fa, UInt fk, UInt fj, UInt fd )
+{
+   vassert(fa < (1 << 5));
+   vassert(fk < (1 << 5));
+   vassert(fj < (1 << 5));
+   vassert(fd < (1 << 5));
+   return op | (fa << 15) | (fk << 10) | (fj << 5) | fd;
+}
+
+static inline UInt emit_op_fk_fj_fd ( UInt op, UInt fk, UInt fj, UInt fd )
+{
+   vassert(fk < (1 << 5));
+   vassert(fj < (1 << 5));
+   vassert(fd < (1 << 5));
+   return op | (fk << 10) | (fj << 5) | fd;
+}
+
+static inline UInt emit_op_ca_fk_fj_fd ( UInt op, UInt ca, UInt fk, UInt fj, UInt fd )
+{
+   vassert(ca < (1 << 3));
+   vassert(fk < (1 << 5));
+   vassert(fj < (1 << 5));
+   vassert(fd < (1 << 5));
+   return op | (ca << 15) | (fk << 10) | (fj << 5) | fd;
+}
+
+static inline UInt emit_op_fk_fj_cd ( UInt op, UInt fk, UInt fj, UInt cd )
+{
+   vassert(fk < (1 << 5));
+   vassert(fj < (1 << 5));
+   vassert(cd < (1 << 3));
+   return op | (fk << 10) | (fj << 5) | cd;
+}
+
+static inline UInt emit_op_cj_rd ( UInt op, UInt cj, UInt rd )
+{
+   vassert(cj < (1 << 3));
+   vassert(rd < (1 << 5));
+   return op | (cj << 5) | rd;
+}
+
+static inline UInt emit_op_rj_cd ( UInt op, UInt rj, UInt cd )
+{
+   vassert(rj < (1 << 5));
+   vassert(cd < (1 << 3));
+   return op | (rj << 5) | cd;
+}
+
+static inline UInt emit_op_rj_fd ( UInt op, UInt rj, UInt fd )
+{
+   vassert(rj < (1 << 5));
+   vassert(fd < (1 << 5));
+   return op | (rj << 5) | fd;
+}
+
+static inline UInt emit_op_fj_rd ( UInt op, UInt fj, UInt rd )
+{
+   vassert(fj < (1 << 5));
+   vassert(rd < (1 << 5));
+   return op | (fj << 5) | rd;
+}
+
+static inline UInt emit_op_rj_fcsr ( UInt op, UInt rj, UInt fcsr )
+{
+   vassert(rj < (1 << 5));
+   vassert(fcsr < (1 << 5));
+   return op | (rj << 5) | fcsr;
+}
+
+static inline UInt emit_op_fcsr_rd ( UInt op, UInt fcsr, UInt rd )
+{
+   vassert(fcsr < (1 << 5));
+   vassert(rd < (1 << 5));
+   return op | (fcsr << 5) | rd;
+}
+
+static inline UInt emit_op_ui5_rj_rd ( UInt op, UInt ui5, UInt rj, UInt rd )
+{
+   vassert(ui5 < (1 << 5));
+   vassert(rj < (1 << 5));
+   vassert(rd < (1 << 5));
+   return op | (ui5 << 10) | (rj << 5) | rd;
+}
+
+static inline UInt emit_op_ui6_rj_rd ( UInt op, UInt ui6, UInt rj, UInt rd )
+{
+   vassert(ui6 < (1 << 6));
+   vassert(rj < (1 << 5));
+   vassert(rd < (1 << 5));
+   return op | (ui6 << 10) | (rj << 5) | rd;
+}
+
+static inline UInt emit_op_ui12_rj_rd ( UInt op, UInt ui12, UInt rj, UInt rd )
+{
+   vassert(ui12 < (1 << 12));
+   vassert(rj < (1 << 5));
+   vassert(rd < (1 << 5));
+   return op | (ui12 << 10) | (rj << 5) | rd;
+}
+
+static inline UInt emit_op_si12_rj_rd ( UInt op, UInt si12, UInt rj, UInt rd )
+{
+   vassert(si12 < (1 << 12));
+   vassert(rj < (1 << 5));
+   vassert(rd < (1 << 5));
+   return op | (si12 << 10) | (rj << 5) | rd;
+}
+
+static inline UInt emit_op_si14_rj_rd ( UInt op, UInt si14, UInt rj, UInt rd )
+{
+   vassert(si14 < (1 << 14));
+   vassert(rj < (1 << 5));
+   vassert(rd < (1 << 5));
+   return op | (si14 << 10) | (rj << 5) | rd;
+}
+
+static inline UInt emit_op_si20_rd ( UInt op, UInt si20, UInt rd )
+{
+   vassert(si20 < (1 << 20));
+   vassert(rd < (1 << 5));
+   return op | (si20 << 5) | rd;
+}
+
+static inline UInt emit_op_offs16_rj_rd ( UInt op, UInt offs16, UInt rj, UInt rd )
+{
+   vassert(offs16 < (1 << 16));
+   vassert(rj < (1 << 5));
+   vassert(rd < (1 << 5));
+   return op | (offs16 << 10) | (rj << 5) | rd;
+}
+
+static inline UInt emit_op_offs26 ( UInt op, UInt offs26 )
+{
+   vassert(offs26 < (1 << 26));
+   return op | ((offs26 & 0xffff) << 10) | (offs26 >> 16);
+}
+
+static inline UInt emit_op_hint15 ( UInt op, UInt hint )
+{
+   vassert(hint < (1 << 15));
+   return op | hint;
+}
+
 /* Emit an instruction into buf and return the number of bytes used.
    Note that buf is not the insn's final place, and therefore it is
    imperative to emit position-independent code.  If the emitted
diff --git a/VEX/priv/host_loongarch64_defs.h b/VEX/priv/host_loongarch64_defs.h
index e76d89876..f0631fad6 100644
--- a/VEX/priv/host_loongarch64_defs.h
+++ b/VEX/priv/host_loongarch64_defs.h
@@ -99,8 +99,278 @@ extern UInt ppHRegLOONGARCH64 ( HReg reg );
 #define LOONGARCH64_N_ARGREGS 8 /* a0 ... a7 */
 
 
+/* --------- Condition codes, LOONGARCH64 encoding. --------- */
+typedef enum {
+   LAcc_EQ  = 0, /* equal */
+   LAcc_NE  = 1, /* not equal */
+
+   LAcc_LT  = 2, /* less than (signed) */
+   LAcc_GE  = 3, /* great equal (signed) */
+
+   LAcc_LTU = 4, /* less than (unsigned) */
+   LAcc_GEU = 5, /* great equal (unsigned) */
+
+   LAcc_AL  = 6  /* always (unconditional) */
+} LOONGARCH64CondCode;
+
+
+/* --------- Memory address expressions (amodes). --------- */
+
+typedef enum {
+   LAam_RI, /* Reg + Imm (signed 12-bit or signed 14-bit) */
+   LAam_RR  /* Reg1 + Reg2 */
+} LOONGARCH64AModeTag;
+
+typedef struct {
+   LOONGARCH64AModeTag tag;
+   union {
+      struct {
+         HReg   base;
+         UShort index;
+      } RI;
+      struct {
+         HReg base;
+         HReg index;
+      } RR;
+   } LAam;
+} LOONGARCH64AMode;
+
+extern LOONGARCH64AMode* LOONGARCH64AMode_RI ( HReg reg, UShort imm );
+extern LOONGARCH64AMode* LOONGARCH64AMode_RR ( HReg base, HReg index );
+
+
+/* --------- Operand, which can be reg or imm. --------- */
+
+typedef enum {
+   LAri_Reg,
+   LAri_Imm
+} LOONGARCH64RITag;
+
+typedef struct {
+   LOONGARCH64RITag tag;
+   union {
+      struct {
+         HReg reg;
+      } R;
+      struct {
+         UShort imm;
+         UChar  size; // size == 5 || size == 6 || size == 12
+         Bool   isSigned;
+      } I;
+   } LAri;
+} LOONGARCH64RI;
+
+extern LOONGARCH64RI* LOONGARCH64RI_R ( HReg reg );
+extern LOONGARCH64RI* LOONGARCH64RI_I ( UShort imm, UChar size, Bool isSigned );
+
+
 /* --------- Instructions. --------- */
 
+/* Tags for unary operations */
+typedef enum {
+   LAun_CLZ_W     = 0x00001400,
+   LAun_CTZ_W     = 0x00001c00,
+   LAun_CLZ_D     = 0x00002400,
+   LAun_CTZ_D     = 0x00002c00,
+   LAun_EXT_W_H   = 0x00005800,
+   LAun_EXT_W_B   = 0x00005c00
+} LOONGARCH64UnOp;
+
+/* Tags for binary operations */
+typedef enum {
+   LAbin_ADD_W     = 0x00100000,
+   LAbin_ADD_D     = 0x00108000,
+   LAbin_SUB_W     = 0x00110000,
+   LAbin_SUB_D     = 0x00118000,
+   LAbin_NOR       = 0x00140000,
+   LAbin_AND       = 0x00148000,
+   LAbin_OR        = 0x00150000,
+   LAbin_XOR       = 0x00158000,
+   LAbin_SLL_W     = 0x00170000,
+   LAbin_SRL_W     = 0x00178000,
+   LAbin_SRA_W     = 0x00180000,
+   LAbin_SLL_D     = 0x00188000,
+   LAbin_SRL_D     = 0x00190000,
+   LAbin_SRA_D     = 0x00198000,
+   LAbin_MUL_W     = 0x001c0000,
+   LAbin_MUL_D     = 0x001d8000,
+   LAbin_MULH_W    = 0x001c8000,
+   LAbin_MULH_WU   = 0x001d0000,
+   LAbin_MULH_D    = 0x001e0000,
+   LAbin_MULH_DU   = 0x001e8000,
+   LAbin_MULW_D_W  = 0x001f0000,
+   LAbin_MULW_D_WU = 0x001f8000,
+   LAbin_DIV_W     = 0x00200000,
+   LAbin_MOD_W     = 0x00208000,
+   LAbin_DIV_WU    = 0x00210000,
+   LAbin_MOD_WU    = 0x00218000,
+   LAbin_DIV_D     = 0x00220000,
+   LAbin_MOD_D     = 0x00228000,
+   LAbin_DIV_DU    = 0x00230000,
+   LAbin_MOD_DU    = 0x00238000,
+   LAbin_SLLI_W    = 0x00408000,
+   LAbin_SLLI_D    = 0x00410000,
+   LAbin_SRLI_W    = 0x00448000,
+   LAbin_SRLI_D    = 0x00450000,
+   LAbin_SRAI_W    = 0x00488000,
+   LAbin_SRAI_D    = 0x00490000,
+   LAbin_ADDI_W    = 0x02800000,
+   LAbin_ADDI_D    = 0x02c00000,
+   LAbin_ANDI      = 0x03400000,
+   LAbin_ORI       = 0x03800000,
+   LAbin_XORI      = 0x03c00000
+} LOONGARCH64BinOp;
+
+/* Tags for load operations */
+typedef enum {
+   LAload_LD_W   = 0x28800000,
+   LAload_LD_D   = 0x28c00000,
+   LAload_LD_BU  = 0x2a000000,
+   LAload_LD_HU  = 0x2a400000,
+   LAload_LD_WU  = 0x2a800000,
+   LAload_LDX_D  = 0x380c0000,
+   LAload_LDX_BU = 0x38200000,
+   LAload_LDX_HU = 0x38240000,
+   LAload_LDX_WU = 0x38280000
+} LOONGARCH64LoadOp;
+
+/* Tags for store operations */
+typedef enum {
+   LAstore_ST_B  = 0x29000000,
+   LAstore_ST_H  = 0x29400000,
+   LAstore_ST_W  = 0x29800000,
+   LAstore_ST_D  = 0x29c00000,
+   LAstore_STX_B = 0x38100000,
+   LAstore_STX_H = 0x38140000,
+   LAstore_STX_W = 0x38180000,
+   LAstore_STX_D = 0x381c0000
+} LOONGARCH64StoreOp;
+
+/* Tags for ll/sc operations */
+typedef enum {
+   LAllsc_LL_W = 0x20000000,
+   LAllsc_SC_W = 0x21000000,
+   LAllsc_LL_D = 0x22000000,
+   LAllsc_SC_D = 0x23000000
+} LOONGARCH64LLSCOp;
+
+/* Tags for barrier operations */
+typedef enum {
+   LAbar_DBAR = 0x38720000,
+   LAbar_IBAR = 0x38728000
+} LOONGARCH64BarOp;
+
+/* Tags for floating point unary operations */
+typedef enum {
+   LAfpun_FABS_S    = 0x01140400,
+   LAfpun_FABS_D    = 0x01140800,
+   LAfpun_FNEG_S    = 0x01141400,
+   LAfpun_FNEG_D    = 0x01141800,
+   LAfpun_FLOGB_S   = 0x01142400,
+   LAfpun_FLOGB_D   = 0x01142800,
+   LAfpun_FSQRT_S   = 0x01144400,
+   LAfpun_FSQRT_D   = 0x01144800,
+   LAfpun_FRSQRT_S  = 0x01146400,
+   LAfpun_FRSQRT_D  = 0x01146800,
+   LAfpun_FCVT_S_D  = 0x01191800,
+   LAfpun_FCVT_D_S  = 0x01192400,
+   LAfpun_FTINT_W_S = 0x011b0400,
+   LAfpun_FTINT_W_D = 0x011b0800,
+   LAfpun_FTINT_L_S = 0x011b2400,
+   LAfpun_FTINT_L_D = 0x011b2800,
+   LAfpun_FFINT_S_W = 0x011d1000,
+   LAfpun_FFINT_S_L = 0x011d1800,
+   LAfpun_FFINT_D_W = 0x011d2000,
+   LAfpun_FFINT_D_L = 0x011d2800,
+   LAfpun_FRINT_S   = 0x011e4400,
+   LAfpun_FRINT_D   = 0x011e4800
+} LOONGARCH64FpUnOp;
+
+/* Tags for floating point binary operations */
+typedef enum {
+   LAfpbin_FADD_S    = 0x01008000,
+   LAfpbin_FADD_D    = 0x01010000,
+   LAfpbin_FSUB_S    = 0x01028000,
+   LAfpbin_FSUB_D    = 0x01030000,
+   LAfpbin_FMUL_S    = 0x01048000,
+   LAfpbin_FMUL_D    = 0x01050000,
+   LAfpbin_FDIV_S    = 0x01068000,
+   LAfpbin_FDIV_D    = 0x01070000,
+   LAfpbin_FMAX_S    = 0x01088000,
+   LAfpbin_FMAX_D    = 0x01090000,
+   LAfpbin_FMIN_S    = 0x010a8000,
+   LAfpbin_FMIN_D    = 0x010b0000,
+   LAfpbin_FMAXA_S   = 0x010c8000,
+   LAfpbin_FMAXA_D   = 0x010d0000,
+   LAfpbin_FMINA_S   = 0x010e8000,
+   LAfpbin_FMINA_D   = 0x010f0000,
+   LAfpbin_FSCALEB_S = 0x01108000,
+   LAfpbin_FSCALEB_D = 0x01110000
+} LOONGARCH64FpBinOp;
+
+/* Tags for floating point trinary operations */
+typedef enum {
+   LAfpbin_FMADD_S = 0x08100000,
+   LAfpbin_FMADD_D = 0x08200000,
+   LAfpbin_FMSUB_S = 0x08500000,
+   LAfpbin_FMSUB_D = 0x08600000
+} LOONGARCH64FpTriOp;
+
+/* Tags for floating point load operations */
+typedef enum {
+   LAfpload_FLD_S  = 0x2b000000,
+   LAfpload_FLD_D  = 0x2b800000,
+   LAfpload_FLDX_S = 0x38300000,
+   LAfpload_FLDX_D = 0x38340000
+} LOONGARCH64FpLoadOp;
+
+/* Tags for floating point store operations */
+typedef enum {
+   LAfpstore_FST_S  = 0x2b400000,
+   LAfpstore_FST_D  = 0x2bc00000,
+   LAfpstore_FSTX_S = 0x38380000,
+   LAfpstore_FSTX_D = 0x383c0000
+} LOONGARCH64FpStoreOp;
+
+/* Tags for floating point move operations */
+typedef enum {
+   LAfpmove_FMOV_S     = 0x01149400,
+   LAfpmove_FMOV_D     = 0x01149800,
+   LAfpmove_MOVGR2FR_W = 0x0114a400,
+   LAfpmove_MOVGR2FR_D = 0x0114a800,
+   LAfpmove_MOVFR2GR_S = 0x0114b400,
+   LAfpmove_MOVFR2GR_D = 0x0114b800,
+   LAfpmove_MOVGR2FCSR = 0x0114c000,
+   LAfpmove_MOVFCSR2GR = 0x0114c800
+} LOONGARCH64FpMoveOp;
+
+/* Tags for floating point compare operations */
+typedef enum {
+   LAfpcmp_FCMP_CLT_S = 0x0c110000,
+   LAfpcmp_FCMP_CLT_D = 0x0c210000,
+   LAfpcmp_FCMP_CEQ_S = 0x0c120000,
+   LAfpcmp_FCMP_CEQ_D = 0x0c220000,
+   LAfpcmp_FCMP_CUN_S = 0x0c140000,
+   LAfpcmp_FCMP_CUN_D = 0x0c240000
+} LOONGARCH64FpCmpOp;
+
+/* Tags for extra operations, we only use them when emiting code directly */
+typedef enum {
+   LAextra_MOVCF2GR = 0x0114dc00,
+   LAextra_SLT      = 0x00120000,
+   LAextra_SLTU     = 0x00128000,
+   LAextra_SLTI     = 0x02000000,
+   LAextra_SLTUI    = 0x02400000,
+   LAextra_LU52I_D  = 0x03000000,
+   LAextra_LU12I_W  = 0x14000000,
+   LAextra_LU32I_D  = 0x16000000,
+   LAextra_JIRL     = 0x4c000000,
+   LAextra_B        = 0x50000000,
+   LAextra_BEQ      = 0x58000000,
+   LAextra_BNE      = 0x5c000000,
+   LAextra_BGE      = 0x64000000
+} LOONGARCH64ExtraOp;
+
 /* Tags for instructions */
 typedef enum {
    /* Pseudo-insn, used for generating a 64-bit
-- 
2.39.1

