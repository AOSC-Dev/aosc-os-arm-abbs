From d452a25bf7f80b7518ed47897818423dba2da506 Mon Sep 17 00:00:00 2001
From: Feiyang Chen <chenfeiyang@loongson.cn>
Date: Wed, 23 Mar 2022 11:31:59 +0800
Subject: [PATCH v4 007/123] Enable the loongarch64-linux target in the build
 system

---
 .gitignore                                    |   2 +
 Makefile.all.am                               |   7 +
 Makefile.tool.am                              |  12 +
 VEX/useful/test_main.c                        |  13 +-
 cachegrind/cg_arch.c                          |   4 +
 cachegrind/cg_branchpred.c                    |   2 +-
 configure.ac                                  |  26 +-
 coregrind/Makefile.am                         |   5 +
 coregrind/m_aspacemgr/aspacemgr-common.c      |   9 +-
 coregrind/m_aspacemgr/aspacemgr-linux.c       |   3 +-
 coregrind/m_cache.c                           |   9 +
 coregrind/m_coredump/coredump-elf.c           |   5 +
 coregrind/m_debuginfo/d3basics.c              |   2 +
 coregrind/m_debuginfo/debuginfo.c             |  10 +-
 coregrind/m_debuginfo/priv_storage.h          |  19 +-
 coregrind/m_debuginfo/readdwarf.c             |  37 +
 coregrind/m_debuginfo/readelf.c               |   6 +-
 coregrind/m_debuginfo/storage.c               |   6 +
 coregrind/m_debuglog.c                        |  14 +
 .../m_dispatch/dispatch-loongarch64-linux.S   | 106 +++
 coregrind/m_gdbserver/target.c                |   2 +
 .../m_gdbserver/valgrind-low-loongarch64.c    |  42 +
 coregrind/m_gdbserver/valgrind_low.h          |   1 +
 coregrind/m_initimg/initimg-linux.c           |   6 +-
 coregrind/m_libcassert.c                      |   5 +
 coregrind/m_libcfile.c                        |  49 +-
 coregrind/m_libcproc.c                        |  11 +-
 coregrind/m_machine.c                         |  49 +-
 coregrind/m_main.c                            |  19 +-
 coregrind/m_options.c                         |   3 +-
 coregrind/m_redir.c                           |   3 +
 coregrind/m_scheduler/scheduler.c             |   3 +
 .../m_sigframe/sigframe-loongarch64-linux.c   |  99 +++
 coregrind/m_signals.c                         |  49 +-
 coregrind/m_stacktrace.c                      |  14 +
 coregrind/m_syscall.c                         |  24 +
 coregrind/m_syswrap/priv_syswrap-linux.h      |   7 +
 coregrind/m_syswrap/priv_types_n_macros.h     |   3 +-
 .../m_syswrap/syscall-loongarch64-linux.S     | 102 +++
 coregrind/m_syswrap/syswrap-generic.c         |   2 +-
 coregrind/m_syswrap/syswrap-linux.c           |  23 +-
 .../m_syswrap/syswrap-loongarch64-linux.c     | 137 +++
 coregrind/m_syswrap/syswrap-main.c            |  21 +
 coregrind/m_trampoline.S                      |  34 +
 coregrind/m_vki.c                             |   6 +-
 coregrind/pub_core_aspacemgr.h                |   3 +-
 coregrind/pub_core_basics.h                   |   8 +-
 coregrind/pub_core_debuginfo.h                |   4 +
 coregrind/pub_core_machine.h                  |  13 +
 coregrind/pub_core_mallocfree.h               |   1 +
 coregrind/pub_core_syscall.h                  |   1 +
 coregrind/pub_core_trampoline.h               |   6 +
 coregrind/pub_core_transtab.h                 |   3 +-
 coregrind/pub_core_transtab_asm.h             |   2 +-
 coregrind/vgdb-invoker-ptrace.c               |  19 +-
 drd/drd_bitmap.h                              |   2 +-
 drd/drd_load_store.c                          |   2 +
 helgrind/tests/annotate_hbefore.c             |  11 +
 helgrind/tests/tc07_hbl1.c                    |   8 +
 helgrind/tests/tc08_hbl2.c                    |   8 +
 helgrind/tests/tc11_XCHG.c                    |  18 +
 include/Makefile.am                           |   3 +
 include/pub_tool_basics.h                     |   6 +-
 include/pub_tool_guest.h                      |   3 +
 include/pub_tool_machine.h                    |   6 +
 include/pub_tool_vkiscnums_asm.h              |   4 +
 include/valgrind.h.in                         | 144 ++-
 include/vki/vki-linux.h                       |   4 +
 include/vki/vki-loongarch64-linux.h           | 827 ++++++++++++++++++
 .../vki/vki-posixtypes-loongarch64-linux.h    |  76 ++
 include/vki/vki-scnums-loongarch64-linux.h    | 356 ++++++++
 memcheck/mc_machine.c                         |  10 +
 memcheck/tests/atomic_incs.c                  |  15 +-
 memcheck/tests/unit_libcbase.c                |   4 +-
 none/tests/libvex_test.c                      |   7 +-
 tests/Makefile.am                             |   3 +-
 tests/arch_test.c                             |   5 +
 tests/loongarch64_features.c                  |  81 ++
 tests/platform_test                           |   1 +
 79 files changed, 2600 insertions(+), 75 deletions(-)
 create mode 100644 coregrind/m_dispatch/dispatch-loongarch64-linux.S
 create mode 100644 coregrind/m_gdbserver/valgrind-low-loongarch64.c
 create mode 100644 coregrind/m_sigframe/sigframe-loongarch64-linux.c
 create mode 100644 coregrind/m_syswrap/syscall-loongarch64-linux.S
 create mode 100644 coregrind/m_syswrap/syswrap-loongarch64-linux.c
 create mode 100644 include/vki/vki-loongarch64-linux.h
 create mode 100644 include/vki/vki-posixtypes-loongarch64-linux.h
 create mode 100644 include/vki/vki-scnums-loongarch64-linux.h
 create mode 100644 tests/loongarch64_features.c

diff --git a/.gitignore b/.gitignore
index b6c285234..d849e53c2 100644
--- a/.gitignore
+++ b/.gitignore
@@ -53,6 +53,7 @@
 /auxprogs/getoff-mips32-linux
 /auxprogs/getoff-mips64-linux
 /auxprogs/getoff-nanomips-linux
+/auxprogs/getoff-loongarch64-linux
 /auxprogs/getoff-amd64-solaris
 /auxprogs/getoff-x86-solaris
 /auxprogs/getoff-*-freebsd
@@ -2271,6 +2272,7 @@
 /tests/vg_regtest
 /tests/x86_amd64_features
 /tests/arm64_features
+/tests/loongarch64_features
 
 # /VEX/
 /VEX/libvex*.a
diff --git a/Makefile.all.am b/Makefile.all.am
index 1de1f13a7..d72410a9d 100755
--- a/Makefile.all.am
+++ b/Makefile.all.am
@@ -290,6 +290,12 @@ AM_CFLAGS_PSO_MIPS64_LINUX = @FLAG_M64@ $(AM_CFLAGS_BASE) \
 				$(AM_CFLAGS_PSO_BASE)
 AM_CCASFLAGS_MIPS64_LINUX  = @FLAG_M64@ -g
 
+AM_FLAG_M3264_LOONGARCH64_LINUX = @FLAG_M64@
+AM_CFLAGS_LOONGARCH64_LINUX     = @FLAG_M64@ $(AM_CFLAGS_BASE)
+AM_CFLAGS_PSO_LOONGARCH64_LINUX = @FLAG_M64@ $(AM_CFLAGS_BASE) \
+				$(AM_CFLAGS_PSO_BASE)
+AM_CCASFLAGS_LOONGARCH64_LINUX  = @FLAG_M64@ -g
+
 AM_FLAG_M3264_X86_SOLARIS   = @FLAG_M32@
 AM_CFLAGS_X86_SOLARIS       = @FLAG_M32@ @PREFERRED_STACK_BOUNDARY_2@ \
 				$(AM_CFLAGS_BASE) -fomit-frame-pointer @SOLARIS_UNDEF_LARGESOURCE@
@@ -350,6 +356,7 @@ PRELOAD_LDFLAGS_S390X_LINUX    = $(PRELOAD_LDFLAGS_COMMON_LINUX) @FLAG_M64@
 PRELOAD_LDFLAGS_MIPS32_LINUX   = $(PRELOAD_LDFLAGS_COMMON_LINUX) @FLAG_M32@
 PRELOAD_LDFLAGS_NANOMIPS_LINUX = $(PRELOAD_LDFLAGS_COMMON_LINUX) @FLAG_M32@
 PRELOAD_LDFLAGS_MIPS64_LINUX   = $(PRELOAD_LDFLAGS_COMMON_LINUX) @FLAG_M64@
+PRELOAD_LDFLAGS_LOONGARCH64_LINUX = $(PRELOAD_LDFLAGS_COMMON_LINUX) @FLAG_M64@
 PRELOAD_LDFLAGS_X86_SOLARIS    = $(PRELOAD_LDFLAGS_COMMON_SOLARIS) @FLAG_M32@
 PRELOAD_LDFLAGS_AMD64_SOLARIS  = $(PRELOAD_LDFLAGS_COMMON_SOLARIS) @FLAG_M64@
 
diff --git a/Makefile.tool.am b/Makefile.tool.am
index df9502913..58a928e95 100644
--- a/Makefile.tool.am
+++ b/Makefile.tool.am
@@ -99,6 +99,10 @@ TOOL_LDFLAGS_MIPS64_LINUX = \
 	-static -nodefaultlibs -nostartfiles -u __start @FLAG_NO_BUILD_ID@ \
 	@FLAG_M64@
 
+TOOL_LDFLAGS_LOONGARCH64_LINUX = \
+	-static -nodefaultlibs -nostartfiles -u __start @FLAG_NO_BUILD_ID@ \
+	@FLAG_M64@
+
 TOOL_LDFLAGS_X86_SOLARIS = \
 	$(TOOL_LDFLAGS_COMMON_SOLARIS) @FLAG_M32@
 
@@ -167,6 +171,9 @@ LIBREPLACEMALLOC_MIPS32_LINUX = \
 LIBREPLACEMALLOC_MIPS64_LINUX = \
 	$(top_builddir)/coregrind/libreplacemalloc_toolpreload-mips64-linux.a
 
+LIBREPLACEMALLOC_LOONGARCH64_LINUX = \
+	$(top_builddir)/coregrind/libreplacemalloc_toolpreload-loongarch64-linux.a
+
 LIBREPLACEMALLOC_X86_SOLARIS = \
 	$(top_builddir)/coregrind/libreplacemalloc_toolpreload-x86-solaris.a
 
@@ -239,6 +246,11 @@ LIBREPLACEMALLOC_LDFLAGS_MIPS64_LINUX = \
 	$(LIBREPLACEMALLOC_MIPS64_LINUX) \
 	-Wl,--no-whole-archive
 
+LIBREPLACEMALLOC_LDFLAGS_LOONGARCH64_LINUX = \
+	-Wl,--whole-archive \
+	$(LIBREPLACEMALLOC_LOONGARCH64_LINUX) \
+	-Wl,--no-whole-archive
+
 LIBREPLACEMALLOC_LDFLAGS_X86_SOLARIS = \
 	-Wl,--whole-archive \
 	$(LIBREPLACEMALLOC_X86_SOLARIS) \
diff --git a/VEX/useful/test_main.c b/VEX/useful/test_main.c
index cfed7a598..9c0f38ddc 100644
--- a/VEX/useful/test_main.c
+++ b/VEX/useful/test_main.c
@@ -101,7 +101,8 @@ int main ( int argc, char** argv )
    VexTranslateResult tres;
    VexControl vcon;
    VexGuestExtents vge;
-   VexArchInfo vai_x86, vai_amd64, vai_ppc32, vai_arm, vai_mips32, vai_mips64;
+   VexArchInfo vai_x86, vai_amd64, vai_ppc32, vai_arm, vai_mips32, vai_mips64,
+               vai_loongarch64;
    VexAbiInfo vbi;
    VexTranslateArgs vta;
 
@@ -190,6 +191,10 @@ int main ( int argc, char** argv )
       LibVEX_default_VexArchInfo(&vai_mips64);
       vai_mips64.endness = VexEndnessLE;
 
+      LibVEX_default_VexArchInfo(&vai_loongarch64);
+      vai_loongarch64.hwcaps = VEX_HWCAPS_LOONGARCH_ISA_64BIT;
+      vai_loongarch64.endness = VexEndnessLE;
+
       LibVEX_default_VexAbiInfo(&vbi);
       vbi.guest_stack_redzone_size = 128;
 
@@ -245,6 +250,12 @@ int main ( int argc, char** argv )
       vta.guest_bytes     = &origbuf[18 +1];
       vta.guest_bytes_addr = (Addr) &origbuf[18 +1];
 #endif
+#if 0 /* loongarch64 -> loongarch64 */
+      vta.arch_guest     = VexArchLOONGARCH64;
+      vta.archinfo_guest = vai_loongarch64;
+      vta.arch_host      = VexArchLOONGARCH64;
+      vta.archinfo_host  = vai_loongarch64;
+#endif
 
 #if 1 /* no instrumentation */
       vta.instrument1     = NULL;
diff --git a/cachegrind/cg_arch.c b/cachegrind/cg_arch.c
index 57570dd63..c1a2e960d 100644
--- a/cachegrind/cg_arch.c
+++ b/cachegrind/cg_arch.c
@@ -475,6 +475,10 @@ configure_caches(cache_t *I1c, cache_t *D1c, cache_t *LLc,
    *D1c = (cache_t) {  65536, 2, 64 };
    *LLc = (cache_t) { 262144, 8, 64 };
 
+#elif defined(VGA_loongarch64)
+
+   /* TODO */
+
 #else
 
 #error "Unknown arch"
diff --git a/cachegrind/cg_branchpred.c b/cachegrind/cg_branchpred.c
index ba433ec2c..0d91b29cd 100644
--- a/cachegrind/cg_branchpred.c
+++ b/cachegrind/cg_branchpred.c
@@ -44,7 +44,7 @@
    guaranteed to be zero? */
 #if defined(VGA_ppc32) || defined(VGA_ppc64be)  || defined(VGA_ppc64le) \
     || defined(VGA_mips32) || defined(VGA_mips64) || defined(VGA_nanomips) \
-    || defined(VGA_arm64)
+    || defined(VGA_arm64) || defined(VGA_loongarch64)
 #  define N_IADDR_LO_ZERO_BITS 2
 #elif defined(VGA_x86) || defined(VGA_amd64)
 #  define N_IADDR_LO_ZERO_BITS 0
diff --git a/configure.ac b/configure.ac
index 625063beb..c6bb31139 100755
--- a/configure.ac
+++ b/configure.ac
@@ -311,6 +311,11 @@ case "${host_cpu}" in
         ARCH_MAX="nanomips"
         ;;
 
+     loongarch64*)
+        AC_MSG_RESULT([ok (${host_cpu})])
+        ARCH_MAX="loongarch64"
+        ;;
+
      *) 
 	AC_MSG_RESULT([no (${host_cpu})])
 	AC_MSG_ERROR([Unsupported host architecture. Sorry])
@@ -935,6 +940,17 @@ case "$ARCH_MAX-$VGCONF_OS" in
         valt_load_address_sec_inner="0xUNSET"
         AC_MSG_RESULT([ok (${ARCH_MAX}-${VGCONF_OS})])
         ;;
+     loongarch64-linux)
+        VGCONF_ARCH_PRI="loongarch64"
+        VGCONF_ARCH_SEC=""
+        VGCONF_PLATFORM_PRI_CAPS="LOONGARCH64_LINUX"
+        VGCONF_PLATFORM_SEC_CAPS=""
+        valt_load_address_pri_norml="0x58000000"
+        valt_load_address_pri_inner="0x38000000"
+        valt_load_address_sec_norml="0xUNSET"
+        valt_load_address_sec_inner="0xUNSET"
+        AC_MSG_RESULT([ok (${ARCH_MAX}-${VGCONF_OS})])
+        ;;
      x86-solaris)
         VGCONF_ARCH_PRI="x86"
         VGCONF_ARCH_SEC=""
@@ -1027,6 +1043,8 @@ AM_CONDITIONAL(VGCONF_ARCHS_INCLUDE_MIPS64,
                test x$VGCONF_PLATFORM_PRI_CAPS = xMIPS64_LINUX ) 
 AM_CONDITIONAL(VGCONF_ARCHS_INCLUDE_NANOMIPS,
                test x$VGCONF_PLATFORM_PRI_CAPS = xNANOMIPS_LINUX )
+AM_CONDITIONAL(VGCONF_ARCHS_INCLUDE_LOONGARCH64,
+               test x$VGCONF_PLATFORM_PRI_CAPS = xLOONGARCH64_LINUX )
 
 # Set up VGCONF_PLATFORMS_INCLUDE_<platform>.  Either one or two of these
 # become defined.
@@ -1057,6 +1075,8 @@ AM_CONDITIONAL(VGCONF_PLATFORMS_INCLUDE_MIPS64_LINUX,
                test x$VGCONF_PLATFORM_PRI_CAPS = xMIPS64_LINUX)
 AM_CONDITIONAL(VGCONF_PLATFORMS_INCLUDE_NANOMIPS_LINUX,
                test x$VGCONF_PLATFORM_PRI_CAPS = xNANOMIPS_LINUX)
+AM_CONDITIONAL(VGCONF_PLATFORMS_INCLUDE_LOONGARCH64_LINUX,
+               test x$VGCONF_PLATFORM_PRI_CAPS = xLOONGARCH64_LINUX)
 AM_CONDITIONAL(VGCONF_PLATFORMS_INCLUDE_X86_FREEBSD,
                test x$VGCONF_PLATFORM_PRI_CAPS = xX86_FREEBSD \
                  -o x$VGCONF_PLATFORM_SEC_CAPS = xX86_FREEBSD)
@@ -1088,7 +1108,8 @@ AM_CONDITIONAL(VGCONF_OS_IS_LINUX,
                  -o x$VGCONF_PLATFORM_PRI_CAPS = xS390X_LINUX \
                  -o x$VGCONF_PLATFORM_PRI_CAPS = xMIPS32_LINUX \
                  -o x$VGCONF_PLATFORM_PRI_CAPS = xMIPS64_LINUX \
-                 -o x$VGCONF_PLATFORM_PRI_CAPS = xNANOMIPS_LINUX)
+                 -o x$VGCONF_PLATFORM_PRI_CAPS = xNANOMIPS_LINUX \
+                 -o x$VGCONF_PLATFORM_PRI_CAPS = xLOONGARCH64_LINUX)
 AM_CONDITIONAL(VGCONF_OS_IS_FREEBSD,
                test x$VGCONF_PLATFORM_PRI_CAPS = xX86_FREEBSD \
                  -o x$VGCONF_PLATFORM_PRI_CAPS = xAMD64_FREEBSD)
@@ -4879,7 +4900,8 @@ elif test x$VGCONF_PLATFORM_PRI_CAPS = xAMD64_LINUX \
        -o x$VGCONF_PLATFORM_PRI_CAPS = xPPC64_LINUX \
        -o x$VGCONF_PLATFORM_PRI_CAPS = xARM64_LINUX \
        -o x$VGCONF_PLATFORM_PRI_CAPS = xMIPS64_LINUX \
-       -o x$VGCONF_PLATFORM_PRI_CAPS = xS390X_LINUX ; then
+       -o x$VGCONF_PLATFORM_PRI_CAPS = xS390X_LINUX \
+       -o x$VGCONF_PLATFORM_PRI_CAPS = xLOONGARCH64_LINUX; then
   mflag_primary=$FLAG_M64
 elif test x$VGCONF_PLATFORM_PRI_CAPS = xX86_DARWIN ; then
   mflag_primary="$FLAG_M32 -arch i386"
diff --git a/coregrind/Makefile.am b/coregrind/Makefile.am
index dda0689dd..5c747685d 100644
--- a/coregrind/Makefile.am
+++ b/coregrind/Makefile.am
@@ -387,6 +387,7 @@ COREGRIND_SOURCES_COMMON = \
 	m_dispatch/dispatch-mips32-linux.S \
 	m_dispatch/dispatch-mips64-linux.S \
 	m_dispatch/dispatch-nanomips-linux.S \
+	m_dispatch/dispatch-loongarch64-linux.S \
 	m_dispatch/dispatch-x86-freebsd.S \
 	m_dispatch/dispatch-amd64-freebsd.S \
 	m_dispatch/dispatch-x86-darwin.S \
@@ -411,6 +412,7 @@ COREGRIND_SOURCES_COMMON = \
 	m_gdbserver/valgrind-low-mips32.c \
 	m_gdbserver/valgrind-low-mips64.c \
 	m_gdbserver/valgrind-low-nanomips.c \
+	m_gdbserver/valgrind-low-loongarch64.c \
 	m_gdbserver/version.c \
 	m_initimg/initimg-linux.c \
 	m_initimg/initimg-freebsd.c \
@@ -438,6 +440,7 @@ COREGRIND_SOURCES_COMMON = \
 	m_sigframe/sigframe-mips32-linux.c \
 	m_sigframe/sigframe-mips64-linux.c \
 	m_sigframe/sigframe-nanomips-linux.c \
+	m_sigframe/sigframe-loongarch64-linux.c \
 	m_sigframe/sigframe-x86-darwin.c \
 	m_sigframe/sigframe-amd64-darwin.c \
 	m_sigframe/sigframe-solaris.c \
@@ -452,6 +455,7 @@ COREGRIND_SOURCES_COMMON = \
 	m_syswrap/syscall-mips32-linux.S \
 	m_syswrap/syscall-mips64-linux.S \
 	m_syswrap/syscall-nanomips-linux.S \
+	m_syswrap/syscall-loongarch64-linux.S \
 	m_syswrap/syscall-x86-freebsd.S \
 	m_syswrap/syscall-amd64-freebsd.S \
 	m_syswrap/syscall-x86-darwin.S \
@@ -477,6 +481,7 @@ COREGRIND_SOURCES_COMMON = \
 	m_syswrap/syswrap-mips32-linux.c \
 	m_syswrap/syswrap-mips64-linux.c \
 	m_syswrap/syswrap-nanomips-linux.c \
+	m_syswrap/syswrap-loongarch64-linux.c \
 	m_syswrap/syswrap-x86-darwin.c \
 	m_syswrap/syswrap-amd64-darwin.c \
 	m_syswrap/syswrap-xen.c \
diff --git a/coregrind/m_aspacemgr/aspacemgr-common.c b/coregrind/m_aspacemgr/aspacemgr-common.c
index 816d2274f..0e79d3f3c 100644
--- a/coregrind/m_aspacemgr/aspacemgr-common.c
+++ b/coregrind/m_aspacemgr/aspacemgr-common.c
@@ -157,7 +157,8 @@ SysRes VG_(am_do_mmap_NO_NOTIFY)( Addr start, SizeT length, UInt prot,
 #  elif defined(VGP_amd64_linux) \
         || defined(VGP_ppc64be_linux)  || defined(VGP_ppc64le_linux) \
         || defined(VGP_s390x_linux) || defined(VGP_mips32_linux) \
-        || defined(VGP_mips64_linux) || defined(VGP_arm64_linux)
+        || defined(VGP_mips64_linux) || defined(VGP_arm64_linux) \
+        || defined(VGP_loongarch64_linux)
    res = VG_(do_syscall6)(__NR_mmap, (UWord)start, length, 
                          prot, flags, fd, offset);
 #  elif defined(VGP_x86_darwin)
@@ -262,7 +263,8 @@ SysRes ML_(am_do_relocate_nooverlap_mapping_NO_NOTIFY)(
 
 SysRes ML_(am_open) ( const HChar* pathname, Int flags, Int mode )
 {
-#  if defined(VGP_arm64_linux) || defined(VGP_nanomips_linux)
+#  if defined(VGP_arm64_linux) || defined(VGP_nanomips_linux) \
+      || defined(VGP_loongarch64_linux)
    /* ARM64 wants to use __NR_openat rather than __NR_open. */
    SysRes res = VG_(do_syscall4)(__NR_openat,
                                  VKI_AT_FDCWD, (UWord)pathname, flags, mode);
@@ -291,7 +293,8 @@ void ML_(am_close) ( Int fd )
 Int ML_(am_readlink)(const HChar* path, HChar* buf, UInt bufsiz)
 {
    SysRes res;
-#  if defined(VGP_arm64_linux) || defined(VGP_nanomips_linux)
+#  if defined(VGP_arm64_linux) || defined(VGP_nanomips_linux) \
+      || defined(VGP_loongarch64_linux)
    res = VG_(do_syscall4)(__NR_readlinkat, VKI_AT_FDCWD,
                                            (UWord)path, (UWord)buf, bufsiz);
 #  elif defined(VGO_linux) || defined(VGO_darwin) || defined(VGO_freebsd)
diff --git a/coregrind/m_aspacemgr/aspacemgr-linux.c b/coregrind/m_aspacemgr/aspacemgr-linux.c
index 00a42ffe6..5bb6b55ab 100644
--- a/coregrind/m_aspacemgr/aspacemgr-linux.c
+++ b/coregrind/m_aspacemgr/aspacemgr-linux.c
@@ -2774,7 +2774,8 @@ static SysRes VG_(am_mmap_file_float_valgrind_flags) ( SizeT length, UInt prot,
    req.rkind = MAny;
    req.start = 0;
    #if defined(VGA_arm) || defined(VGA_arm64) \
-      || defined(VGA_mips32) || defined(VGA_mips64) || defined(VGA_nanomips)
+      || defined(VGA_mips32) || defined(VGA_mips64) || defined(VGA_nanomips) \
+      || defined(VGA_loongarch64)
    aspacem_assert(VKI_SHMLBA >= VKI_PAGE_SIZE);
    #else
    aspacem_assert(VKI_SHMLBA == VKI_PAGE_SIZE);
diff --git a/coregrind/m_cache.c b/coregrind/m_cache.c
index 428a4df43..a4a3c9a8a 100644
--- a/coregrind/m_cache.c
+++ b/coregrind/m_cache.c
@@ -660,6 +660,15 @@ get_cache_info(VexArchInfo *vai)
    return True;
 }
 
+#elif defined(VGA_loongarch64)
+
+static Bool
+get_cache_info(VexArchInfo *vai)
+{
+   /* TODO */
+   return False;
+}
+
 #else
 
 #error "Unknown arch"
diff --git a/coregrind/m_coredump/coredump-elf.c b/coregrind/m_coredump/coredump-elf.c
index 4a8c29c52..e2bb1017b 100644
--- a/coregrind/m_coredump/coredump-elf.c
+++ b/coregrind/m_coredump/coredump-elf.c
@@ -489,6 +489,8 @@ static void fill_prstatus(const ThreadState *tst,
    regs[VKI_MIPS32_EF_CP0_STATUS] = arch->vex.guest_CP0_status;
    regs[VKI_MIPS32_EF_CP0_EPC]    = arch->vex.guest_PC;
 #  undef DO
+#elif defined(VGP_loongarch64_linux)
+   /* TODO */
 #elif defined(VGP_amd64_freebsd)
    regs->rflags = LibVEX_GuestAMD64_get_rflags( &arch->vex );
    regs->rsp    = arch->vex.guest_RSP;
@@ -654,6 +656,9 @@ static void fill_fpu(const ThreadState *tst, vki_elf_fpregset_t *fpu)
 #  undef DO
 #elif defined(VGP_nanomips_linux)
 
+#elif defined(VGP_loongarch64_linux)
+   /* TODO */
+
 #elif defined(VGP_x86_freebsd)
 
 #elif defined(VGP_amd64_freebsd)
diff --git a/coregrind/m_debuginfo/d3basics.c b/coregrind/m_debuginfo/d3basics.c
index e9e8944af..ba2a9d761 100644
--- a/coregrind/m_debuginfo/d3basics.c
+++ b/coregrind/m_debuginfo/d3basics.c
@@ -555,6 +555,8 @@ static Bool get_Dwarf_Reg( /*OUT*/Addr* a, Word regno, const RegSummary* regs )
 #  elif defined(VGP_arm64_linux)
    if (regno == 31) { *a = regs->sp; return True; }
    if (regno == 29) { *a = regs->fp; return True; }
+#  elif defined(VGP_loongarch64_linux)
+   /* TODO */
 #  else
 #    error "Unknown platform"
 #  endif
diff --git a/coregrind/m_debuginfo/debuginfo.c b/coregrind/m_debuginfo/debuginfo.c
index 2d2accc99..7fb096593 100644
--- a/coregrind/m_debuginfo/debuginfo.c
+++ b/coregrind/m_debuginfo/debuginfo.c
@@ -1262,7 +1262,7 @@ ULong VG_(di_notify_mmap)( Addr a, Bool allow_SkFileV, Int use_fd )
    is_ro_map = False;
 
 #  if defined(VGA_x86) || defined(VGA_ppc32) || defined(VGA_mips32) \
-      || defined(VGA_mips64) || defined(VGA_nanomips)
+      || defined(VGA_mips64) || defined(VGA_nanomips) || defined(VGA_loongarch64)
    is_rx_map = seg->hasR && seg->hasX;
    is_rw_map = seg->hasR && seg->hasW;
 #  elif defined(VGA_amd64) || defined(VGA_ppc64be) || defined(VGA_ppc64le)  \
@@ -2998,6 +2998,8 @@ UWord evalCfiExpr ( const XArray* exprs, Int ix,
             case Creg_ARM64_SP: return eec->uregs->sp;
             case Creg_ARM64_X30: return eec->uregs->x30;
             case Creg_ARM64_X29: return eec->uregs->x29;
+#           elif defined(VGA_loongarch64)
+            /* TODO */
 #           else
 #             error "Unsupported arch"
 #           endif
@@ -3269,6 +3271,8 @@ static Addr compute_cfa ( const D3UnwindRegs* uregs,
       case CFIC_ARM64_X29REL: 
          cfa = cfsi_m->cfa_off + uregs->x29;
          break;
+#     elif defined(VGA_loongarch64)
+      /* TODO */
 #     else
 #       error "Unsupported arch"
 #     endif
@@ -3414,6 +3418,8 @@ Bool VG_(use_CF_info) ( /*MOD*/D3UnwindRegs* uregsHere,
 #  elif defined(VGA_ppc32) || defined(VGA_ppc64be) || defined(VGA_ppc64le)
 #  elif defined(VGP_arm64_linux)
    ipHere = uregsHere->pc;
+#  elif defined(VGA_loongarch64)
+   /* TODO */
 #  else
 #    error "Unknown arch"
 #  endif
@@ -3559,6 +3565,8 @@ Bool VG_(use_CF_info) ( /*MOD*/D3UnwindRegs* uregsHere,
    COMPUTE(uregsPrev.sp,  uregsHere->sp,  cfsi_m->sp_how,  cfsi_m->sp_off);
    COMPUTE(uregsPrev.x30, uregsHere->x30, cfsi_m->x30_how, cfsi_m->x30_off);
    COMPUTE(uregsPrev.x29, uregsHere->x29, cfsi_m->x29_how, cfsi_m->x29_off);
+#  elif defined(VGA_loongarch64)
+   /* TODO */
 #  else
 #    error "Unknown arch"
 #  endif
diff --git a/coregrind/m_debuginfo/priv_storage.h b/coregrind/m_debuginfo/priv_storage.h
index a4b90d36b..8188064d4 100644
--- a/coregrind/m_debuginfo/priv_storage.h
+++ b/coregrind/m_debuginfo/priv_storage.h
@@ -367,6 +367,19 @@ typedef
       Int   fp_off;
    }
    DiCfSI_m;
+#elif defined(VGA_loongarch64)
+typedef
+   struct {
+      UChar cfa_how;  /* a CFIC_ value */
+      UChar ra_how;   /* a CFIR_ value */
+      UChar sp_how;   /* a CFIR_ value */
+      UChar fp_how;   /* a CFIR_ value */
+      Int   cfa_off;
+      Int   ra_off;
+      Int   sp_off;
+      Int   fp_off;
+   }
+   DiCfSI_m;
 #else
 #  error "Unknown arch"
 #endif
@@ -422,7 +435,11 @@ typedef
       Creg_S390_SP,
       Creg_S390_FP,
       Creg_S390_LR,
-      Creg_MIPS_RA
+      Creg_MIPS_RA,
+      Creg_LOONGARCH64_PC,
+      Creg_LOONGARCH64_RA,
+      Creg_LOONGARCH64_SP,
+      Creg_LOONGARCH64_FP
    }
    CfiReg;
 
diff --git a/coregrind/m_debuginfo/readdwarf.c b/coregrind/m_debuginfo/readdwarf.c
index 79d6764ea..1a50ff803 100644
--- a/coregrind/m_debuginfo/readdwarf.c
+++ b/coregrind/m_debuginfo/readdwarf.c
@@ -2066,6 +2066,10 @@ void ML_(read_debuginfo_dwarf1) (
 #  define FP_REG         30
 #  define SP_REG         29
 #  define RA_REG_DEFAULT 31
+#elif defined(VGP_loongarch64_linux)
+#  define FP_REG         22
+#  define SP_REG         3
+#  define RA_REG_DEFAULT 1
 #else
 #  error "Unknown platform"
 #endif
@@ -2084,6 +2088,8 @@ void ML_(read_debuginfo_dwarf1) (
 # define N_CFI_REGS 128
 #elif defined(VGP_s390x_linux)
 # define N_CFI_REGS 66
+#elif defined(VGP_loongarch64_linux)
+# define N_CFI_REGS 32
 #else
 # define N_CFI_REGS 20
 #endif
@@ -2786,6 +2792,30 @@ static Bool summarise_context(/*OUT*/Addr* base,
 #  elif defined(VGA_ppc32) || defined(VGA_ppc64be) || defined(VGA_ppc64le)
    /* These don't use CFI based unwinding (is that really true?) */
 
+#  elif defined(VGA_loongarch64)
+
+   /* --- entire tail of this fn specialised for loongarch64 --- */
+
+   SUMMARISE_HOW(si_m->ra_how, si_m->ra_off, ctxs->reg[ctx->ra_reg]);
+   SUMMARISE_HOW(si_m->fp_how, si_m->fp_off, ctxs->reg[FP_REG]);
+
+   /* on loongarch64, it seems the old sp value before the call is always
+      the same as the CFA.  Therefore ... */
+   si_m->sp_how = CFIR_CFAREL;
+   si_m->sp_off = 0;
+
+   /* bogus looking range?  Note, we require that the difference is
+      representable in 32 bits. */
+   if (loc_start >= ctx->loc)
+      { why = 4; goto failed; }
+   if (ctx->loc - loc_start > 10000000 /* let's say */)
+      { why = 5; goto failed; }
+
+   *base = loc_start + ctx->initloc;
+   *len  = (UInt)(ctx->loc - loc_start);
+
+   return True;
+
 #  else
 #    error "Unknown arch"
 #  endif
@@ -2885,6 +2915,13 @@ static Int copy_convert_CfiExpr_tree ( XArray*        dstxa,
             return ML_(CfiExpr_CfiReg)( dstxa, Creg_ARM64_X30 );
 #        elif defined(VGA_ppc32) || defined(VGA_ppc64be) \
             || defined(VGA_ppc64le)
+#        elif defined(VGA_loongarch64)
+         if (dwreg == SP_REG)
+            return ML_(CfiExpr_CfiReg)( dstxa, Creg_LOONGARCH64_SP );
+         if (dwreg == FP_REG)
+            return ML_(CfiExpr_CfiReg)( dstxa, Creg_LOONGARCH64_FP );
+         if (dwreg == srcuc->ra_reg)
+            return ML_(CfiExpr_CfiReg)( dstxa, Creg_LOONGARCH64_RA );
 #        else
 #           error "Unknown arch"
 #        endif
diff --git a/coregrind/m_debuginfo/readelf.c b/coregrind/m_debuginfo/readelf.c
index ce7b7998d..8960689ac 100644
--- a/coregrind/m_debuginfo/readelf.c
+++ b/coregrind/m_debuginfo/readelf.c
@@ -1780,7 +1780,8 @@ static HChar* readlink_path (const HChar *path)
 
    while (tries > 0) {
       SysRes res;
-#if defined(VGP_arm64_linux) || defined(VGP_nanomips_linux)
+#if defined(VGP_arm64_linux) || defined(VGP_nanomips_linux) \
+    || defined(VGP_loongarch64_linux)
       res = VG_(do_syscall4)(__NR_readlinkat, VKI_AT_FDCWD,
                                               (UWord)path, (UWord)buf, bufsiz);
 #elif defined(VGO_linux) || defined(VGO_darwin) || defined(VGO_freebsd)
@@ -2653,8 +2654,9 @@ Bool ML_(read_elf_debug_info) ( struct _DebugInfo* di )
          || defined(VGP_arm_linux) || defined (VGP_s390x_linux) \
          || defined(VGP_mips32_linux) || defined(VGP_mips64_linux) \
          || defined(VGP_arm64_linux) || defined(VGP_nanomips_linux) \
+         || defined(VGP_loongarch64_linux) \
          || defined(VGP_x86_solaris) || defined(VGP_amd64_solaris) \
-         || defined(VGP_x86_freebsd) || defined(VGP_amd64_freebsd)
+         || defined(VGP_x86_freebsd) || defined(VGP_amd64_freebsd) \
       /* Accept .plt where mapped as rx (code) */
       if (0 == VG_(strcmp)(name, ".plt")) {
          if (inrx && !di->plt_present) {
diff --git a/coregrind/m_debuginfo/storage.c b/coregrind/m_debuginfo/storage.c
index c3fa62e96..1c94341c8 100644
--- a/coregrind/m_debuginfo/storage.c
+++ b/coregrind/m_debuginfo/storage.c
@@ -260,6 +260,8 @@ void ML_(ppDiCfSI) ( const XArray* /* of CfiExpr */ exprs,
    SHOW_HOW(si_m->x30_how, si_m->x30_off);
    VG_(printf)(" X29=");
    SHOW_HOW(si_m->x29_how, si_m->x29_off);
+#  elif defined(VGP_loongarch64_linux)
+   /* TODO */
 #  else
 #    error "Unknown arch"
 #  endif
@@ -1010,6 +1012,10 @@ static void ppCfiReg ( CfiReg reg )
       case Creg_S390_SP:   VG_(printf)("SP"); break;
       case Creg_S390_FP:   VG_(printf)("FP"); break;
       case Creg_S390_LR:   VG_(printf)("LR"); break;
+      case Creg_LOONGARCH64_PC: VG_(printf)("PC"); break;
+      case Creg_LOONGARCH64_RA: VG_(printf)("RA"); break;
+      case Creg_LOONGARCH64_SP: VG_(printf)("SP"); break;
+      case Creg_LOONGARCH64_FP: VG_(printf)("FP"); break;
       default: vg_assert(0);
    }
 }
diff --git a/coregrind/m_debuglog.c b/coregrind/m_debuglog.c
index 355c3caf5..671fc57fd 100644
--- a/coregrind/m_debuglog.c
+++ b/coregrind/m_debuglog.c
@@ -601,6 +601,20 @@ static UInt local_sys_getpid ( void )
    return a0;
 }
 
+#elif defined(VGP_loongarch64_linux)
+
+static UInt local_sys_write_stderr ( const HChar* buf, Int n )
+{
+   /* TODO */
+   return 0;
+}
+
+static UInt local_sys_getpid ( void )
+{
+   /* TODO */
+   return 0;
+}
+
 #elif defined(VGP_x86_solaris)
 static UInt local_sys_write_stderr ( const HChar* buf, Int n )
 {
diff --git a/coregrind/m_dispatch/dispatch-loongarch64-linux.S b/coregrind/m_dispatch/dispatch-loongarch64-linux.S
new file mode 100644
index 000000000..f9354e636
--- /dev/null
+++ b/coregrind/m_dispatch/dispatch-loongarch64-linux.S
@@ -0,0 +1,106 @@
+
+/*--------------------------------------------------------------------*/
+/*--- The core dispatch loop, for jumping to a code address.       ---*/
+/*---                                 dispatch-loongarch64-linux.S ---*/
+/*--------------------------------------------------------------------*/
+
+/*
+  This file is part of Valgrind, a dynamic binary instrumentation
+  framework.
+
+  Copyright (C) 2021-2022 Loongson Technology Corporation Limited
+
+  This program is free software; you can redistribute it and/or
+  modify it under the terms of the GNU General Public License as
+  published by the Free Software Foundation; either version 2 of the
+  License, or (at your option) any later version.
+
+  This program is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, see <http://www.gnu.org/licenses/>.
+
+  The GNU General Public License is contained in the file COPYING.
+*/
+
+#include "pub_core_basics_asm.h"
+
+#if defined(VGP_loongarch64_linux)
+
+#include "pub_core_dispatch_asm.h"
+#include "pub_core_transtab_asm.h"
+#include "libvex_guest_offsets.h"	/* for OFFSET_loongarch64_* */
+
+
+/*------------------------------------------------------------*/
+/*---                                                      ---*/
+/*--- The dispatch loop.  VG_(disp_run_translations) is    ---*/
+/*--- used to run all translations,                        ---*/
+/*--- including no-redir ones.                             ---*/
+/*---                                                      ---*/
+/*------------------------------------------------------------*/
+
+/*----------------------------------------------------*/
+/*--- Entry and preamble (set everything up)       ---*/
+/*----------------------------------------------------*/
+
+/* signature:
+void VG_(disp_run_translations)( UWord* two_words,
+                                 void*  guest_state,
+                                 Addr   host_addr );
+*/
+
+.text
+.globl VG_(disp_run_translations)
+VG_(disp_run_translations):
+   /* TODO */
+
+/*----------------------------------------------------*/
+/*--- Postamble and exit.                          ---*/
+/*----------------------------------------------------*/
+
+postamble:
+   /* TODO */
+
+/*----------------------------------------------------*/
+/*--- Continuation points                          ---*/
+/*----------------------------------------------------*/
+
+/* ------ Chain me to slow entry point ------ */
+.globl VG_(disp_cp_chain_me_to_slowEP)
+VG_(disp_cp_chain_me_to_slowEP):
+   /* TODO */
+
+/* ------ Chain me to fast entry point ------ */
+.globl VG_(disp_cp_chain_me_to_fastEP)
+VG_(disp_cp_chain_me_to_fastEP):
+   /* TODO */
+
+/* ------ Indirect but boring jump ------ */
+.globl VG_(disp_cp_xindir)
+VG_(disp_cp_xindir):
+   /* TODO */
+
+/* ------ Assisted jump ------ */
+.globl VG_(disp_cp_xassisted)
+VG_(disp_cp_xassisted):
+   /* TODO */
+
+/* ------ Event check failed ------ */
+.globl VG_(disp_cp_evcheck_fail)
+VG_(disp_cp_evcheck_fail):
+   /* TODO */
+
+.size VG_(disp_run_translations), .-VG_(disp_run_translations)
+
+#endif // defined(VGP_loongarch64_linux)
+
+/* Let the linker know we don't need an executable stack */
+MARK_STACK_NO_EXEC
+
+/*--------------------------------------------------------------------*/
+/*--- end                             dispatch-loongarch64-linux.S ---*/
+/*--------------------------------------------------------------------*/
diff --git a/coregrind/m_gdbserver/target.c b/coregrind/m_gdbserver/target.c
index 490276b6c..5e0a8ad24 100644
--- a/coregrind/m_gdbserver/target.c
+++ b/coregrind/m_gdbserver/target.c
@@ -867,6 +867,8 @@ void valgrind_initialize_target(void)
    mips64_init_architecture(&the_low_target);
 #elif defined(VGA_nanomips)
    nanomips_init_architecture(&the_low_target);
+#elif defined(VGA_loongarch64)
+   loongarch64_init_architecture(&the_low_target);
 #else
    #error "architecture missing in target.c valgrind_initialize_target"
 #endif
diff --git a/coregrind/m_gdbserver/valgrind-low-loongarch64.c b/coregrind/m_gdbserver/valgrind-low-loongarch64.c
new file mode 100644
index 000000000..9e5948d68
--- /dev/null
+++ b/coregrind/m_gdbserver/valgrind-low-loongarch64.c
@@ -0,0 +1,42 @@
+/* Low level interface to valgrind, for the remote server for GDB integrated
+   in valgrind.
+   Copyright (C) 2021
+   Free Software Foundation, Inc.
+
+   This file is part of VALGRIND.
+   It has been inspired from files from gdbserver in gdb 13.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.  */
+
+#include "server.h"
+#include "target.h"
+#include "regdef.h"
+#include "regcache.h"
+
+#include "pub_core_machine.h"
+#include "pub_core_debuginfo.h"
+#include "pub_core_threadstate.h"
+#include "pub_core_transtab.h"
+#include "pub_core_gdbserver.h"
+
+#include "valgrind_low.h"
+
+#include "libvex_guest_loongarch64.h"
+
+void loongarch64_init_architecture (struct valgrind_target_ops* target)
+{
+   /* TODO */
+}
diff --git a/coregrind/m_gdbserver/valgrind_low.h b/coregrind/m_gdbserver/valgrind_low.h
index c6c0bb63b..833f3612e 100644
--- a/coregrind/m_gdbserver/valgrind_low.h
+++ b/coregrind/m_gdbserver/valgrind_low.h
@@ -108,5 +108,6 @@ extern void s390x_init_architecture (struct valgrind_target_ops *target);
 extern void mips32_init_architecture (struct valgrind_target_ops *target);
 extern void mips64_init_architecture (struct valgrind_target_ops *target);
 extern void nanomips_init_architecture (struct valgrind_target_ops *target);
+extern void loongarch64_init_architecture (struct valgrind_target_ops *target);
 
 #endif
diff --git a/coregrind/m_initimg/initimg-linux.c b/coregrind/m_initimg/initimg-linux.c
index 4da9a8b97..c96af570b 100644
--- a/coregrind/m_initimg/initimg-linux.c
+++ b/coregrind/m_initimg/initimg-linux.c
@@ -909,7 +909,8 @@ Addr setup_client_stack( void*  init_sp,
             && !defined(VGP_ppc64le_linux) \
             && !defined(VGP_mips32_linux) && !defined(VGP_mips64_linux) \
             && !defined(VGP_nanomips_linux) \
-            && !defined(VGP_s390x_linux)
+            && !defined(VGP_s390x_linux) \
+            && !defined(VGP_loongarch64_linux)
          case AT_SYSINFO_EHDR: {
             /* Trash this, because we don't reproduce it */
             const NSegment* ehdrseg = VG_(am_find_nsegment)((Addr)auxv->u.a_ptr);
@@ -1340,6 +1341,9 @@ void VG_(ii_finalise_image)( IIFinaliseImageInfo iifii )
    arch->vex.guest_PC = iifii.initial_client_IP;
    arch->vex.guest_r31 = iifii.initial_client_SP;
 
+#  elif defined(VGP_loongarch64_linux)
+   /* TODO */
+
 #  else
 #    error Unknown platform
 #  endif
diff --git a/coregrind/m_libcassert.c b/coregrind/m_libcassert.c
index 35f37f88d..56a3e2000 100644
--- a/coregrind/m_libcassert.c
+++ b/coregrind/m_libcassert.c
@@ -264,6 +264,11 @@
         (srP)->misc.MIPS32.r31 = (UInt)ra;                \
         (srP)->misc.MIPS32.r28 = (UInt)gp;                \
       }
+#elif defined(VGP_loongarch64_linux)
+#  define GET_STARTREGS(srP)                              \
+   do {                                                   \
+      /* TODO */                                          \
+   } while (0)
 #else
 #  error Unknown platform
 #endif
diff --git a/coregrind/m_libcfile.c b/coregrind/m_libcfile.c
index e98de3e96..98b19ffad 100644
--- a/coregrind/m_libcfile.c
+++ b/coregrind/m_libcfile.c
@@ -252,7 +252,8 @@ Bool VG_(resolve_filemode) ( Int fd, Int * result )
 
 SysRes VG_(mknod) ( const HChar* pathname, Int mode, UWord dev )
 {
-#  if defined(VGP_arm64_linux) || defined(VGP_nanomips_linux)
+#  if defined(VGP_arm64_linux) || defined(VGP_nanomips_linux) \
+      || defined(VGP_loongarch64_linux)
    /* ARM64 wants to use __NR_mknodat rather than __NR_mknod. */
    SysRes res = VG_(do_syscall4)(__NR_mknodat,
                                  VKI_AT_FDCWD, (UWord)pathname, mode, dev);
@@ -278,7 +279,8 @@ SysRes VG_(mknod) ( const HChar* pathname, Int mode, UWord dev )
 
 SysRes VG_(open) ( const HChar* pathname, Int flags, Int mode )
 {
-#  if defined(VGP_arm64_linux) || defined(VGP_nanomips_linux)
+#  if defined(VGP_arm64_linux) || defined(VGP_nanomips_linux) \
+      || defined(VGP_loongarch64_linux)
    /* ARM64 wants to use __NR_openat rather than __NR_open. */
    SysRes res = VG_(do_syscall4)(__NR_openat,
                                  VKI_AT_FDCWD, (UWord)pathname, flags, mode);
@@ -372,7 +374,8 @@ Int VG_(pipe) ( Int fd[2] )
    } else {
       return -1;
    }
-#  elif defined(VGP_arm64_linux) || defined(VGP_nanomips_linux)
+#  elif defined(VGP_arm64_linux) || defined(VGP_nanomips_linux) \
+        || defined(VGP_loongarch64_linux)
    SysRes res = VG_(do_syscall2)(__NR_pipe2, (UWord)fd, 0);
    return sr_isError(res) ? -1 : 0;
 #  elif defined(VGO_linux)
@@ -719,7 +722,8 @@ SysRes VG_(dup) ( Int oldfd )
 
 SysRes VG_(dup2) ( Int oldfd, Int newfd )
 {
-#  if defined(VGP_arm64_linux) || defined(VGP_nanomips_linux)
+#  if defined(VGP_arm64_linux) || defined(VGP_nanomips_linux) \
+      || defined(VGP_loongarch64_linux)
    /* We only have dup3, that means we have to mimic dup2.
       The only real difference is when oldfd == newfd.
       dup3 always returns an error, but dup2 returns only an
@@ -761,7 +765,7 @@ Int VG_(rename) ( const HChar* old_name, const HChar* new_name )
 #  if defined(VGO_solaris) || defined(VGP_arm64_linux)
    SysRes res = VG_(do_syscall4)(__NR_renameat, VKI_AT_FDCWD, (UWord)old_name,
                                  VKI_AT_FDCWD, (UWord)new_name);
-#  elif defined(VGP_nanomips_linux)
+#  elif defined(VGP_nanomips_linux) || defined(VGP_loongarch64_linux)
    SysRes res = VG_(do_syscall5)(__NR_renameat2, VKI_AT_FDCWD, (UWord)old_name,
                                  VKI_AT_FDCWD, (UWord)new_name, 0);
 
@@ -775,7 +779,8 @@ Int VG_(rename) ( const HChar* old_name, const HChar* new_name )
 
 Int VG_(unlink) ( const HChar* file_name )
 {
-#  if defined(VGP_arm64_linux) || defined(VGP_nanomips_linux)
+#  if defined(VGP_arm64_linux) || defined(VGP_nanomips_linux) \
+      || defined(VGP_loongarch64_linux)
    SysRes res = VG_(do_syscall2)(__NR_unlinkat, VKI_AT_FDCWD,
                                                 (UWord)file_name);
 #  elif defined(VGO_linux) || defined(VGO_darwin) || defined(VGO_freebsd)
@@ -854,7 +859,8 @@ const HChar *VG_(get_startup_wd) ( void )
 SysRes VG_(poll) (struct vki_pollfd *fds, Int nfds, Int timeout)
 {
    SysRes res;
-#  if defined(VGP_arm64_linux)  || defined(VGP_nanomips_linux)
+#  if defined(VGP_arm64_linux)  || defined(VGP_nanomips_linux) \
+      || defined(VGP_loongarch64_linux)
    /* ARM64 wants to use __NR_ppoll rather than __NR_poll. */
    struct vki_timespec timeout_ts;
    if (timeout >= 0) {
@@ -899,7 +905,8 @@ SSizeT VG_(readlink) (const HChar* path, HChar* buf, SizeT bufsiz)
 {
    SysRes res;
    /* res = readlink( path, buf, bufsiz ); */
-#  if defined(VGP_arm64_linux) || defined(VGP_nanomips_linux)
+#  if defined(VGP_arm64_linux) || defined(VGP_nanomips_linux) \
+      || defined(VGP_loongarch64_linux)
    res = VG_(do_syscall4)(__NR_readlinkat, VKI_AT_FDCWD,
                                            (UWord)path, (UWord)buf, bufsiz);
 #  elif defined(VGO_linux) || defined(VGO_darwin) || defined(VGO_freebsd)
@@ -978,7 +985,8 @@ Int VG_(access) ( const HChar* path, Bool irusr, Bool iwusr, Bool ixusr )
    UWord w = (irusr ? VKI_R_OK : 0)
              | (iwusr ? VKI_W_OK : 0)
              | (ixusr ? VKI_X_OK : 0);
-#  if defined(VGP_arm64_linux) || defined(VGP_nanomips_linux)
+#  if defined(VGP_arm64_linux) || defined(VGP_nanomips_linux) \
+      || defined(VGP_loongarch64_linux)
    SysRes res = VG_(do_syscall3)(__NR_faccessat, VKI_AT_FDCWD, (UWord)path, w);
 #  elif defined(VGO_linux) || defined(VGO_darwin) || defined(VGO_freebsd)
    SysRes res = VG_(do_syscall2)(__NR_access, (UWord)path, w);
@@ -1124,7 +1132,8 @@ SysRes VG_(pread) ( Int fd, void* buf, Int count, OffT offset )
    return res;
 #  elif defined(VGP_amd64_linux) || defined(VGP_s390x_linux) \
       || defined(VGP_ppc64be_linux)  || defined(VGP_ppc64le_linux) \
-      || defined(VGP_mips64_linux) || defined(VGP_arm64_linux)
+      || defined(VGP_mips64_linux) || defined(VGP_arm64_linux) \
+      || defined(VGP_loongarch64_linux)
    res = VG_(do_syscall4)(__NR_pread64, fd, (UWord)buf, count, offset);
    return res;
 #  elif defined(VGP_amd64_freebsd)
@@ -1388,7 +1397,8 @@ Int VG_(socket) ( Int domain, Int type, Int protocol )
 
 #  elif defined(VGP_amd64_linux) || defined(VGP_arm_linux) \
         || defined(VGP_mips32_linux) || defined(VGP_mips64_linux) \
-        || defined(VGP_arm64_linux) || defined(VGP_nanomips_linux) || defined(VGO_freebsd)
+        || defined(VGP_arm64_linux) || defined(VGP_nanomips_linux) \
+        || defined(VGO_freebsd) || defined(VGP_loongarch64_linux)
    SysRes res;
    res = VG_(do_syscall3)(__NR_socket, domain, type, protocol );
    return sr_isError(res) ? -1 : sr_Res(res);
@@ -1443,7 +1453,8 @@ Int my_connect ( Int sockfd, struct vki_sockaddr_in* serv_addr, Int addrlen )
 
 #  elif defined(VGP_amd64_linux) || defined(VGP_arm_linux) \
         || defined(VGP_mips32_linux) || defined(VGP_mips64_linux) \
-        || defined(VGP_arm64_linux) || defined(VGP_nanomips_linux) || defined(VGO_freebsd)
+        || defined(VGP_arm64_linux) || defined(VGP_nanomips_linux) \
+        || defined(VGO_freebsd) || defined(VGP_loongarch64_linux)
    SysRes res;
    res = VG_(do_syscall3)(__NR_connect, sockfd, (UWord)serv_addr, addrlen);
    return sr_isError(res) ? -1 : sr_Res(res);
@@ -1490,7 +1501,8 @@ Int VG_(write_socket)( Int sd, const void *msg, Int count )
 
 #  elif defined(VGP_amd64_linux) || defined(VGP_arm_linux) \
         || defined(VGP_mips32_linux) || defined(VGP_mips64_linux) \
-        || defined(VGP_arm64_linux) || defined(VGP_nanomips_linux) || defined(VGO_freebsd)
+        || defined(VGP_arm64_linux) || defined(VGP_nanomips_linux) \
+        || defined(VGO_freebsd) || defined(VGP_loongarch64_linux)
    SysRes res;
    res = VG_(do_syscall6)(__NR_sendto, sd, (UWord)msg, 
                                        count, VKI_MSG_NOSIGNAL, 0,0);
@@ -1528,7 +1540,8 @@ Int VG_(getsockname) ( Int sd, struct vki_sockaddr *name, Int *namelen)
 #  elif defined(VGP_amd64_linux) || defined(VGP_arm_linux) \
         || defined(VGP_mips64_linux) || defined(VGP_arm64_linux) \
         || defined(VGP_nanomips_linux) || defined(VGO_freebsd) \
-        || defined(VGP_mips64_linux) || defined(VGP_arm64_linux)
+        || defined(VGP_mips64_linux) || defined(VGP_arm64_linux) \
+        || defined(VGP_loongarch64_linux)
    SysRes res;
    res = VG_(do_syscall3)( __NR_getsockname,
                            (UWord)sd, (UWord)name, (UWord)namelen );
@@ -1567,7 +1580,8 @@ Int VG_(getpeername) ( Int sd, struct vki_sockaddr *name, Int *namelen)
 
 #  elif defined(VGP_amd64_linux) || defined(VGP_arm_linux) \
         || defined(VGP_mips64_linux) || defined(VGP_arm64_linux) \
-        || defined(VGP_nanomips_linux) || defined(VGO_freebsd)
+        || defined(VGP_nanomips_linux) || defined(VGO_freebsd) \
+        || defined(VGP_loongarch64_linux)
    SysRes res;
    res = VG_(do_syscall3)( __NR_getpeername,
                            (UWord)sd, (UWord)name, (UWord)namelen );
@@ -1609,7 +1623,7 @@ Int VG_(getsockopt) ( Int sd, Int level, Int optname, void *optval,
 #  elif defined(VGP_amd64_linux) || defined(VGP_arm_linux) \
         || defined(VGP_mips32_linux) || defined(VGP_mips64_linux) \
         || defined(VGP_arm64_linux) || defined(VGP_nanomips_linux) \
-        || defined(VGO_freebsd)
+        || defined(VGO_freebsd) || defined(VGP_loongarch64_linux)
    SysRes res;
    res = VG_(do_syscall5)( __NR_getsockopt,
                            (UWord)sd, (UWord)level, (UWord)optname, 
@@ -1653,7 +1667,8 @@ Int VG_(setsockopt) ( Int sd, Int level, Int optname, void *optval,
 
 #  elif defined(VGP_amd64_linux) || defined(VGP_arm_linux) \
         || defined(VGP_mips32_linux) || defined(VGP_mips64_linux) \
-        || defined(VGP_arm64_linux) || defined(VGP_nanomips_linux)
+        || defined(VGP_arm64_linux) || defined(VGP_nanomips_linux) \
+        || defined(VGP_loongarch64_linux)
    SysRes res;
    res = VG_(do_syscall5)( __NR_setsockopt,
                            (UWord)sd, (UWord)level, (UWord)optname, 
diff --git a/coregrind/m_libcproc.c b/coregrind/m_libcproc.c
index b94cabcf1..2578efc43 100644
--- a/coregrind/m_libcproc.c
+++ b/coregrind/m_libcproc.c
@@ -698,7 +698,8 @@ Int VG_(gettid)(void)
        * the /proc/self link is pointing...
        */
 
-#     if defined(VGP_arm64_linux) || defined(VGP_nanomips_linux)
+#     if defined(VGP_arm64_linux) || defined(VGP_nanomips_linux) \
+         || defined(VGP_loongarch64_linux)
       res = VG_(do_syscall4)(__NR_readlinkat, VKI_AT_FDCWD,
                              (UWord)"/proc/self",
                              (UWord)pid, sizeof(pid));
@@ -753,7 +754,8 @@ Int VG_(getpid) ( void )
 Int VG_(getpgrp) ( void )
 {
    /* ASSUMES SYSCALL ALWAYS SUCCEEDS */
-#  if defined(VGP_arm64_linux) || defined(VGP_nanomips_linux)
+#  if defined(VGP_arm64_linux) || defined(VGP_nanomips_linux) \
+      || defined(VGP_loongarch64_linux)
    return sr_Res( VG_(do_syscall1)(__NR_getpgid, 0) );
 #  elif defined(VGO_linux) || defined(VGO_darwin) || defined(VGO_freebsd)
    return sr_Res( VG_(do_syscall0)(__NR_getpgrp) );
@@ -850,7 +852,7 @@ Int VG_(getgroups)( Int size, UInt* list )
         || defined(VGO_darwin) || defined(VGP_s390x_linux)    \
         || defined(VGP_mips32_linux) || defined(VGP_arm64_linux) \
         || defined(VGO_solaris) || defined(VGP_nanomips_linux) \
-        || defined(VGO_freebsd)
+        || defined(VGO_freebsd) || defined(VGP_loongarch64_linux)
    SysRes sres;
    sres = VG_(do_syscall2)(__NR_getgroups, size, (Addr)list);
    if (sr_isError(sres))
@@ -944,7 +946,8 @@ Int VG_(fork) ( void )
       fds[0] = fds[1] = -1;
    }
 
-#  if defined(VGP_arm64_linux) || defined(VGP_nanomips_linux)
+#  if defined(VGP_arm64_linux) || defined(VGP_nanomips_linux) \
+      || defined(VGP_loongarch64_linux)
    SysRes res;
    res = VG_(do_syscall5)(__NR_clone, VKI_SIGCHLD,
                           (UWord)NULL, (UWord)NULL, (UWord)NULL, (UWord)NULL);
diff --git a/coregrind/m_machine.c b/coregrind/m_machine.c
index 052b5d186..987255811 100644
--- a/coregrind/m_machine.c
+++ b/coregrind/m_machine.c
@@ -152,6 +152,8 @@ void VG_(get_UnwindStartRegs) ( /*OUT*/UnwindStartRegs* regs,
       = VG_(threads)[tid].arch.vex.guest_r31;
    regs->misc.MIPS64.r28
       = VG_(threads)[tid].arch.vex.guest_r28;
+#  elif defined(VGA_loongarch64)
+   /* TODO */
 #  else
 #    error "Unknown arch"
 #  endif
@@ -369,6 +371,39 @@ static void apply_to_GPs_of_tid(ThreadId tid, void (*f)(ThreadId,
    (*f)(tid, "x28", vex->guest_X28);
    (*f)(tid, "x29", vex->guest_X29);
    (*f)(tid, "x30", vex->guest_X30);
+#elif defined(VGA_loongarch64)
+   (*f)(tid, "r0" , vex->guest_R0 );
+   (*f)(tid, "r1" , vex->guest_R1 );
+   (*f)(tid, "r2" , vex->guest_R2 );
+   (*f)(tid, "r3" , vex->guest_R3 );
+   (*f)(tid, "r4" , vex->guest_R4 );
+   (*f)(tid, "r5" , vex->guest_R5 );
+   (*f)(tid, "r6" , vex->guest_R6 );
+   (*f)(tid, "r7" , vex->guest_R7 );
+   (*f)(tid, "r8" , vex->guest_R8 );
+   (*f)(tid, "r9" , vex->guest_R9 );
+   (*f)(tid, "r10", vex->guest_R10);
+   (*f)(tid, "r11", vex->guest_R11);
+   (*f)(tid, "r12", vex->guest_R12);
+   (*f)(tid, "r13", vex->guest_R13);
+   (*f)(tid, "r14", vex->guest_R14);
+   (*f)(tid, "r15", vex->guest_R15);
+   (*f)(tid, "r16", vex->guest_R16);
+   (*f)(tid, "r17", vex->guest_R17);
+   (*f)(tid, "r18", vex->guest_R18);
+   (*f)(tid, "r19", vex->guest_R19);
+   (*f)(tid, "r20", vex->guest_R20);
+   (*f)(tid, "r21", vex->guest_R21);
+   (*f)(tid, "r22", vex->guest_R22);
+   (*f)(tid, "r23", vex->guest_R23);
+   (*f)(tid, "r24", vex->guest_R24);
+   (*f)(tid, "r25", vex->guest_R25);
+   (*f)(tid, "r26", vex->guest_R26);
+   (*f)(tid, "r27", vex->guest_R27);
+   (*f)(tid, "r28", vex->guest_R28);
+   (*f)(tid, "r29", vex->guest_R29);
+   (*f)(tid, "r30", vex->guest_R30);
+   (*f)(tid, "r31", vex->guest_R31);
 #else
 #  error Unknown arch
 #endif
@@ -479,7 +514,7 @@ Int VG_(machine_arm_archlevel) = 4;
    testing, so we need a VG_MINIMAL_JMP_BUF. */
 #if defined(VGA_ppc32) || defined(VGA_ppc64be) || defined(VGA_ppc64le) \
     || defined(VGA_arm) || defined(VGA_s390x) || defined(VGA_mips32) \
-    || defined(VGA_mips64) || defined(VGA_arm64)
+    || defined(VGA_mips64) || defined(VGA_arm64) || defined(VGA_loongarch64)
 #include "pub_core_libcsetjmp.h"
 static VG_MINIMAL_JMP_BUF(env_unsup_insn);
 static void handler_unsup_insn ( Int x ) {
@@ -2227,6 +2262,13 @@ Bool VG_(machine_get_hwcaps)( void )
 
      return True;
    }
+
+#elif defined(VGA_loongarch64)
+   {
+      /* TODO */
+      return False;
+   }
+
 #else
 #  error "Unknown arch"
 #endif
@@ -2367,6 +2409,9 @@ Int VG_(machine_get_size_of_largest_guest_register) ( void )
 #  elif defined(VGA_mips64)
    return 8;
 
+#  elif defined(VGA_loongarch64)
+   return 8;
+
 #  else
 #    error "Unknown arch"
 #  endif
@@ -2383,7 +2428,7 @@ void* VG_(fnptr_to_fnentry)( void* f )
       || defined(VGP_s390x_linux) || defined(VGP_mips32_linux) \
       || defined(VGP_mips64_linux) || defined(VGP_arm64_linux) \
       || defined(VGP_x86_solaris) || defined(VGP_amd64_solaris) \
-      || defined(VGP_nanomips_linux)
+      || defined(VGP_nanomips_linux) || defined(VGP_loongarch64_linux)
    return f;
 #  elif defined(VGP_ppc64be_linux)
    /* ppc64-linux uses the AIX scheme, in which f is a pointer to a
diff --git a/coregrind/m_main.c b/coregrind/m_main.c
index 4316e625f..30eeb2133 100644
--- a/coregrind/m_main.c
+++ b/coregrind/m_main.c
@@ -2520,6 +2520,8 @@ static void final_tidyup(ThreadId tid)
    VG_TRACK(post_reg_write, Vg_CoreClientReq, tid,
             offsetof(VexGuestS390XState, guest_r2),
             sizeof(VG_(threads)[tid].arch.vex.guest_r2));
+#  elif defined(VGA_loongarch64)
+   /* TODO */
 #else
    I_die_here : architecture missing in m_main.c
 #endif
@@ -3048,6 +3050,15 @@ asm(
     ".set pop                                           \n\t"
 ".previous                                              \n\t"
 );
+#elif defined(VGP_loongarch64_linux)
+/* TODO */
+asm("                                                           \n\t"
+    ".text                                                      \n\t"
+    ".globl _start                                              \n\t"
+    ".type _start,@function                                     \n\t"
+    "_start:                                                    \n\t"
+    ".previous                                                  \n\t"
+);
 #else
 #  error "Unknown platform"
 #endif
@@ -3093,11 +3104,11 @@ void _start_in_C_linux ( UWord* pArgc )
 #  if defined(VGP_ppc32_linux) || defined(VGP_ppc64be_linux) \
       || defined(VGP_ppc64le_linux) || defined(VGP_arm64_linux) \
       || defined(VGP_mips32_linux)  || defined(VGP_mips64_linux) \
-      || defined(VGP_nanomips_linux)
+      || defined(VGP_nanomips_linux) || defined(VGP_loongarch64_linux)
    {
-      /* ppc32/ppc64, arm64, mips32/64 can be configured with different
-         page sizes. Determine this early. This is an ugly hack and really
-         should be moved into valgrind_main. */
+      /* ppc32/ppc64, arm64, mips32/64, loongarch64 can be configured with
+         different page sizes. Determine this early. This is an ugly hack
+         and really should be moved into valgrind_main. */
       UWord *sp = &pArgc[1+argc+1];
       while (*sp++ != 0)
          ;
diff --git a/coregrind/m_options.c b/coregrind/m_options.c
index 92ac3ad19..fbc2671b4 100644
--- a/coregrind/m_options.c
+++ b/coregrind/m_options.c
@@ -202,7 +202,8 @@ UInt   VG_(clo_unw_stack_scan_frames) = 5;
 VgSmc VG_(clo_smc_check) = Vg_SmcAllNonFile;
 #elif defined(VGA_ppc32) || defined(VGA_ppc64be) || defined(VGA_ppc64le) \
       || defined(VGA_arm) || defined(VGA_arm64) \
-      || defined(VGA_mips32) || defined(VGA_mips64) || defined(VGA_nanomips)
+      || defined(VGA_mips32) || defined(VGA_mips64) || defined(VGA_nanomips) \
+      || defined(VGA_loongarch64)
 VgSmc VG_(clo_smc_check) = Vg_SmcStack;
 #else
 #  error "Unknown arch"
diff --git a/coregrind/m_redir.c b/coregrind/m_redir.c
index 37c67f4c1..176e2673c 100644
--- a/coregrind/m_redir.c
+++ b/coregrind/m_redir.c
@@ -1668,6 +1668,9 @@ void VG_(redir_initialise) ( void )
       );
    }
 
+#elif defined(VGP_loongarch64_linux)
+   /* TODO */
+
 #  elif defined(VGP_x86_solaris)
    /* If we're using memcheck, use these intercepts right from
       the start, otherwise ld.so makes a lot of noise. */
diff --git a/coregrind/m_scheduler/scheduler.c b/coregrind/m_scheduler/scheduler.c
index a61320b21..3269806aa 100644
--- a/coregrind/m_scheduler/scheduler.c
+++ b/coregrind/m_scheduler/scheduler.c
@@ -1826,6 +1826,9 @@ void VG_(nuke_all_threads_except) ( ThreadId me, VgSchedReturnCode src )
 #elif defined(VGA_mips32) || defined(VGA_mips64) || defined(VGA_nanomips)
 #  define VG_CLREQ_ARGS       guest_r12
 #  define VG_CLREQ_RET        guest_r11
+#elif defined(VGA_loongarch64)
+#  define VG_CLREQ_ARGS       guest_R12
+#  define VG_CLREQ_RET        guest_R11
 #else
 #  error Unknown arch
 #endif
diff --git a/coregrind/m_sigframe/sigframe-loongarch64-linux.c b/coregrind/m_sigframe/sigframe-loongarch64-linux.c
new file mode 100644
index 000000000..ca0a9789a
--- /dev/null
+++ b/coregrind/m_sigframe/sigframe-loongarch64-linux.c
@@ -0,0 +1,99 @@
+
+/*--------------------------------------------------------------------*/
+/*--- Create/destroy signal delivery frames.                       ---*/
+/*---                             sigframe-loongarch64-linux.c     ---*/
+/*--------------------------------------------------------------------*/
+
+/*
+   This file is part of Valgrind, a dynamic binary instrumentation
+   framework.
+
+   Copyright (C) 2021-2022 Loongson Technology Corporation Limited
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, see <http://www.gnu.org/licenses/>.
+
+   The GNU General Public License is contained in the file COPYING.
+*/
+
+#if defined(VGP_loongarch64_linux)
+
+#include "pub_core_basics.h"
+#include "pub_core_vki.h"
+#include "pub_core_vkiscnums.h"
+#include "pub_core_threadstate.h"
+#include "pub_core_aspacemgr.h"
+#include "pub_core_libcbase.h"
+#include "pub_core_libcassert.h"
+#include "pub_core_libcprint.h"
+#include "pub_core_machine.h"
+#include "pub_core_options.h"
+#include "pub_core_sigframe.h"
+#include "pub_core_signals.h"
+#include "pub_core_tooliface.h"
+#include "pub_core_trampoline.h"
+#include "priv_sigframe.h"
+
+
+/*------------------------------------------------------------*/
+/*--- Signal frame layouts                                 ---*/
+/*------------------------------------------------------------*/
+
+struct vg_sig_private {
+   UInt magicPI;
+   UInt sigNo_private;
+   VexGuestLOONGARCH64State vex_shadow1;
+   VexGuestLOONGARCH64State vex_shadow2;
+};
+
+struct rt_sigframe {
+   struct vki_siginfo rs_info;
+   struct vki_ucontext rs_uctx;
+   struct vg_sig_private priv;
+};
+
+
+/*------------------------------------------------------------*/
+/*--- Creating signal frames                               ---*/
+/*------------------------------------------------------------*/
+
+/* EXPORTED */
+void VG_(sigframe_create) ( ThreadId tid,
+                            Bool on_altstack,
+                            Addr sp_top_of_frame,
+                            const vki_siginfo_t *siginfo,
+                            const struct vki_ucontext *siguc,
+                            void *handler,
+                            UInt flags,
+                            const vki_sigset_t *mask,
+                            void *restorer )
+{
+   /* TODO */
+}
+
+
+/*------------------------------------------------------------*/
+/*--- Destroying signal frames                             ---*/
+/*------------------------------------------------------------*/
+
+/* EXPORTED */
+void VG_(sigframe_destroy)( ThreadId tid, Bool isRT )
+{
+   /* TODO */
+}
+
+#endif /* defined(VGP_loongarch64_linux) */
+
+/*--------------------------------------------------------------------*/
+/*--- end                             sigframe-loongarch64-linux.c ---*/
+/*--------------------------------------------------------------------*/
diff --git a/coregrind/m_signals.c b/coregrind/m_signals.c
index 8162a101f..696319612 100644
--- a/coregrind/m_signals.c
+++ b/coregrind/m_signals.c
@@ -628,6 +628,20 @@ VgHashTable *ht_sigchld_ignore = NULL;
         (srP)->misc.MIPS32.r28 = (uc)->uc_mcontext.sc_regs[28]; \
       }
 
+#elif defined(VGP_loongarch64_linux)
+#  define VG_UCONTEXT_INSTR_PTR(uc)      0 /* TODO */
+#  define VG_UCONTEXT_STACK_PTR(uc)      0 /* TODO */
+#  define VG_UCONTEXT_FRAME_PTR(uc)      0 /* TODO */
+#  define VG_UCONTEXT_SYSCALL_NUM(uc)    0 /* TODO */
+#  define VG_UCONTEXT_SYSCALL_SYSRES(uc)                              \
+      /* TODO */                                                      \
+      VG_(mk_SysRes_loongarch64_linux)(0)
+
+#  define VG_UCONTEXT_TO_UnwindStartRegs(srP, uc)                     \
+      do {                                                            \
+         /* TODO */                                                   \
+      } while (0)
+
 #elif defined(VGP_x86_solaris)
 #  define VG_UCONTEXT_INSTR_PTR(uc)       ((Addr)(uc)->uc_mcontext.gregs[VKI_EIP])
 #  define VG_UCONTEXT_STACK_PTR(uc)       ((Addr)(uc)->uc_mcontext.gregs[VKI_UESP])
@@ -899,8 +913,10 @@ void calculate_SKSS_from_SCSS ( SKSS* dst )
       if (skss_handler != VKI_SIG_IGN && skss_handler != VKI_SIG_DFL)
          skss_flags |= VKI_SA_SIGINFO;
 
+#     if !defined(VGP_loongarch64_linux)
       /* use our own restorer */
       skss_flags |= VKI_SA_RESTORER;
+#     endif
 
       /* Create SKSS entry for this signal. */
       if (sig != VKI_SIGKILL && sig != VKI_SIGSTOP)
@@ -1052,6 +1068,15 @@ extern void my_sigreturn(void);
    "   li $t4, " #name "\n" \
    "   syscall[32]\n" \
    ".previous\n"
+
+#elif defined(VGP_loongarch64_linux)
+#  define _MY_SIGRETURN(name) \
+   ".text\n" \
+   "my_sigreturn:\n" \
+   "   li.w $a7, " #name "\n" \
+   "   syscall 0\n" \
+   ".previous\n"
+
 #elif defined(VGP_x86_solaris) || defined(VGP_amd64_solaris)
 /* Not used on Solaris. */
 #  define _MY_SIGRETURN(name) \
@@ -1111,7 +1136,8 @@ static void handle_SCSS_change ( Bool force_update )
       ksa.sa_flags    = skss.skss_per_sig[sig].skss_flags;
 #     if !defined(VGP_ppc32_linux) && \
          !defined(VGP_x86_darwin) && !defined(VGP_amd64_darwin) && \
-         !defined(VGP_mips32_linux) && !defined(VGO_solaris) && !defined(VGO_freebsd)
+         !defined(VGP_mips32_linux) && !defined(VGO_solaris) && \
+         !defined(VGO_freebsd) && !defined(VGP_loongarch64_linux)
       ksa.sa_restorer = my_sigreturn;
 #     endif
       /* Re above ifdef (also the assertion below), PaulM says:
@@ -1159,7 +1185,7 @@ static void handle_SCSS_change ( Bool force_update )
             !defined(VGP_x86_darwin) && !defined(VGP_amd64_darwin) && \
             !defined(VGP_mips32_linux) && !defined(VGP_mips64_linux) && \
             !defined(VGP_nanomips_linux) && !defined(VGO_solaris) && \
-            !defined(VGO_freebsd)
+            !defined(VGO_freebsd) && !defined(VGP_loongarch64_linux)
          vg_assert(ksa_old.sa_restorer == my_sigreturn);
 #        endif
          VG_(sigaddset)( &ksa_old.sa_mask, VKI_SIGKILL );
@@ -1280,7 +1306,7 @@ SysRes VG_(do_sys_sigaction) ( Int signo,
       old_act->sa_flags    = scss.scss_per_sig[signo].scss_flags;
       old_act->sa_mask     = scss.scss_per_sig[signo].scss_mask;
 #     if !defined(VGO_darwin) && !defined(VGO_freebsd) && \
-         !defined(VGO_solaris)
+         !defined(VGO_solaris) && !defined(VGP_loongarch64_linux)
       old_act->sa_restorer = scss.scss_per_sig[signo].scss_restorer;
 #     endif
    }
@@ -1293,7 +1319,7 @@ SysRes VG_(do_sys_sigaction) ( Int signo,
 
       scss.scss_per_sig[signo].scss_restorer = NULL;
 #     if !defined(VGO_darwin) && !defined(VGO_freebsd) && \
-         !defined(VGO_solaris)
+         !defined(VGO_solaris) && !defined(VGP_loongarch64_linux)
       scss.scss_per_sig[signo].scss_restorer = new_act->sa_restorer;
 #     endif
 
@@ -1653,7 +1679,7 @@ void VG_(kill_self)(Int sigNo)
    sa.ksa_handler = VKI_SIG_DFL;
    sa.sa_flags = 0;
 #  if !defined(VGO_darwin) && !defined(VGO_freebsd) && \
-      !defined(VGO_solaris)
+      !defined(VGO_solaris) && !defined(VGP_loongarch64_linux)
    sa.sa_restorer = 0;
 #  endif
    VG_(sigemptyset)(&sa.sa_mask);
@@ -2296,8 +2322,9 @@ void VG_(synth_sigtrap)(ThreadId tid)
 // Synthesise a SIGFPE.
 void VG_(synth_sigfpe)(ThreadId tid, UInt code)
 {
-// Only tested on mips32, mips64, s390x and nanomips.
-#if !defined(VGA_mips32) && !defined(VGA_mips64) && !defined(VGA_s390x) && !defined(VGA_nanomips)
+// Only tested on mips32, mips64, s390x, nanomips and loongarch64.
+#if !defined(VGA_mips32) && !defined(VGA_mips64) && !defined(VGA_s390x) \
+    && !defined(VGA_nanomips) && !defined(VGA_loongarch64)
    vg_assert(0);
 #else
    vki_siginfo_t info;
@@ -3067,7 +3094,7 @@ void pp_ksigaction ( vki_sigaction_toK_t* sa )
                sa->ksa_handler, 
                (UInt)sa->sa_flags, 
 #              if !defined(VGO_darwin) && !defined(VGO_freebsd) && \
-                  !defined(VGO_solaris)
+                  !defined(VGO_solaris) && !defined(VGP_loongarch64_linux)
                   sa->sa_restorer
 #              else
                   (void*)0
@@ -3090,7 +3117,7 @@ void VG_(set_default_handler)(Int signo)
    sa.ksa_handler = VKI_SIG_DFL;
    sa.sa_flags = 0;
 #  if !defined(VGO_darwin) && !defined(VGO_freebsd) && \
-      !defined(VGO_solaris)
+      !defined(VGO_solaris) && !defined(VGP_loongarch64_linux)
    sa.sa_restorer = 0;
 #  endif
    VG_(sigemptyset)(&sa.sa_mask);
@@ -3212,7 +3239,7 @@ void VG_(sigstartup_actions) ( void )
 	 tsa.ksa_handler = (void *)sync_signalhandler;
 	 tsa.sa_flags = VKI_SA_SIGINFO;
 #        if !defined(VGO_darwin) && !defined(VGO_freebsd) && \
-            !defined(VGO_solaris)
+            !defined(VGO_solaris) && !defined(VGP_loongarch64_linux)
 	 tsa.sa_restorer = 0;
 #        endif
 	 VG_(sigfillset)(&tsa.sa_mask);
@@ -3240,7 +3267,7 @@ void VG_(sigstartup_actions) ( void )
 
       scss.scss_per_sig[i].scss_restorer = NULL;
 #     if !defined(VGO_darwin) && !defined(VGO_freebsd) && \
-         !defined(VGO_solaris)
+         !defined(VGO_solaris) && !defined(VGP_loongarch64_linux)
       scss.scss_per_sig[i].scss_restorer = sa.sa_restorer;
 #     endif
 
diff --git a/coregrind/m_stacktrace.c b/coregrind/m_stacktrace.c
index 308bebdd8..bd8356dcf 100644
--- a/coregrind/m_stacktrace.c
+++ b/coregrind/m_stacktrace.c
@@ -1502,6 +1502,20 @@ UInt VG_(get_StackTrace_wrk) ( ThreadId tid_if_known,
 
 #endif
 
+/* ---------------------- loongarch64 ----------------------- */
+#if defined(VGP_loongarch64_linux)
+UInt VG_(get_StackTrace_wrk) ( ThreadId tid_if_known,
+                               /*OUT*/Addr* ips, UInt max_n_ips,
+                               /*OUT*/Addr* sps, /*OUT*/Addr* fps,
+                               const UnwindStartRegs* startRegs,
+                               Addr fp_max_orig )
+{
+   /* TODO */
+   return 0;
+}
+
+#endif
+
 /*------------------------------------------------------------*/
 /*---                                                      ---*/
 /*--- END platform-dependent unwinder worker functions     ---*/
diff --git a/coregrind/m_syscall.c b/coregrind/m_syscall.c
index 1e49ed412..8e3a00f88 100644
--- a/coregrind/m_syscall.c
+++ b/coregrind/m_syscall.c
@@ -204,6 +204,12 @@ SysRes VG_(mk_SysRes_arm64_linux) ( Long val ) {
    return res;
 }
 
+SysRes VG_(mk_SysRes_loongarch64_linux) ( UWord val ) {
+   /* TODO */
+   SysRes res;
+   return res;
+}
+
 /* Generic constructors. */
 SysRes VG_(mk_SysRes_Success) ( UWord res ) {
    SysRes r;
@@ -1034,6 +1040,20 @@ asm (
    ".previous                              \n\t"
 );
 
+#elif defined(VGP_loongarch64_linux)
+extern UWord do_syscall_WRK (UWord a1, UWord a2, UWord a3, /* $a0, $a1, $a2 */
+                             UWord a4, UWord a5, UWord a6, /* $a3, $a4, $a5 */
+                             UWord syscall_no);            /* $a6 */
+/* TODO */
+asm (
+   ".text                                  \n\t"
+   ".globl do_syscall_WRK                  \n\t"
+   ".type  do_syscall_WRK, @function       \n\t"
+   "do_syscall_WRK:                        \n\t"
+   ".size do_syscall_WRK, .-do_syscall_WRK \n\t"
+   ".previous                              \n\t"
+);
+
 #elif defined(VGP_x86_solaris)
 
 extern ULong
@@ -1274,6 +1294,10 @@ SysRes VG_(do_syscall) ( UWord sysno, RegWord a1, RegWord a2, RegWord a3,
    do_syscall_WRK(a1, a2, a3, a4, a5, a6, sysno, &reg_a0);
    return VG_(mk_SysRes_nanomips_linux)(reg_a0);
 
+#elif defined(VGP_loongarch64_linux)
+   /* TODO */
+   return VG_(mk_SysRes_loongarch64_linux)(0);
+
 #  elif defined(VGP_x86_solaris)
    UInt val, val2, err = False;
    Bool restart;
diff --git a/coregrind/m_syswrap/priv_syswrap-linux.h b/coregrind/m_syswrap/priv_syswrap-linux.h
index 4f8506947..16542f575 100644
--- a/coregrind/m_syswrap/priv_syswrap-linux.h
+++ b/coregrind/m_syswrap/priv_syswrap-linux.h
@@ -505,6 +505,13 @@ extern UInt do_syscall_clone_nanomips_linux ( Word (*fn) (void *),  /* a0 - 4 */
                                               Int*  child_tid,      /* a4 - 8 */
                                               Int*  parent_tid,     /* a5 - 9 */
                                               void* tls_ptr);       /* a6 - 10 */
+extern UInt do_syscall_clone_loongarch64_linux ( Word (*fn) (void *), /* a0 */
+                                                 void* stack,         /* a1 */
+                                                 Int   flags,         /* a2 */
+                                                 void* arg,           /* a3 */
+                                                 Int*  child_tid,     /* a4 */
+                                                 Int*  parent_tid,    /* a5 */
+                                                 void* tls_ptr);      /* a6 */
 #endif   // __PRIV_SYSWRAP_LINUX_H
 
 /*--------------------------------------------------------------------*/
diff --git a/coregrind/m_syswrap/priv_types_n_macros.h b/coregrind/m_syswrap/priv_types_n_macros.h
index dd241839a..11a9d5e1b 100644
--- a/coregrind/m_syswrap/priv_types_n_macros.h
+++ b/coregrind/m_syswrap/priv_types_n_macros.h
@@ -94,7 +94,8 @@ typedef
          || defined(VGP_ppc32_linux) \
          || defined(VGP_arm_linux) || defined(VGP_s390x_linux) \
          || defined(VGP_arm64_linux) \
-         || defined(VGP_nanomips_linux)
+         || defined(VGP_nanomips_linux) \
+         || defined(VGP_loongarch64_linux)
       Int o_arg1;
       Int o_arg2;
       Int o_arg3;
diff --git a/coregrind/m_syswrap/syscall-loongarch64-linux.S b/coregrind/m_syswrap/syscall-loongarch64-linux.S
new file mode 100644
index 000000000..9cee32e21
--- /dev/null
+++ b/coregrind/m_syswrap/syscall-loongarch64-linux.S
@@ -0,0 +1,102 @@
+
+/*--------------------------------------------------------------------*/
+/*--- Support for doing system calls.  syscall-loongarch64-linux.S ---*/
+/*--------------------------------------------------------------------*/
+
+/*
+   This file is part of Valgrind, a dynamic binary instrumentation
+   framework.
+
+   Copyright (C) 2021-2022 Loongson Technology Corporation Limited
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, see <http://www.gnu.org/licenses/>.
+
+   The GNU General Public License is contained in the file COPYING.
+*/
+
+#include "pub_core_basics_asm.h"
+
+#if defined(VGP_loongarch64_linux)
+
+#include "pub_core_vkiscnums_asm.h"
+#include "libvex_guest_offsets.h"
+
+/*----------------------------------------------------------------*/
+/*
+   Perform a syscall for the client. This will run a syscall
+   with the client's specific per-thread signal mask.
+
+   The structure of this function is such that, if the syscall is
+   interrupted by a signal, we can determine exactly what
+   execution state we were in with respect to the execution of
+   the syscall by examining the value of PC in the signal
+   handler. This means that we can always do the appropriate
+   thing to precisely emulate the kernel's signal/syscall
+   interactions.
+
+   The syscall number is taken from the argument, even though it
+   should also be in guest_state->guest_R11. The syscall result
+   is written back to guest_state->guest_R4 on completion.
+
+   VG_(fixup_guest_state_after_syscall_interrupted) does the
+   thread state fixup in the case where we were interrupted by a
+   signal.
+
+   Prototype:
+
+   UWord ML_(do_syscall_for_client_WRK)(
+             Int syscallno,                 // $r4 - a0
+             void* guest_state,             // $r5 - a1
+             const vki_sigset_t *sysmask,   // $r6 - a2
+             const vki_sigset_t *postmask,  // $r7 - a3
+             Int nsigwords)                 // $r8 - a4
+*/
+
+/* from vki-loongarch64-linux.h */
+#define VKI_SIG_SETMASK 2
+
+.globl ML_(do_syscall_for_client_WRK)
+ML_(do_syscall_for_client_WRK):
+
+   /* TODO */
+1:
+2:
+3:
+4:
+5:
+
+.section .rodata
+/* export the ranges so that
+   VG_(fixup_guest_state_after_syscall_interrupted) can do the
+   right thing */
+
+.globl ML_(blksys_setup)
+.globl ML_(blksys_restart)
+.globl ML_(blksys_complete)
+.globl ML_(blksys_committed)
+.globl ML_(blksys_finished)
+ML_(blksys_setup):      .quad 1b
+ML_(blksys_restart):    .quad 2b
+ML_(blksys_complete):   .quad 3b
+ML_(blksys_committed):  .quad 4b
+ML_(blksys_finished):   .quad 5b
+
+#endif // defined(VGP_loongarch64_linux)
+
+/* Let the linker know we don't need an executable stack */
+MARK_STACK_NO_EXEC
+
+/*--------------------------------------------------------------------*/
+/*--- end                              syscall-loongarch64-linux.S ---*/
+/*--------------------------------------------------------------------*/
diff --git a/coregrind/m_syswrap/syswrap-generic.c b/coregrind/m_syswrap/syswrap-generic.c
index efdae60e1..88b0593cd 100644
--- a/coregrind/m_syswrap/syswrap-generic.c
+++ b/coregrind/m_syswrap/syswrap-generic.c
@@ -3439,7 +3439,7 @@ POST(sys_newfstat)
 #endif
 
 #if !defined(VGO_solaris) && !defined(VGP_arm64_linux) && \
-    !defined(VGP_nanomips_linux)
+    !defined(VGP_nanomips_linux) && !defined(VGP_loongarch64_linux)
 static vki_sigset_t fork_saved_mask;
 
 // In Linux, the sys_fork() function varies across architectures, but we
diff --git a/coregrind/m_syswrap/syswrap-linux.c b/coregrind/m_syswrap/syswrap-linux.c
index bb87c90ba..18d5f9723 100644
--- a/coregrind/m_syswrap/syswrap-linux.c
+++ b/coregrind/m_syswrap/syswrap-linux.c
@@ -310,6 +310,8 @@ static void run_a_thread_NORETURN ( Word tidW )
          : "r" (VgTs_Empty), "n" (__NR_exit), "m" (tst->os_state.exitcode)
          : "memory" , "$t4", "$a0"
       );
+#elif defined(VGP_loongarch64_linux)
+      /* TODO */
 #else
 # error Unknown platform
 #endif
@@ -535,6 +537,8 @@ static SysRes clone_new_thread ( Word (*fn)(void *),
       (ML_(start_thread_NORETURN), stack, flags, ctst,
        child_tidptr, parent_tidptr, NULL);
    res = VG_ (mk_SysRes_nanomips_linux) (ret);
+#elif defined(VGP_loongarch64_linux)
+   /* TODO */
 #else
 # error Unknown platform
 #endif
@@ -597,6 +601,8 @@ static SysRes setup_child_tls (ThreadId ctid, Addr tlsaddr)
 #elif defined(VGP_mips32_linux) || defined(VGP_nanomips_linux)
    ctst->arch.vex.guest_ULR = tlsaddr;
    ctst->arch.vex.guest_r27 = tlsaddr;
+#elif defined(VGP_loongarch64_linux)
+   /* TODO */
 #else
 # error Unknown platform
 #endif
@@ -755,7 +761,7 @@ static SysRes ML_(do_fork_clone) ( ThreadId tid, UInt flags,
     || defined(VGP_ppc64be_linux) || defined(VGP_ppc64le_linux)	\
     || defined(VGP_arm_linux) || defined(VGP_mips32_linux) \
     || defined(VGP_mips64_linux) || defined(VGP_arm64_linux) \
-    || defined(VGP_nanomips_linux)
+    || defined(VGP_nanomips_linux) || defined(VGP_loongarch64_linux)
    res = VG_(do_syscall5)( __NR_clone, flags, 
                            (UWord)NULL, (UWord)parent_tidptr, 
                            (UWord)NULL, (UWord)child_tidptr );
@@ -828,7 +834,8 @@ PRE(sys_clone)
 #define PRA_CHILD_TIDPTR PRA5
 #define ARG_TLS          ARG4
 #define PRA_TLS          PRA4
-#elif defined(VGP_amd64_linux) || defined(VGP_s390x_linux)
+#elif defined(VGP_amd64_linux) || defined(VGP_s390x_linux) \
+      || defined(VGP_loongarch64_linux)
 #define ARG_CHILD_TIDPTR ARG4
 #define PRA_CHILD_TIDPTR PRA4
 #define ARG_TLS          ARG5
@@ -4314,9 +4321,11 @@ PRE(sys_sigaction)
       PRE_MEM_READ( "sigaction(act->sa_handler)", (Addr)&sa->ksa_handler, sizeof(sa->ksa_handler));
       PRE_MEM_READ( "sigaction(act->sa_mask)", (Addr)&sa->sa_mask, sizeof(sa->sa_mask));
       PRE_MEM_READ( "sigaction(act->sa_flags)", (Addr)&sa->sa_flags, sizeof(sa->sa_flags));
+#if !defined(VGP_loongarch64_linux)
       if (ML_(safe_to_deref)(sa,sizeof(struct vki_old_sigaction))
           && (sa->sa_flags & VKI_SA_RESTORER))
          PRE_MEM_READ( "sigaction(act->sa_restorer)", (Addr)&sa->sa_restorer, sizeof(sa->sa_restorer));
+#endif
    }
 
    if (ARG3 != 0) {
@@ -4346,7 +4355,9 @@ PRE(sys_sigaction)
 
          new.ksa_handler = oldnew->ksa_handler;
          new.sa_flags = oldnew->sa_flags;
+#if !defined(VGP_loongarch64_linux)
          new.sa_restorer = oldnew->sa_restorer;
+#endif
          convert_sigset_to_rt(&oldnew->sa_mask, &new.sa_mask);
          newp = &new;
       }
@@ -4359,7 +4370,9 @@ PRE(sys_sigaction)
 
          oldold->ksa_handler = oldp->ksa_handler;
          oldold->sa_flags = oldp->sa_flags;
+#if !defined(VGP_loongarch64_linux)
          oldold->sa_restorer = oldp->sa_restorer;
+#endif
          oldold->sa_mask = oldp->sa_mask.sig[0];
       }
   }
@@ -4432,10 +4445,13 @@ PRE(sys_rt_sigaction)
       PRE_MEM_READ( "rt_sigaction(act->sa_handler)", (Addr)&sa->ksa_handler, sizeof(sa->ksa_handler));
       PRE_MEM_READ( "rt_sigaction(act->sa_mask)", (Addr)&sa->sa_mask, sizeof(sa->sa_mask));
       PRE_MEM_READ( "rt_sigaction(act->sa_flags)", (Addr)&sa->sa_flags, sizeof(sa->sa_flags));
+#if !defined(VGP_loongarch64_linux)
       if (ML_(safe_to_deref)(sa,sizeof(vki_sigaction_toK_t))
           && (sa->sa_flags & VKI_SA_RESTORER))
          PRE_MEM_READ( "rt_sigaction(act->sa_restorer)", (Addr)&sa->sa_restorer, sizeof(sa->sa_restorer));
+#endif
    }
+
    if (ARG3 != 0)
       PRE_MEM_WRITE( "rt_sigaction(oldact)", ARG3, sizeof(vki_sigaction_fromK_t));
 
@@ -6787,7 +6803,8 @@ POST(sys_lookup_dcookie)
 #endif
 
 #if defined(VGP_amd64_linux) || defined(VGP_s390x_linux)        \
-      || defined(VGP_arm64_linux) || defined(VGP_nanomips_linux)
+      || defined(VGP_arm64_linux) || defined(VGP_nanomips_linux) \
+      || defined(VGP_loongarch64_linux)
 PRE(sys_lookup_dcookie)
 {
    *flags |= SfMayBlock;
diff --git a/coregrind/m_syswrap/syswrap-loongarch64-linux.c b/coregrind/m_syswrap/syswrap-loongarch64-linux.c
new file mode 100644
index 000000000..4766b83c6
--- /dev/null
+++ b/coregrind/m_syswrap/syswrap-loongarch64-linux.c
@@ -0,0 +1,137 @@
+
+/*---------------------------------------------------------------------*/
+/*--- Platform-specific syscalls stuff. syswrap-loongarch64-linux.c ---*/
+/*---------------------------------------------------------------------*/
+
+/*
+   This file is part of Valgrind, a dynamic binary instrumentation
+   framework.
+
+   Copyright (C) 2021-2022 Loongson Technology Corporation Limited
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, see <http://www.gnu.org/licenses/>.
+
+   The GNU General Public License is contained in the file COPYING.
+*/
+
+#if defined(VGP_loongarch64_linux)
+
+#include "pub_core_basics.h"
+#include "pub_core_vki.h"
+#include "pub_core_vkiscnums.h"
+#include "pub_core_threadstate.h"
+#include "pub_core_aspacemgr.h"
+#include "pub_core_libcbase.h"
+#include "pub_core_libcassert.h"
+#include "pub_core_libcprint.h"
+#include "pub_core_libcsignal.h"
+#include "pub_core_options.h"
+#include "pub_core_scheduler.h"
+#include "pub_core_sigframe.h"      // For VG_(sigframe_destroy)()
+#include "pub_core_syscall.h"
+#include "pub_core_syswrap.h"
+#include "pub_core_tooliface.h"
+
+#include "priv_types_n_macros.h"
+#include "priv_syswrap-generic.h"   /* for decls of generic wrappers */
+#include "priv_syswrap-linux.h"     /* for decls of linux-ish wrappers */
+
+
+/* ---------------------------------------------------------------------
+   clone() handling
+   ------------------------------------------------------------------ */
+
+/* Call f(arg1), but first switch stacks, using 'stack' as the new
+   stack, and use 'retaddr' as f's return-to address.  Also, clear all
+   the integer registers before entering f. */
+__attribute__((noreturn))
+void ML_(call_on_new_stack_0_1) ( Addr stack,
+                                  Addr retaddr,
+                                  void (*f) (Word),
+                                  Word arg1 );
+/* TODO */
+asm (
+".text\n"
+".globl vgModuleLocal_call_on_new_stack_0_1 \n\t"
+"vgModuleLocal_call_on_new_stack_0_1:       \n\t"
+".previous                                  \n\t"
+);
+
+/*
+   Perform a clone system call.  clone is strange because it has
+   fork()-like return-twice semantics, so it needs special
+   handling here.
+
+   Upon entry, we have:
+
+      Word (*fn)(void*)  in a0
+      void*  child_stack in a1
+      int    flags       in a2
+      void*  arg         in a3
+      pid_t* child_tid   in a4
+      pid_t* parent_tid  in a5
+      void*  tls_ptr     in a6
+
+	System call requires:
+
+      int           $__NR_clone   in a7
+      unsigned long clone_flags   in a0
+      unsigned long newsp         in a1
+		int*          parent_tidptr in a2
+		int*          child_tidptr  in a3
+		unsigned long tls           in a4
+*/
+
+// See priv_syswrap-linux.h for arg profile.
+/* TODO */
+asm(
+".text                                     \n\t"
+".globl do_syscall_clone_loongarch64_linux \n\t"
+"do_syscall_clone_loongarch64_linux:       \n\t"
+".previous                                 \n\t"
+);
+
+
+/* ---------------------------------------------------------------------
+   More thread stuff
+   ------------------------------------------------------------------ */
+
+// loongarch64 doesn't have any architecture specific thread stuff that
+// needs to be cleaned up
+void VG_(cleanup_thread) ( ThreadArchState* arch )
+{
+}
+
+/* ---------------------------------------------------------------------
+   PRE/POST wrappers for loongarch64/Linux-specific syscalls
+   ------------------------------------------------------------------ */
+
+/* TODO */
+
+
+/* ---------------------------------------------------------------------
+   The loongarch64/Linux syscall table
+   ------------------------------------------------------------------ */
+
+SyscallTableEntry* ML_(get_linux_syscall_entry) ( UInt sysno )
+{
+   /* TODO */
+   return NULL;
+}
+
+#endif  /* defined(VGP_loongarch64_linux) */
+
+/*--------------------------------------------------------------------*/
+/*--- end                              syswrap-loongarch64-linux.c ---*/
+/*--------------------------------------------------------------------*/
diff --git a/coregrind/m_syswrap/syswrap-main.c b/coregrind/m_syswrap/syswrap-main.c
index abd8472e9..9b269f072 100644
--- a/coregrind/m_syswrap/syswrap-main.c
+++ b/coregrind/m_syswrap/syswrap-main.c
@@ -708,6 +708,10 @@ void getSyscallArgsFromGuestState ( /*OUT*/SyscallArgs*       canonical,
    canonical->arg6  = gst->guest_r9;    // a5
    canonical->arg7  = gst->guest_r10;   // a6
    canonical->arg8  = gst->guest_r11;   // a7
+
+#elif defined(VGP_loongarch64_linux)
+   /* TODO */
+
 #elif defined(VGP_x86_darwin)
    VexGuestX86State* gst = (VexGuestX86State*)gst_vanilla;
    UWord *stack = (UWord *)gst->guest_ESP;
@@ -1131,6 +1135,9 @@ void putSyscallArgsIntoGuestState ( /*IN*/ SyscallArgs*       canonical,
    gst->guest_r10 = canonical->arg7;
    gst->guest_r11 = canonical->arg8;
 
+#elif defined(VGP_loongarch64_linux)
+   /* TODO */
+
 #elif defined(VGP_x86_solaris)
    VexGuestX86State* gst = (VexGuestX86State*)gst_vanilla;
    UWord *stack = (UWord *)gst->guest_ESP;
@@ -1245,6 +1252,10 @@ void getSyscallStatusFromGuestState ( /*OUT*/SyscallStatus*     canonical,
    RegWord  a0 = gst->guest_r4;    // a0
    canonical->sres = VG_(mk_SysRes_nanomips_linux)(a0);
    canonical->what = SsComplete;
+
+#  elif defined(VGP_loongarch64_linux)
+   /* TODO */
+
 #  elif defined(VGP_amd64_freebsd)
    /* duplicates logic in m_signals.VG_UCONTEXT_SYSCALL_SYSRES */
    VexGuestAMD64State* gst = (VexGuestAMD64State*)gst_vanilla;
@@ -1611,6 +1622,9 @@ void putSyscallStatusIntoGuestState ( /*IN*/ ThreadId tid,
    VG_TRACK( post_reg_write, Vg_CoreSysCall, tid,
              OFFSET_mips32_r4, sizeof(UWord) );
 
+#  elif defined(VGP_loongarch64_linux)
+   /* TODO */
+
 #  elif defined(VGP_x86_solaris)
    VexGuestX86State* gst = (VexGuestX86State*)gst_vanilla;
    SysRes sres = canonical->sres;
@@ -1860,6 +1874,9 @@ void getSyscallArgLayout ( /*OUT*/SyscallArgLayout* layout )
    layout->s_arg7   = sizeof(UWord) * 1;
    layout->s_arg8   = sizeof(UWord) * 2;
 
+#elif defined(VGP_loongarch64_linux)
+   /* TODO */
+
 #else
 #  error "getSyscallLayout: unknown arch"
 #endif
@@ -2904,6 +2921,10 @@ void ML_(fixup_guest_state_to_restart_syscall) ( ThreadArchState* arch )
          arch->vex.guest_PC -= 2;
       }
    }
+
+#elif defined(VGP_loongarch64_linux)
+   /* TODO */
+
 #elif defined(VGP_x86_solaris)
    arch->vex.guest_EIP -= 2;   // sizeof(int $0x91) or sizeof(syscall)
 
diff --git a/coregrind/m_trampoline.S b/coregrind/m_trampoline.S
index da9697232..5679e504b 100644
--- a/coregrind/m_trampoline.S
+++ b/coregrind/m_trampoline.S
@@ -1520,6 +1520,39 @@ VG_(trampoline_stuff_end):
 #	undef UD2_1024
 #	undef UD2_PAGE
 
+/*------------------- loongarch64-linux -------------------*/
+#else
+#if defined(VGP_loongarch64_linux)
+
+.global VG_(trampoline_stuff_start)
+VG_(trampoline_stuff_start):
+
+.global VG_(loongarch64_linux_SUBST_FOR_rt_sigreturn)
+VG_(loongarch64_linux_SUBST_FOR_rt_sigreturn):
+        li.w $a7, __NR_rt_sigreturn
+        syscall 0
+        .long 0 /*illegal insn*/
+
+/* There's no particular reason that this needs to be handwritten
+   assembly, but since that's what this file contains, here's a
+   simple index() and strlen() implementations.
+*/
+
+.global VG_(loongarch64_linux_REDIR_FOR_index)
+.type   VG_(loongarch64_linux_REDIR_FOR_index), @function
+VG_(loongarch64_linux_REDIR_FOR_index):
+   /* TODO */
+.size VG_(loongarch64_linux_REDIR_FOR_index), .-VG_(loongarch64_linux_REDIR_FOR_index)
+
+.global VG_(loongarch64_linux_REDIR_FOR_strlen)
+.type   VG_(loongarch64_linux_REDIR_FOR_strlen), @function
+VG_(loongarch64_linux_REDIR_FOR_strlen):
+   /* TODO */
+.size VG_(loongarch64_linux_REDIR_FOR_strlen), .-VG_(loongarch64_linux_REDIR_FOR_strlen)
+
+.global VG_(trampoline_stuff_end)
+VG_(trampoline_stuff_end):
+
 /*---------------- x86-solaris ----------------*/
 #else
 #if defined(VGP_x86_solaris)
@@ -1719,6 +1752,7 @@ VG_(trampoline_stuff_end):
 #endif
 #endif
 #endif
+#endif
 
 /* Let the linker know we don't need an executable stack */
 MARK_STACK_NO_EXEC
diff --git a/coregrind/m_vki.c b/coregrind/m_vki.c
index 0cc1882a1..11c5fe316 100644
--- a/coregrind/m_vki.c
+++ b/coregrind/m_vki.c
@@ -37,13 +37,13 @@
    describing the kernel interface, so this file is nearly empty. */
 
 
-/* ppc32/64, arm64 and mips32/64 (linux) determine page size at startup,
-   hence m_vki is the logical place to store that info. */
+/* ppc32/64, arm64, mips32/64 and loongarch64 (linux) determine page size
+   at startup, hence m_vki is the logical place to store that info. */
 
 #if defined(VGP_ppc32_linux) || defined(VGP_ppc64be_linux) \
     || defined(VGP_ppc64le_linux) || defined(VGP_arm64_linux) \
     || defined(VGP_mips32_linux)  || defined(VGP_mips64_linux) \
-    || defined(VGP_nanomips_linux)
+    || defined(VGP_nanomips_linux) || defined(VGP_loongarch64_linux)
 unsigned long VKI_PAGE_SHIFT = 12;
 unsigned long VKI_PAGE_SIZE  = 1UL << 12;
 #endif
diff --git a/coregrind/pub_core_aspacemgr.h b/coregrind/pub_core_aspacemgr.h
index b867108a2..a2b41f374 100644
--- a/coregrind/pub_core_aspacemgr.h
+++ b/coregrind/pub_core_aspacemgr.h
@@ -335,7 +335,8 @@ extern Bool VG_(am_relocate_nooverlap_client)( /*OUT*/Bool* need_discard,
 #if defined(VGP_ppc32_linux) \
     || defined(VGP_ppc64be_linux) || defined(VGP_ppc64le_linux)	\
     || defined(VGP_mips32_linux) || defined(VGP_mips64_linux) \
-    || defined(VGP_arm64_linux) || defined(VGP_nanomips_linux)
+    || defined(VGP_arm64_linux) || defined(VGP_nanomips_linux) \
+    || defined(VGP_loongarch64_linux)
 # define VG_STACK_GUARD_SZB  65536  // 1 or 16 pages
 #else
 # define VG_STACK_GUARD_SZB  8192   // 2 pages
diff --git a/coregrind/pub_core_basics.h b/coregrind/pub_core_basics.h
index abc5a066a..132545166 100644
--- a/coregrind/pub_core_basics.h
+++ b/coregrind/pub_core_basics.h
@@ -55,8 +55,8 @@
 
 typedef
    struct {
-      ULong r_pc; /* x86:EIP, amd64:RIP, ppc:CIA, arm:R15, mips:pc */
-      ULong r_sp; /* x86:ESP, amd64:RSP, ppc:R1,  arm:R13, mips:sp */
+      ULong r_pc; /* x86:EIP, amd64:RIP, ppc:CIA, arm:R15, mips:pc, loongarch64:pc */
+      ULong r_sp; /* x86:ESP, amd64:RSP, ppc:R1,  arm:R13, mips:sp, loongarch64:sp */
       union {
          struct {
             UInt r_ebp;
@@ -102,6 +102,10 @@ typedef
             ULong r31;  /* Return address of the last subroutine call */
             ULong r28;
          } MIPS64;
+         struct {
+            ULong r_fp; /* Stack frame pointer or static variable */
+            ULong r_ra; /* Return address of the last subroutine call */
+         } LOONGARCH64;
       } misc;
    }
    UnwindStartRegs;
diff --git a/coregrind/pub_core_debuginfo.h b/coregrind/pub_core_debuginfo.h
index 938ed00cc..d8c0db545 100644
--- a/coregrind/pub_core_debuginfo.h
+++ b/coregrind/pub_core_debuginfo.h
@@ -131,6 +131,10 @@ typedef
 typedef
    struct { Addr pc; Addr sp; Addr fp; Addr ra; }
    D3UnwindRegs;
+#elif defined(VGA_loongarch64)
+typedef
+   struct { Addr pc; Addr ra; Addr sp; Addr fp; }
+   D3UnwindRegs;
 #else
 #  error "Unsupported arch"
 #endif
diff --git a/coregrind/pub_core_machine.h b/coregrind/pub_core_machine.h
index a9b7dd8b1..4793d599c 100644
--- a/coregrind/pub_core_machine.h
+++ b/coregrind/pub_core_machine.h
@@ -126,6 +126,11 @@
 #  define VG_ELF_MACHINE      EM_NANOMIPS
 #  define VG_ELF_CLASS        ELFCLASS32
 #  undef  VG_PLAT_USES_PPCTOC
+#elif defined(VGP_loongarch64_linux)
+#  define VG_ELF_DATA2XXX     ELFDATA2LSB
+#  define VG_ELF_MACHINE      EM_LOONGARCH
+#  define VG_ELF_CLASS        ELFCLASS64
+#  undef  VG_PLAT_USES_PPCTOC
 #else
 #  error Unknown platform
 #endif
@@ -163,6 +168,10 @@
 #  define VG_INSTR_PTR        guest_PC
 #  define VG_STACK_PTR        guest_r29
 #  define VG_FRAME_PTR        guest_r30
+#elif defined(VGA_loongarch64)
+#  define VG_INSTR_PTR        guest_PC
+#  define VG_STACK_PTR        guest_R3
+#  define VG_FRAME_PTR        guest_R22
 #else
 #  error Unknown arch
 #endif
@@ -234,6 +243,10 @@ void VG_(get_UnwindStartRegs) ( /*OUT*/UnwindStartRegs* regs,
    s390x: initially:  call VG_(machine_get_hwcaps)
 
           then safe to use VG_(machine_get_VexArchInfo)
+   -------------
+   loongarch64: initially: call VG_(machine_get_hwcaps)
+
+          then safe to use VG_(machine_get_VexArchInfo)
 
    VG_(machine_get_hwcaps) may use signals (although it attempts to
    leave signal state unchanged) and therefore should only be
diff --git a/coregrind/pub_core_mallocfree.h b/coregrind/pub_core_mallocfree.h
index b5922ca50..d285caa1a 100644
--- a/coregrind/pub_core_mallocfree.h
+++ b/coregrind/pub_core_mallocfree.h
@@ -78,6 +78,7 @@ typedef Int ArenaId;
       defined(VGP_ppc64le_linux)  || \
       defined(VGP_s390x_linux)    || \
       (defined(VGP_mips64_linux) && !defined(VGABI_N32)) || \
+      defined(VGP_loongarch64_linux) || \
       defined(VGP_x86_freebsd)    || \
       defined(VGP_amd64_freebsd)  || \
       defined(VGP_x86_darwin)     || \
diff --git a/coregrind/pub_core_syscall.h b/coregrind/pub_core_syscall.h
index 6c4f82591..5d7ff4435 100644
--- a/coregrind/pub_core_syscall.h
+++ b/coregrind/pub_core_syscall.h
@@ -105,6 +105,7 @@ extern SysRes VG_(mk_SysRes_mips32_linux)( UWord v0, UWord v1,
 extern SysRes VG_(mk_SysRes_mips64_linux)( ULong v0, ULong v1,
                                            ULong a3 );
 extern SysRes VG_(mk_SysRes_nanomips_linux)( UWord a0);
+extern SysRes VG_(mk_SysRes_loongarch64_linux)( UWord a0 );
 extern SysRes VG_(mk_SysRes_x86_solaris) ( Bool isErr, UInt val, UInt val2 );
 extern SysRes VG_(mk_SysRes_amd64_solaris) ( Bool isErr, ULong val, ULong val2 );
 extern SysRes VG_(mk_SysRes_Error)       ( UWord val );
diff --git a/coregrind/pub_core_trampoline.h b/coregrind/pub_core_trampoline.h
index 54c575a72..59e4507b6 100644
--- a/coregrind/pub_core_trampoline.h
+++ b/coregrind/pub_core_trampoline.h
@@ -171,6 +171,12 @@ extern Char* VG_(nanomips_linux_REDIR_FOR_index)( const Char*, Int );
 extern UInt  VG_(nanomips_linux_REDIR_FOR_strlen)( void* );
 #endif
 
+#if defined(VGP_loongarch64_linux)
+extern Addr  VG_(loongarch64_linux_SUBST_FOR_rt_sigreturn);
+extern Char* VG_(loongarch64_linux_REDIR_FOR_index)( const Char*, Int );
+extern UInt  VG_(loongarch64_linux_REDIR_FOR_strlen)( void* );
+#endif
+
 #if defined(VGP_x86_solaris)
 extern SizeT VG_(x86_solaris_REDIR_FOR_strcmp)(const HChar *, const HChar *);
 extern SizeT VG_(x86_solaris_REDIR_FOR_strlen)(const HChar *);
diff --git a/coregrind/pub_core_transtab.h b/coregrind/pub_core_transtab.h
index 6cc11f658..fe9392626 100644
--- a/coregrind/pub_core_transtab.h
+++ b/coregrind/pub_core_transtab.h
@@ -81,7 +81,8 @@ static inline UWord VG_TT_FAST_HASH ( Addr guest ) {
 }
 
 #elif defined(VGA_ppc32) || defined(VGA_ppc64be) || defined(VGA_ppc64le) \
-      || defined(VGA_mips32) || defined(VGA_mips64) || defined(VGA_arm64)
+      || defined(VGA_mips32) || defined(VGA_mips64) || defined(VGA_arm64) \
+      || defined(VGA_loongarch64)
 static inline UWord VG_TT_FAST_HASH ( Addr guest ) {
    // Instructions are 4-byte aligned.
    UWord merged = ((UWord)guest) >> 2;
diff --git a/coregrind/pub_core_transtab_asm.h b/coregrind/pub_core_transtab_asm.h
index 8b585f17d..e73c89ae3 100644
--- a/coregrind/pub_core_transtab_asm.h
+++ b/coregrind/pub_core_transtab_asm.h
@@ -83,7 +83,7 @@
 #if defined(VGA_amd64) || defined(VGA_arm64) \
     || defined(VGA_ppc64be) || defined(VGA_ppc64le) \
     || (defined(VGA_mips64) && defined(VGABI_64)) \
-    || defined(VGA_s390x)
+    || defined(VGA_s390x) || defined(VGA_loongarch64)
   // And all other 64-bit hosts
 # define VG_FAST_CACHE_SET_BITS 6
   // These FCS_{g,h}{0,1,2,3} are the values of
diff --git a/coregrind/vgdb-invoker-ptrace.c b/coregrind/vgdb-invoker-ptrace.c
index 78a6a168c..798fe5f8e 100644
--- a/coregrind/vgdb-invoker-ptrace.c
+++ b/coregrind/vgdb-invoker-ptrace.c
@@ -50,9 +50,10 @@
 // Rather we use PTRACE_GETREGS or PTRACE_PEEKUSER.
 
 // The only platform on which we must use PTRACE_GETREGSET is arm64.
+// We use PTRACE_GETREGSET on loongarch64 as well.
 // The resulting vgdb cannot work in a bi-arch setup.
 // -1 means we will check that PTRACE_GETREGSET works.
-#  if defined(VGA_arm64)
+#  if defined(VGA_arm64) || defined(VGA_loongarch64)
 #define USE_PTRACE_GETREGSET
 #  endif
 #endif
@@ -529,6 +530,9 @@ static struct user_regs_struct user_save;
 #    else
 static struct user_pt_regs user_save;
 #    endif
+#  elif defined(VGA_loongarch64)
+/* loongarch64 is extra special, glibc only defined user_regs_struct. */
+static struct user_regs_struct user_save;
 #  else
 static struct user user_save;
 #  endif
@@ -805,6 +809,9 @@ Bool invoker_invoke_gdbserver (pid_t pid)
 #    else
    struct user_pt_regs user_mod;
 #    endif
+#  elif defined(VGA_loongarch64)
+/* loongarch64 is extra special, glibc only defined user_regs_struct. */
+   struct user_regs_struct user_mod;
 #  else
    struct user user_mod;
 #  endif
@@ -874,6 +881,8 @@ Bool invoker_invoke_gdbserver (pid_t pid)
    sp = p[29];
 #elif defined(VGA_mips64)
    sp = user_mod.regs[29];
+#elif defined(VGA_loongarch64)
+   sp = user_mod.regs[3];
 #else
    I_die_here : (sp) architecture missing in vgdb-invoker-ptrace.c
 #endif
@@ -961,6 +970,8 @@ Bool invoker_invoke_gdbserver (pid_t pid)
 
 #elif defined(VGA_mips64)
       assert(0); // cannot vgdb a 32 bits executable with a 64 bits exe
+#elif defined(VGA_loongarch64)
+      assert(0); // cannot vgdb a 32 bits executable with a 64 bits exe
 #else
       I_die_here : architecture missing in vgdb-invoker-ptrace.c
 #endif
@@ -1068,6 +1079,12 @@ Bool invoker_invoke_gdbserver (pid_t pid)
       user_mod.regs[31] = bad_return;
       user_mod.regs[34] = shared64->invoke_gdbserver;
       user_mod.regs[25] = shared64->invoke_gdbserver;
+#elif defined(VGA_loongarch64)
+      /* put check arg in register a0 */
+      user_mod.regs[4] = check;
+      /* put NULL return address in ra */
+      user_mod.regs[1] = bad_return;
+      user_mod.csr_era = shared64->invoke_gdbserver;
 #else
       I_die_here: architecture missing in vgdb-invoker-ptrace.c
 #endif
diff --git a/drd/drd_bitmap.h b/drd/drd_bitmap.h
index 3b71d749a..1f11f23c4 100644
--- a/drd/drd_bitmap.h
+++ b/drd/drd_bitmap.h
@@ -140,7 +140,7 @@ Addr make_address(const UWord a1, const UWord a0)
 #define BITS_PER_BITS_PER_UWORD 5
 #elif defined(VGA_amd64) || defined(VGA_ppc64be) || defined(VGA_ppc64le) \
       || defined(VGA_s390x) || (defined(VGA_mips64) && !defined(VGABI_N32)) \
-      || defined(VGA_arm64)
+      || defined(VGA_arm64) || defined(VGA_loongarch64)
 #define BITS_PER_BITS_PER_UWORD 6
 #else
 #error Unknown platform.
diff --git a/drd/drd_load_store.c b/drd/drd_load_store.c
index 435e5586d..dda4ea385 100644
--- a/drd/drd_load_store.c
+++ b/drd/drd_load_store.c
@@ -53,6 +53,8 @@
 #define STACK_POINTER_OFFSET OFFSET_mips32_r29
 #elif defined(VGA_mips64)
 #define STACK_POINTER_OFFSET OFFSET_mips64_r29
+#elif defined(VGA_loongarch64)
+#define STACK_POINTER_OFFSET OFFSET_loongarch64_R3
 #else
 #error Unknown architecture.
 #endif
diff --git a/helgrind/tests/annotate_hbefore.c b/helgrind/tests/annotate_hbefore.c
index 259d3b64c..bc11c287c 100644
--- a/helgrind/tests/annotate_hbefore.c
+++ b/helgrind/tests/annotate_hbefore.c
@@ -314,6 +314,17 @@ UWord do_acasW ( UWord* addr, UWord expected, UWord nyu )
    return success;
 }
 
+#elif defined(VGA_loongarch64)
+
+// loongarch64
+/* return 1 if success, 0 if failure */
+UWord do_acasW ( UWord* addr, UWord expected, UWord nyu )
+{
+   /* TODO */
+   assert(0);
+   return 0;
+}
+
 #endif
 
 void atomic_incW ( UWord* w )
diff --git a/helgrind/tests/tc07_hbl1.c b/helgrind/tests/tc07_hbl1.c
index 54297dee6..58f2fbc45 100644
--- a/helgrind/tests/tc07_hbl1.c
+++ b/helgrind/tests/tc07_hbl1.c
@@ -18,6 +18,7 @@
 #undef PLAT_arm64_linux
 #undef PLAT_s390x_linux
 #undef PLAT_mips32_linux
+#undef PLAT_loongarch64_linux
 #undef PLAT_x86_solaris
 #undef PLAT_amd64_solaris
 
@@ -47,6 +48,8 @@
 #  define PLAT_mips32_linux 1
 #elif defined(__linux__) && defined(__nanomips__)
 #  define PLAT_nanomips_linux 1
+#elif defined(__linux__) && defined(__loongarch__) && (__loongarch_grlen == 64)
+#  define PLAT_loongarch64_linux 1
 #elif defined(__sun__) && defined(__i386__)
 #  define PLAT_x86_solaris 1
 #elif defined(__sun__) && defined(__x86_64__)
@@ -131,6 +134,11 @@
       : /*out*/ : /*in*/ "r"(&(_lval))              \
       : /*trash*/ "$t0", "$t1", "memory"            \
    )
+#elif defined(PLAT_loongarch64_linux)
+   /* TODO */
+#include <assert.h>
+#  define INC(_lval,_lqual)                         \
+     assert(0);
 #else
 #  error "Fix Me for this platform"
 #endif
diff --git a/helgrind/tests/tc08_hbl2.c b/helgrind/tests/tc08_hbl2.c
index c3a2ec794..2758231a9 100644
--- a/helgrind/tests/tc08_hbl2.c
+++ b/helgrind/tests/tc08_hbl2.c
@@ -35,6 +35,7 @@
 #undef PLAT_s390x_linux
 #undef PLAT_mips32_linux
 #undef PLAT_mips64_linux
+#undef PLAT_loongarch64_linux
 #undef PLAT_x86_solaris
 #undef PLAT_amd64_solaris
 
@@ -68,6 +69,8 @@
 #endif
 #elif defined(__linux__) && defined(__nanomips__)
 #  define PLAT_nanomips_linux 1
+#elif defined(__linux__) && defined(__loongarch__) && (__loongarch_grlen == 64)
+#  define PLAT_loongarch64_linux 1
 #elif defined(__sun__) && defined(__i386__)
 #  define PLAT_x86_solaris 1
 #elif defined(__sun__) && defined(__x86_64__)
@@ -151,6 +154,11 @@
       : /*out*/ : /*in*/ "r"(&(_lval))              \
       : /*trash*/ "$t0", "$t1", "memory"            \
    )
+#elif defined(PLAT_loongarch64_linux)
+   /* TODO Implement. */
+#include <assert.h>
+#  define INC(_lval,_lqual)                         \
+     assert(0);
 #else
 #  error "Fix Me for this platform"
 #endif
diff --git a/helgrind/tests/tc11_XCHG.c b/helgrind/tests/tc11_XCHG.c
index f6ff1c984..0d307ac0c 100644
--- a/helgrind/tests/tc11_XCHG.c
+++ b/helgrind/tests/tc11_XCHG.c
@@ -20,6 +20,7 @@
 #undef PLAT_arm_linux
 #undef PLAT_s390x_linux
 #undef PLAT_mips32_linux
+#undef PLAT_loongarch64_linux
 #undef PLAT_x86_solaris
 #undef PLAT_amd64_solaris
 
@@ -49,6 +50,8 @@
 #  define PLAT_mips32_linux 1
 #elif defined(__linux__) && defined(__nanomips__)
 #  define PLAT_nanomips_linux 1
+#elif defined(__linux__) && defined(__loongarch__) && (__loongarch_grlen == 64)
+#  define PLAT_loongarch64_linux 1
 #elif defined(__sun__) && defined(__i386__)
 #  define PLAT_x86_solaris 1
 #elif defined(__sun__) && defined(__x86_64__)
@@ -146,6 +149,21 @@
 #  define XCHG_M_R_with_redundant_LOCK(_addr,_lval) \
       XCHG_M_R(_addr,_lval)
 
+#elif defined(PLAT_loongarch64_linux)
+#  define XCHG_M_R(_addr,_lval)                              \
+   __asm__ __volatile__(                                     \
+      "move $t0, %2 \n\t"                                    \
+      "ll.w $t1, %1 \n\t"                                    \
+      "sc.w $t0, %1 \n\t"                                    \
+      "move %0, $t1 \n\t"                                    \
+      : /*out*/ "=r"(_lval), "+ZC"(_addr)                    \
+      : /*in*/  "r"(_lval)                                   \
+      : "$t0", "$t1", "memory"                               \
+   )
+
+#  define XCHG_M_R_with_redundant_LOCK(_addr,_lval)          \
+      XCHG_M_R(_addr,_lval)
+
 #else
 #  error "Unsupported architecture"
 
diff --git a/include/Makefile.am b/include/Makefile.am
index 972d394b8..abfa2c915 100644
--- a/include/Makefile.am
+++ b/include/Makefile.am
@@ -63,6 +63,7 @@ nobase_pkginclude_HEADERS = \
 	vki/vki-posixtypes-mips32-linux.h \
 	vki/vki-posixtypes-mips64-linux.h \
 	vki/vki-posixtypes-nanomips-linux.h \
+	vki/vki-posixtypes-loongarch64-linux.h \
 	vki/vki-amd64-linux.h		\
 	vki/vki-arm64-linux.h		\
 	vki/vki-ppc32-linux.h		\
@@ -75,6 +76,7 @@ nobase_pkginclude_HEADERS = \
 	vki/vki-mips32-linux.h		\
 	vki/vki-mips64-linux.h		\
 	vki/vki-nanomips-linux.h	\
+	vki/vki-loongarch64-linux.h	\
 	vki/vki-scnums-amd64-linux.h	\
 	vki/vki-scnums-arm64-linux.h	\
 	vki/vki-scnums-ppc32-linux.h	\
@@ -86,6 +88,7 @@ nobase_pkginclude_HEADERS = \
 	vki/vki-scnums-mips32-linux.h	\
 	vki/vki-scnums-mips64-linux.h	\
 	vki/vki-scnums-nanomips-linux.h	\
+	vki/vki-scnums-loongarch64-linux.h \
 	vki/vki-scnums-darwin.h         \
 	vki/vki-scnums-solaris.h	\
 	vki/vki-scnums-shared-linux.h	\
diff --git a/include/pub_tool_basics.h b/include/pub_tool_basics.h
index d22a42523..079196524 100644
--- a/include/pub_tool_basics.h
+++ b/include/pub_tool_basics.h
@@ -442,7 +442,8 @@ static inline Bool sr_EQ ( UInt sysno, SysRes sr1, SysRes sr2 ) {
 
 #if defined(VGA_x86) || defined(VGA_amd64) || defined (VGA_arm) \
     || ((defined(VGA_mips32) || defined(VGA_mips64) || defined(VGA_nanomips)) \
-    && defined (_MIPSEL)) || defined(VGA_arm64)  || defined(VGA_ppc64le)
+    && defined (_MIPSEL)) || defined(VGA_arm64)  || defined(VGA_ppc64le) \
+    || defined (VGA_loongarch64)
 #  define VG_LITTLEENDIAN 1
 #elif defined(VGA_ppc32) || defined(VGA_ppc64be) || defined(VGA_s390x) \
       || ((defined(VGA_mips32) || defined(VGA_mips64) || defined(VGA_nanomips)) \
@@ -490,7 +491,8 @@ static inline Bool sr_EQ ( UInt sysno, SysRes sr1, SysRes sr2 ) {
       || defined(VGA_ppc64be) || defined(VGA_ppc64le) \
       || defined(VGA_arm) || defined(VGA_s390x) \
       || defined(VGA_mips32) || defined(VGA_mips64) \
-      || defined(VGA_arm64) || defined(VGA_nanomips)
+      || defined(VGA_arm64) || defined(VGA_nanomips) \
+      || defined(VGA_loongarch64)
 #  define VG_REGPARM(n)            /* */
 #else
 #  error Unknown arch
diff --git a/include/pub_tool_guest.h b/include/pub_tool_guest.h
index 08a72efac..87e8cc2bc 100644
--- a/include/pub_tool_guest.h
+++ b/include/pub_tool_guest.h
@@ -62,6 +62,9 @@
 #elif defined(VGA_mips64)
 #  include "libvex_guest_mips64.h"
    typedef VexGuestMIPS64State VexGuestArchState;
+#elif defined(VGA_loongarch64)
+#  include "libvex_guest_loongarch64.h"
+   typedef VexGuestLOONGARCH64State VexGuestArchState;
 #else
 #  error Unknown arch
 #endif
diff --git a/include/pub_tool_machine.h b/include/pub_tool_machine.h
index 9bdd4f514..12377f97a 100644
--- a/include/pub_tool_machine.h
+++ b/include/pub_tool_machine.h
@@ -108,6 +108,12 @@
 #  define VG_CLREQ_SZB             20
 #  define VG_STACK_REDZONE_SZB      0
 
+#elif defined(VGP_loongarch64_linux)
+#  define VG_MIN_INSTR_SZB          4
+#  define VG_MAX_INSTR_SZB          8
+#  define VG_CLREQ_SZB             20
+#  define VG_STACK_REDZONE_SZB      0
+
 #else
 #  error Unknown platform
 #endif
diff --git a/include/pub_tool_vkiscnums_asm.h b/include/pub_tool_vkiscnums_asm.h
index 14b483c4d..b2222aadf 100644
--- a/include/pub_tool_vkiscnums_asm.h
+++ b/include/pub_tool_vkiscnums_asm.h
@@ -74,6 +74,10 @@
 #  include "vki/vki-scnums-shared-linux.h"
 #  include "vki/vki-scnums-mips64-linux.h"
 
+#elif defined(VGP_loongarch64_linux)
+#  include "vki/vki-scnums-shared-linux.h"
+#  include "vki/vki-scnums-loongarch64-linux.h"
+
 #elif defined(VGP_x86_freebsd) || defined(VGP_amd64_freebsd)
 #  include "vki/vki-scnums-freebsd.h"
 
diff --git a/include/valgrind.h.in b/include/valgrind.h.in
index aa0b43125..8b9dbf489 100644
--- a/include/valgrind.h.in
+++ b/include/valgrind.h.in
@@ -125,6 +125,7 @@
 #undef PLAT_mips32_linux
 #undef PLAT_mips64_linux
 #undef PLAT_nanomips_linux
+#undef PLAT_loongarch64_linux
 #undef PLAT_x86_solaris
 #undef PLAT_amd64_solaris
 
@@ -169,6 +170,8 @@
 #  define PLAT_mips32_linux 1
 #elif defined(__linux__) && defined(__nanomips__)
 #  define PLAT_nanomips_linux 1
+#elif defined(__linux__) && defined(__loongarch__) && (__loongarch_grlen == 64)
+#  define PLAT_loongarch64_linux 1
 #elif defined(__sun) && defined(__i386__)
 #  define PLAT_x86_solaris 1
 #elif defined(__sun) && defined(__x86_64__)
@@ -1125,7 +1128,44 @@ typedef
                     );                                              \
  } while (0)
 
-#endif
+#endif /* PLAT_nanomips_linux */
+
+/* --------------------- loongarch64-linux --------------------- */
+#if defined(PLAT_loongarch64_linux)
+
+typedef
+   struct {
+      unsigned long nraddr; /* where's the code? */
+   }
+   OrigFn;
+
+#define __SPECIAL_INSTRUCTION_PREAMBLE                              \
+   do {                                                             \
+      /* TODO */                                                    \
+   } while (0)
+
+#define VALGRIND_DO_CLIENT_REQUEST_EXPR(                            \
+        _zzq_default, _zzq_request,                                 \
+        _zzq_arg1, _zzq_arg2, _zzq_arg3, _zzq_arg4, _zzq_arg5)      \
+   /* TODO */                                                       \
+   0
+
+#define VALGRIND_GET_NR_CONTEXT(_zzq_rlval)                         \
+   do {                                                             \
+      /* TODO */                                                    \
+   } while (0)
+
+#define VALGRIND_CALL_NOREDIR_T8                                    \
+   do {                                                             \
+      /* TODO */                                                    \
+   } while (0)
+
+#define VALGRIND_VEX_INJECT_IR()                                    \
+   do {                                                             \
+      /* TODO */                                                    \
+   } while (0)
+
+#endif /* PLAT_loongarch64_linux */
 /* Insert assembly code for other platforms here... */
 
 #endif /* NVALGRIND */
@@ -6603,6 +6643,107 @@ typedef
 
 #endif /* PLAT_mips64_linux */
 
+/* --------------------- loongarch64-linux --------------------- */
+
+#if defined(PLAT_loongarch64_linux)
+
+/* These regs are trashed by the hidden call. */
+#define __CALLER_SAVED_REGS                                       \
+   do {                                                           \
+      /* TODO */                                                  \
+   } while (0)
+
+/* $s0 is callee-saved, so we can use it to save and restore SP around
+   the hidden call. */
+#define VALGRIND_ALIGN_STACK                                      \
+   do {                                                           \
+      /* TODO */                                                  \
+   } while (0)
+
+#define VALGRIND_RESTORE_STACK                                    \
+   do {                                                           \
+      /* TODO */                                                  \
+   } while (0)
+
+/* These CALL_FN_ macros assume that on loongarch64-linux,
+   sizeof(unsigned long) == 8. */
+
+#define CALL_FN_W_v(lval, orig)                                   \
+   do {                                                           \
+      /* TODO */                                                  \
+   } while (0)
+
+#define CALL_FN_W_W(lval, orig, arg1)                             \
+   do {                                                           \
+      /* TODO */                                                  \
+   } while (0)
+
+#define CALL_FN_W_WW(lval, orig, arg1, arg2)                      \
+   do {                                                           \
+      /* TODO */                                                  \
+   } while (0)
+
+#define CALL_FN_W_WWW(lval, orig, arg1, arg2, arg3)               \
+   do {                                                           \
+      /* TODO */                                                  \
+   } while (0)
+
+#define CALL_FN_W_WWWW(lval, orig, arg1, arg2, arg3, arg4)        \
+   do {                                                           \
+      /* TODO */                                                  \
+   } while (0)
+
+#define CALL_FN_W_5W(lval, orig, arg1, arg2, arg3, arg4, arg5)    \
+   do {                                                           \
+      /* TODO */                                                  \
+   } while (0)
+
+#define CALL_FN_W_6W(lval, orig, arg1, arg2, arg3, arg4, arg5,    \
+                                 arg6)                            \
+   do {                                                           \
+      /* TODO */                                                  \
+   } while (0)
+
+#define CALL_FN_W_7W(lval, orig, arg1, arg2, arg3, arg4, arg5,    \
+                                 arg6, arg7)                      \
+   do {                                                           \
+      /* TODO */                                                  \
+   } while (0)
+
+#define CALL_FN_W_8W(lval, orig, arg1, arg2, arg3, arg4, arg5,    \
+                                 arg6, arg7, arg8)                \
+   do {                                                           \
+      /* TODO */                                                  \
+   } while (0)
+
+#define CALL_FN_W_9W(lval, orig, arg1, arg2, arg3, arg4, arg5,    \
+                                 arg6, arg7, arg8, arg9)          \
+   do {                                                           \
+      /* TODO */                                                  \
+   } while (0)
+
+#define CALL_FN_W_10W(lval, orig, arg1, arg2, arg3, arg4, arg5,   \
+                                  arg6, arg7, arg8, arg9, arg10)  \
+   do {                                                           \
+      /* TODO */                                                  \
+   } while (0)
+
+#define CALL_FN_W_11W(lval, orig, arg1, arg2, arg3, arg4, arg5,   \
+                                  arg6, arg7, arg8, arg9, arg10,  \
+                                  arg11)                          \
+   do {                                                           \
+      /* TODO */                                                  \
+   } while (0)
+
+#define CALL_FN_W_12W(lval, orig, arg1, arg2, arg3, arg4, arg5,   \
+                                  arg6, arg7, arg8, arg9, arg10,  \
+                                  arg11, arg12)                   \
+   do {                                                           \
+      /* TODO */                                                  \
+   } while (0)
+
+#endif /* PLAT_loongarch64_linux */
+
 /* ------------------------------------------------------------------ */
 /* ARCHITECTURE INDEPENDENT MACROS for CLIENT REQUESTS.               */
 /*                                                                    */
@@ -7159,6 +7300,7 @@ VALGRIND_PRINTF_BACKTRACE(const char *format, ...)
 #undef PLAT_mips32_linux
 #undef PLAT_mips64_linux
 #undef PLAT_nanomips_linux
+#undef PLAT_loongarch64_linux
 #undef PLAT_x86_solaris
 #undef PLAT_amd64_solaris
 
diff --git a/include/vki/vki-linux.h b/include/vki/vki-linux.h
index 6de21d1b7..9b2ef71bd 100644
--- a/include/vki/vki-linux.h
+++ b/include/vki/vki-linux.h
@@ -97,6 +97,8 @@
 #  include "vki-posixtypes-mips64-linux.h"
 #elif defined(VGA_nanomips)
 #  include "vki-posixtypes-nanomips-linux.h"
+#elif defined(VGA_loongarch64)
+#  include "vki-posixtypes-loongarch64-linux.h"
 #else
 #  error Unknown platform
 #endif
@@ -225,6 +227,8 @@ typedef unsigned int	        vki_uint;
 #  include "vki-mips64-linux.h"
 #elif defined(VGA_nanomips)
 #  include "vki-nanomips-linux.h"
+#elif defined(VGA_loongarch64)
+#  include "vki-loongarch64-linux.h"
 #else
 #  error Unknown platform
 #endif
diff --git a/include/vki/vki-loongarch64-linux.h b/include/vki/vki-loongarch64-linux.h
new file mode 100644
index 000000000..d1323bd2e
--- /dev/null
+++ b/include/vki/vki-loongarch64-linux.h
@@ -0,0 +1,827 @@
+
+/*--------------------------------------------------------------------*/
+/*--- loongarch/Linux-specific kernel interface.                   ---*/
+/*---                                      vki-loongarch64-linux.h ---*/
+/*--------------------------------------------------------------------*/
+
+/*
+   This file is part of Valgrind, a dynamic binary instrumentation
+   framework.
+
+   Copyright (C) 2021-2022 Loongson Technology Corporation Limited
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef __VKI_LOONGARCH64_LINUX_H
+#define __VKI_LOONGARCH64_LINUX_H
+
+// loongarch64 is little-endian.
+#define VKI_LITTLE_ENDIAN 1
+
+//----------------------------------------------------------------------
+// From linux-5.15.2/include/uapi/asm-generic/int-ll64.h
+//----------------------------------------------------------------------
+
+typedef __signed__ char __vki_s8;
+typedef unsigned char __vki_u8;
+
+typedef __signed__ short __vki_s16;
+typedef unsigned short __vki_u16;
+
+typedef __signed__ int __vki_s32;
+typedef unsigned int __vki_u32;
+
+typedef __signed__ long long __vki_s64;
+typedef unsigned long long __vki_u64;
+
+//----------------------------------------------------------------------
+// From linux-5.15.2/include/asm-generic/int-ll64.h
+//----------------------------------------------------------------------
+
+typedef __vki_s8  vki_s8;
+typedef __vki_u8  vki_u8;
+typedef __vki_s16 vki_s16;
+typedef __vki_u16 vki_u16;
+typedef __vki_s32 vki_s32;
+typedef __vki_u32 vki_u32;
+typedef __vki_s64 vki_s64;
+typedef __vki_u64 vki_u64;
+
+//----------------------------------------------------------------------
+// From linux-5.15.2/include/linux/types.h
+//----------------------------------------------------------------------
+
+typedef vki_u8  vki_u_int8_t;
+typedef vki_s8  vki_int8_t;
+typedef vki_u16 vki_u_int16_t;
+typedef vki_s16 vki_int16_t;
+typedef vki_u32 vki_u_int32_t;
+typedef vki_s32 vki_int32_t;
+
+typedef vki_u8  vki_uint8_t;
+typedef vki_u16 vki_uint16_t;
+typedef vki_u32 vki_uint32_t;
+
+typedef vki_u64 vki_uint64_t;
+typedef vki_u64 vki_u_int64_t;
+typedef vki_s64 vki_int64_t;
+
+//----------------------------------------------------------------------
+// From linux-5.19-rc1/arch/loongarch/include/asm/page.h
+//----------------------------------------------------------------------
+
+/* loongarch64 uses runtime pagesize detection */
+extern UWord VKI_PAGE_SHIFT;
+extern UWord VKI_PAGE_SIZE;
+#define VKI_PAGE_MASK      (~(PAGE_SIZE - 1))
+#define VKI_MAX_PAGE_SHIFT 16
+#define VKI_MAX_PAGE_SIZE  (1UL << VKI_MAX_PAGE_SHIFT)
+
+//----------------------------------------------------------------------
+// From linux-5.19-rc1/arch/loongarch/include/asm/shmparam.h
+//----------------------------------------------------------------------
+
+#define VKI_SHMLBA 0x00010000 // SZ_64K
+
+//----------------------------------------------------------------------
+// From linux-5.19-rc1/arch/loongarch/include/uapi/asm/signal.h
+//----------------------------------------------------------------------
+
+#define VKI_MINSIGSTKSZ 4096
+#define VKI_SIGSTKSZ    16384
+
+//----------------------------------------------------------------------
+// From linux-5.19-rc1/include/uapi/asm-generic/signal-defs.h
+//----------------------------------------------------------------------
+
+#define VKI_SA_NOCLDSTOP      0x00000001
+#define VKI_SA_NOCLDWAIT      0x00000002
+#define VKI_SA_SIGINFO        0x00000004
+/* 0x00000008 used on alpha, mips, parisc */
+/* 0x00000010 used on alpha, parisc */
+/* 0x00000020 used on alpha, parisc, sparc */
+/* 0x00000040 used on alpha, parisc */
+/* 0x00000080 used on parisc */
+/* 0x00000100 used on sparc */
+/* 0x00000200 used on sparc */
+#define VKI_SA_UNSUPPORTED    0x00000400
+#define VKI_SA_EXPOSE_TAGBITS 0x00000800
+/* 0x00010000 used on mips */
+/* 0x00800000 used for internal SA_IMMUTABLE */
+/* 0x01000000 used on x86 */
+/* 0x02000000 used on x86 */
+/*
+ * New architectures should not define the obsolete
+ *      VKI_SA_RESTORER       0x04000000
+ */
+#define VKI_SA_ONSTACK        0x08000000
+#define VKI_SA_RESTART        0x10000000
+#define VKI_SA_NODEFER        0x40000000
+#define VKI_SA_RESETHAND      0x80000000
+
+#define VKI_SA_NOMASK         VKI_SA_NODEFER
+#define VKI_SA_ONESHOT        VKI_SA_RESETHAND
+
+#define VKI_SIG_BLOCK     0 /* for blocking signals */
+#define VKI_SIG_UNBLOCK   1 /* for unblocking signals */
+#define VKI_SIG_SETMASK   2 /* for setting the signal mask */
+
+typedef void __vki_signalfn_t(int);
+typedef __vki_signalfn_t __user *__vki_sighandler_t;
+
+typedef void __vki_restorefn_t(void);
+typedef __vki_restorefn_t __user *__vki_igrestore_t;
+
+#define VKI_SIG_DFL ((__vki_sighandler_t)0)  /* default signal handling */
+#define VKI_SIG_IGN ((__vki_sighandler_t)1)  /* ignore signal */
+#define VKI_SIG_ERR ((__vki_sighandler_t)-1) /* error return from signal */
+
+//----------------------------------------------------------------------
+// From linux-5.19-rc1/include/uapi/asm-generic/signal.h
+//----------------------------------------------------------------------
+
+#define _VKI_NSIG       64
+#define _VKI_NSIG_BPW   64 // __BITS_PER_LONG == 64
+#define _VKI_NSIG_WORDS (_VKI_NSIG / _VKI_NSIG_BPW)
+
+#define VKI_SIGHUP     1
+#define VKI_SIGINT     2
+#define VKI_SIGQUIT    3
+#define VKI_SIGILL     4
+#define VKI_SIGTRAP    5
+#define VKI_SIGABRT    6
+#define VKI_SIGIOT     6
+#define VKI_SIGBUS     7
+#define VKI_SIGFPE     8
+#define VKI_SIGKILL    9
+#define VKI_SIGUSR1   10
+#define VKI_SIGSEGV   11
+#define VKI_SIGUSR2   12
+#define VKI_SIGPIPE   13
+#define VKI_SIGALRM   14
+#define VKI_SIGTERM   15
+#define VKI_SIGSTKFLT 16
+#define VKI_SIGCHLD   17
+#define VKI_SIGCONT   18
+#define VKI_SIGSTOP   19
+#define VKI_SIGTSTP   20
+#define VKI_SIGTTIN   21
+#define VKI_SIGTTOU   22
+#define VKI_SIGURG    23
+#define VKI_SIGXCPU   24
+#define VKI_SIGXFSZ   25
+#define VKI_SIGVTALRM 26
+#define VKI_SIGPROF   27
+#define VKI_SIGWINCH  28
+#define VKI_SIGIO     29
+#define VKI_SIGPOLL   VKI_SIGIO
+/*
+#define VKI_SIGLOST   29
+*/
+#define VKI_SIGPWR    30
+#define VKI_SIGSYS    31
+#define VKI_SIGUNUSED 31
+
+#define VKI_SIGRTMIN  32
+#define VKI_SIGRTMAX  _VKI_NSIG
+
+typedef struct {
+   unsigned long sig[_VKI_NSIG_WORDS];
+} vki_sigset_t;
+
+typedef unsigned long vki_old_sigset_t;
+
+//----------------------------------------------------------------------
+// From linux-5.19-rc1/include/uapi/linux/signal.h
+//----------------------------------------------------------------------
+
+#define VKI_SS_ONSTACK 1
+#define VKI_SS_DISABLE 2
+
+//----------------------------------------------------------------------
+// From linux-5.19-rc1/include/linux/signal_types.h
+//----------------------------------------------------------------------
+
+struct vki_sigaction {
+   __vki_sighandler_t sa_handler;
+	unsigned long      sa_flags;
+	vki_sigset_t       sa_mask; /* mask last for extensibility */
+};
+
+struct vki_sigaction_base {
+   // [[Nb: a 'k' prefix is added to "sa_handler" because
+   // bits/sigaction.h (which gets dragged in somehow via signal.h)
+   // #defines it as something else.  Since that is done for glibc's
+   // purposes, which we don't care about here, we use our own name.]]
+   __vki_sighandler_t ksa_handler;
+   unsigned long      sa_flags;
+   vki_sigset_t       sa_mask; /* mask last for extensibility */
+};
+
+/* On Linux we use the same type for passing sigactions to
+   and from the kernel.  Hence: */
+typedef struct vki_sigaction_base vki_sigaction_toK_t;
+typedef struct vki_sigaction_base vki_sigaction_fromK_t;
+
+typedef struct vki_sigaltstack {
+   void __user         *ss_sp;
+   int                 ss_flags;
+   __vki_kernel_size_t ss_size;
+} vki_stack_t;
+
+//----------------------------------------------------------------------
+// From linux-5.19-rc1/arch/loongarch/include/uapi/asm/sigcontext.h
+//----------------------------------------------------------------------
+
+struct vki_sigcontext {
+   __vki_u64 sc_pc;
+   __vki_u64 sc_regs[32];
+   __vki_u32 sc_flags;
+   __vki_u64 sc_extcontext[0] __attribute__((__aligned__(16)));
+};
+
+//----------------------------------------------------------------------
+// From linux-5.19-rc1/include/uapi/linux/mman.h
+//----------------------------------------------------------------------
+
+#define VKI_MAP_SHARED          0x01       /* Share changes */
+#define VKI_MAP_PRIVATE         0x02       /* Changes are private */
+#define VKI_MAP_SHARED_VALIDATE 0x03       /* share + validate extension flags */
+
+//----------------------------------------------------------------------
+// From linux-5.19-rc1/include/uapi/asm-generic/mman-common.h
+//----------------------------------------------------------------------
+
+#define VKI_PROT_READ  0x1                 /* page can be read */
+#define VKI_PROT_WRITE 0x2                 /* page can be written */
+#define VKI_PROT_EXEC  0x4                 /* page can be executed */
+#define VKI_PROT_SEM   0x8                 /* page may be used for atomic ops */
+/*                              0x10          reserved for arch-specific use */
+/*                              0x20          reserved for arch-specific use */
+#define VKI_PROT_NONE           0x0        /* page can not be accessed */
+#define VKI_PROT_GROWSDOWN      0x01000000 /* mprotect flag: extend change to start of growsdown vma */
+#define VKI_PROT_GROWSUP        0x02000000 /* mprotect flag: extend change to end of growsup vma */
+
+/* 0x01 - 0x03 are defined in linux/mman.h */
+#define VKI_MAP_TYPE            0x0f       /* Mask for type of mapping */
+#define VKI_MAP_FIXED           0x10       /* Interpret addr exactly */
+#define VKI_MAP_ANONYMOUS       0x20       /* don't use a file */
+
+/* 0x0100 - 0x4000 flags are defined in asm-generic/mman.h */
+#define VKI_MAP_POPULATE        0x008000   /* populate (prefault) pagetables */
+#define VKI_MAP_NONBLOCK        0x010000   /* do not block on IO */
+#define VKI_MAP_STACK           0x020000   /* give out an address that is best suited for process/thread stacks */
+#define VKI_MAP_HUGETLB         0x040000   /* create a huge page mapping */
+#define VKI_MAP_SYNC            0x080000   /* perform synchronous page faults for the mapping */
+#define VKI_MAP_FIXED_NOREPLACE 0x100000   /* MAP_FIXED which doesn't unmap underlying mapping */
+
+#define VKI_MAP_UNINITIALIZED   0x4000000  /* For anonymous mmap, memory could be uninitialized */
+
+//----------------------------------------------------------------------
+// From linux-5.19-rc1/include/uapi/asm-generic/fcntl.h
+//----------------------------------------------------------------------
+
+#define VKI_O_ACCMODE    00000003
+#define VKI_O_RDONLY     00000000
+#define VKI_O_WRONLY     00000001
+#define VKI_O_RDWR       00000002
+#define VKI_O_CREAT      00000100 /* not fcntl */
+#define VKI_O_EXCL       00000200 /* not fcntl */
+#define VKI_O_NOCTTY     00000400 /* not fcntl */
+#define VKI_O_TRUNC      00001000 /* not fcntl */
+#define VKI_O_APPEND     00002000
+#define VKI_O_NONBLOCK   00004000
+#define VKI_O_DSYNC      00010000 /* used to be O_SYNC, see below */
+#define VKI_FASYNC       00020000 /* fcntl, for BSD compatibility */
+#define VKI_O_DIRECT     00040000 /* direct disk access hint */
+#define VKI_O_LARGEFILE  00100000
+#define VKI_O_DIRECTORY  00200000 /* must be a directory */
+#define VKI_O_NOFOLLOW   00400000 /* don't follow links */
+#define VKI_O_NOATIME    01000000
+#define VKI_O_CLOEXEC    02000000 /* set close_on_exec */
+
+#define __VKI_O_SYNC     04000000
+#define VKI_O_SYNC       (__VKI_O_SYNC|VKI_O_DSYNC)
+
+#define VKI_O_PATH       010000000
+
+#define __VKI_O_TMPFILE  020000000
+
+#define VKI_O_TMPFILE      (__VKI_O_TMPFILE | VKI_O_DIRECTORY)
+#define VKI_O_TMPFILE_MASK (__VKI_O_TMPFILE | VKI_O_DIRECTORY | VKI_O_CREAT)
+
+#define VKI_O_NDELAY     VKI_O_NONBLOCK
+
+#define VKI_F_DUPFD         0  /* dup */
+#define VKI_F_GETFD         1  /* get close_on_exec */
+#define VKI_F_SETFD         2  /* set/clear close_on_exec */
+#define VKI_F_GETFL         3  /* get file->f_flags */
+#define VKI_F_SETFL         4  /* set file->f_flags */
+#define VKI_F_GETLK         5
+#define VKI_F_SETLK         6
+#define VKI_F_SETLKW        7
+#define VKI_F_SETOWN        8  /* for sockets. */
+#define VKI_F_GETOWN        9  /* for sockets. */
+#define VKI_F_SETSIG        10 /* for sockets. */
+#define VKI_F_GETSIG        11 /* for sockets. */
+
+#define VKI_F_SETOWN_EX     15
+#define VKI_F_GETOWN_EX     16
+
+#define VKI_F_GETOWNER_UIDS 17
+
+#define VKI_F_OFD_GETLK     36
+#define VKI_F_OFD_SETLK     37
+#define VKI_F_OFD_SETLKW    38
+
+#define VKI_F_OWNER_TID     0
+#define VKI_F_OWNER_PID     1
+#define VKI_F_OWNER_PGRP    2
+
+struct vki_f_owner_ex {
+   int   type;
+   __vki_kernel_pid_t   pid;
+};
+
+#define VKI_FD_CLOEXEC 1  /* actually anything with low bit set goes */
+
+#define VKI_F_RDLCK    0
+#define VKI_F_WRLCK    1
+#define VKI_F_UNLCK    2
+
+#define VKI_F_EXLCK    4   /* or 3 */
+#define VKI_F_SHLCK    8   /* or 4 */
+
+#define VKI_LOCK_SH    1   /* shared lock */
+#define VKI_LOCK_EX    2   /* exclusive lock */
+#define VKI_LOCK_NB    4   /* or'd with one of the above to prevent blocking */
+#define VKI_LOCK_UN    8   /* remove lock */
+
+#define VKI_LOCK_MAND  32  /* This is a mandatory flock ... */
+#define VKI_LOCK_READ  64  /* which allows concurrent read operations */
+#define VKI_LOCK_WRITE 128 /* which allows concurrent write operations */
+#define VKI_LOCK_RW    192 /* which allows concurrent read & write ops */
+
+#define VKI_F_LINUX_SPECIFIC_BASE 1024
+
+//----------------------------------------------------------------------
+// From linux-5.19-rc1/include/uapi/linux/fcntl.h
+//----------------------------------------------------------------------
+
+#define VKI_AT_FDCWD -100 /* Special value used to indicate
+                             openat should use the current
+                             working directory. */
+
+//----------------------------------------------------------------------
+// From linux-5.19-rc1/include/uapi/asm-generic/resource.h
+//----------------------------------------------------------------------
+
+#define VKI_RLIMIT_DATA   2 /* max data size */
+#define VKI_RLIMIT_STACK  3 /* max stack size */
+#define VKI_RLIMIT_CORE   4 /* max core file size */
+#define VKI_RLIMIT_NOFILE 7 /* max number of open files */
+
+//----------------------------------------------------------------------
+// From linux-5.19-rc1/include/uapi/asm-generic/socket.h
+//----------------------------------------------------------------------
+
+#define VKI_SOL_SOCKET 1
+#define VKI_SO_TYPE    3
+
+#define VKI_SO_ATTACH_FILTER 26
+
+//----------------------------------------------------------------------
+// From linux-5.19-rc1/include/uapi/asm-generic/sockios.h
+//----------------------------------------------------------------------
+
+#define VKI_FIOSETOWN        0x8901
+#define VKI_SIOCSPGRP        0x8902
+#define VKI_FIOGETOWN        0x8903
+#define VKI_SIOCGPGRP        0x8904
+#define VKI_SIOCATMARK       0x8905
+#define VKI_SIOCGSTAMP_OLD   0x8906 /* Get stamp (timeval) */
+#define VKI_SIOCGSTAMPNS_OLD 0x8907 /* Get stamp (timespec) */
+
+//----------------------------------------------------------------------
+// From linux-5.19-rc1/include/uapi/linux/sockios.h
+//----------------------------------------------------------------------
+
+#define VKI_SIOCGSTAMP       VKI_SIOCGSTAMP_OLD
+#define VKI_SIOCGSTAMPNS     VKI_SIOCGSTAMPNS_OLD
+
+//----------------------------------------------------------------------
+// From linux-5.19-rc1/include/uapi/asm-generic/stat.h
+//----------------------------------------------------------------------
+
+struct vki_stat {
+   unsigned long st_dev;        /* Device.  */
+   unsigned long st_ino;        /* File serial number.  */
+   unsigned int  st_mode;       /* File mode.  */
+   unsigned int  st_nlink;      /* Link count.  */
+   unsigned int  st_uid;        /* User ID of the file's owner.  */
+   unsigned int  st_gid;        /* Group ID of the file's group. */
+   unsigned long st_rdev;       /* Device number, if device.  */
+   unsigned long __pad1;
+   long          st_size;       /* Size of file, in bytes.  */
+   int           st_blksize;    /* Optimal block size for I/O.  */
+   int           __pad2;
+   long          st_blocks;     /* Number 512-byte blocks allocated. */
+   long          st_atime;      /* Time of last access.  */
+   unsigned long st_atime_nsec;
+   long          st_mtime;      /* Time of last modification.  */
+   unsigned long st_mtime_nsec;
+   long          st_ctime;      /* Time of last status change.  */
+   unsigned long st_ctime_nsec;
+   unsigned int  __unused4;
+   unsigned int  __unused5;
+};
+
+struct vki_stat64 {
+   unsigned long long st_dev;        /* Device.  */
+   unsigned long long st_ino;        /* File serial number.  */
+   unsigned int       st_mode;       /* File mode.  */
+   unsigned int       st_nlink;      /* Link count.  */
+   unsigned int       st_uid;        /* User ID of the file's owner.  */
+   unsigned int       st_gid;        /* Group ID of the file's group. */
+   unsigned long long st_rdev;       /* Device number, if device.  */
+   unsigned long long __pad1;
+   long long          st_size;       /* Size of file, in bytes.  */
+   int                st_blksize;    /* Optimal block size for I/O.  */
+   int                __pad2;
+   long long          st_blocks;     /* Number 512-byte blocks allocated. */
+   int                st_atime;      /* Time of last access.  */
+   unsigned int       st_atime_nsec;
+   int                st_mtime;      /* Time of last modification.  */
+   unsigned int       st_mtime_nsec;
+   int                st_ctime;      /* Time of last status change.  */
+   unsigned int       st_ctime_nsec;
+   unsigned int       __unused4;
+   unsigned int       __unused5;
+};
+
+//----------------------------------------------------------------------
+// From linux-5.19-rc1/include/uapi/asm-generic/statfs.h
+//----------------------------------------------------------------------
+
+#define __vki_statfs_word __vki_kernel_long_t
+
+struct vki_statfs {
+   __vki_statfs_word f_type;
+   __vki_statfs_word f_bsize;
+   __vki_statfs_word f_blocks;
+   __vki_statfs_word f_bfree;
+   __vki_statfs_word f_bavail;
+   __vki_statfs_word f_files;
+   __vki_statfs_word f_ffree;
+   __vki_kernel_fsid_t f_fsid;
+   __vki_statfs_word f_namelen;
+   __vki_statfs_word f_frsize;
+   __vki_statfs_word f_flags;
+   __vki_statfs_word f_spare[4];
+};
+
+//----------------------------------------------------------------------
+// From linux-5.19-rc1/include/uapi/asm-generic/termios.h
+//----------------------------------------------------------------------
+
+struct vki_winsize {
+   unsigned short ws_row;
+   unsigned short ws_col;
+   unsigned short ws_xpixel;
+   unsigned short ws_ypixel;
+};
+
+#define VKI_NCC 8
+struct vki_termio {
+   unsigned short c_iflag;       /* input mode flags */
+   unsigned short c_oflag;       /* output mode flags */
+   unsigned short c_cflag;       /* control mode flags */
+   unsigned short c_lflag;       /* local mode flags */
+   unsigned char  c_line;        /* line discipline */
+   unsigned char  c_cc[VKI_NCC]; /* control characters */
+};
+
+//----------------------------------------------------------------------
+// From linux-5.19-rc1/include/uapi/asm-generic/termbits.h
+//----------------------------------------------------------------------
+
+typedef unsigned char vki_cc_t;
+typedef unsigned int  vki_speed_t;
+typedef unsigned int  vki_tcflag_t;
+
+#define VKI_NCCS 19
+struct vki_termios {
+   vki_tcflag_t c_iflag;     /* input mode flags */
+   vki_tcflag_t c_oflag;     /* output mode flags */
+   vki_tcflag_t c_cflag;     /* control mode flags */
+   vki_tcflag_t c_lflag;     /* local mode flags */
+   vki_cc_t c_line;          /* line discipline */
+   vki_cc_t c_cc[VKI_NCCS];  /* control characters */
+};
+
+//----------------------------------------------------------------------
+// From linux-5.19-rc1/include/uapi/asm-generic/ioctl.h
+//----------------------------------------------------------------------
+
+#define _VKI_IOC_NRBITS    8
+#define _VKI_IOC_TYPEBITS  8
+#define _VKI_IOC_SIZEBITS  14
+#define _VKI_IOC_DIRBITS   2
+
+#define _VKI_IOC_NRMASK    ((1 << _VKI_IOC_NRBITS)-1)
+#define _VKI_IOC_TYPEMASK  ((1 << _VKI_IOC_TYPEBITS)-1)
+#define _VKI_IOC_SIZEMASK  ((1 << _VKI_IOC_SIZEBITS)-1)
+#define _VKI_IOC_DIRMASK   ((1 << _VKI_IOC_DIRBITS)-1)
+
+#define _VKI_IOC_NRSHIFT   0
+#define _VKI_IOC_TYPESHIFT (_VKI_IOC_NRSHIFT+_VKI_IOC_NRBITS)
+#define _VKI_IOC_SIZESHIFT (_VKI_IOC_TYPESHIFT+_VKI_IOC_TYPEBITS)
+#define _VKI_IOC_DIRSHIFT  (_VKI_IOC_SIZESHIFT+_VKI_IOC_SIZEBITS)
+
+#define _VKI_IOC_NONE      0U
+#define _VKI_IOC_WRITE     1U
+#define _VKI_IOC_READ      2U
+
+#define _VKI_IOC(dir,type,nr,size) \
+        (((dir)  << _VKI_IOC_DIRSHIFT) | \
+         ((type) << _VKI_IOC_TYPESHIFT) | \
+         ((nr)   << _VKI_IOC_NRSHIFT) | \
+         ((size) << _VKI_IOC_SIZESHIFT))
+
+#define _VKI_IO(type,nr)            _VKI_IOC(_VKI_IOC_NONE,(type),(nr),0)
+#define _VKI_IOR(type,nr,size)      _VKI_IOC(_VKI_IOC_READ,(type),(nr),(_VKI_IOC_TYPECHECK(size)))
+#define _VKI_IOW(type,nr,size)      _VKI_IOC(_VKI_IOC_WRITE,(type),(nr),(_VKI_IOC_TYPECHECK(size)))
+#define _VKI_IOWR(type,nr,size)     _VKI_IOC(_VKI_IOC_READ|_VKI_IOC_WRITE,(type),(nr),(_VKI_IOC_TYPECHECK(size)))
+#define _VKI_IOR_BAD(type,nr,size)  _VKI_IOC(_VKI_IOC_READ,(type),(nr),sizeof(size))
+#define _VKI_IOW_BAD(type,nr,size)  _VKI_IOC(_VKI_IOC_WRITE,(type),(nr),sizeof(size))
+#define _VKI_IOWR_BAD(type,nr,size) _VKI_IOC(_VKI_IOC_READ|_VKI_IOC_WRITE,(type),(nr),sizeof(size))
+
+#define _VKI_IOC_DIR(nr)  (((nr) >> _VKI_IOC_DIRSHIFT) & _VKI_IOC_DIRMASK)
+#define _VKI_IOC_TYPE(nr) (((nr) >> _VKI_IOC_TYPESHIFT) & _VKI_IOC_TYPEMASK)
+#define _VKI_IOC_NR(nr)   (((nr) >> _VKI_IOC_NRSHIFT) & _VKI_IOC_NRMASK)
+#define _VKI_IOC_SIZE(nr) (((nr) >> _VKI_IOC_SIZESHIFT) & _VKI_IOC_SIZEMASK)
+
+//----------------------------------------------------------------------
+// From linux-5.19-rc1/include/uapi/asm-generic/ioctls.h
+//----------------------------------------------------------------------
+
+#define VKI_TCGETS       0x5401
+#define VKI_TCSETS       0x5402
+#define VKI_TCSETSW      0x5403
+#define VKI_TCSETSF      0x5404
+#define VKI_TCGETA       0x5405
+#define VKI_TCSETA       0x5406
+#define VKI_TCSETAW      0x5407
+#define VKI_TCSETAF      0x5408
+#define VKI_TCSBRK       0x5409
+#define VKI_TCXONC       0x540A
+#define VKI_TCFLSH       0x540B
+#define VKI_TIOCEXCL     0x540C
+#define VKI_TIOCNXCL     0x540D
+#define VKI_TIOCSCTTY    0x540E
+#define VKI_TIOCGPGRP    0x540F
+#define VKI_TIOCSPGRP    0x5410
+#define VKI_TIOCOUTQ     0x5411
+#define VKI_TIOCSTI      0x5412
+#define VKI_TIOCGWINSZ   0x5413
+#define VKI_TIOCSWINSZ   0x5414
+#define VKI_TIOCMGET     0x5415
+#define VKI_TIOCMBIS     0x5416
+#define VKI_TIOCMBIC     0x5417
+#define VKI_TIOCMSET     0x5418
+#define VKI_TIOCGSOFTCAR 0x5419
+#define VKI_TIOCSSOFTCAR 0x541A
+#define VKI_FIONREAD     0x541B
+#define VKI_TIOCINQ      VKI_FIONREAD
+#define VKI_TIOCLINUX    0x541C
+#define VKI_TIOCCONS     0x541D
+#define VKI_TIOCGSERIAL  0x541E
+#define VKI_TIOCSSERIAL  0x541F
+#define VKI_TIOCPKT      0x5420
+#define VKI_FIONBIO      0x5421
+#define VKI_TIOCNOTTY    0x5422
+#define VKI_TIOCSETD     0x5423
+#define VKI_TIOCGETD     0x5424
+#define VKI_TCSBRKP      0x5425   /* Needed for POSIX tcsendbreak() */
+#define VKI_TIOCSBRK     0x5427   /* BSD compatibility */
+#define VKI_TIOCCBRK     0x5428   /* BSD compatibility */
+#define VKI_TIOCGSID     0x5429   /* Return the session ID of FD */
+#define VKI_TCGETS2      _VKI_IOR('T', 0x2A, struct termios2)
+#define VKI_TCSETS2      _VKI_IOW('T', 0x2B, struct termios2)
+#define VKI_TCSETSW2     _VKI_IOW('T', 0x2C, struct termios2)
+#define VKI_TCSETSF2     _VKI_IOW('T', 0x2D, struct termios2)
+#define VKI_TIOCGRS485   0x542E
+#define VKI_TIOCSRS485   0x542F
+#define VKI_TIOCGPTN     _VKI_IOR('T', 0x30, unsigned int) /* Get Pty Number (of pty-mux device) */
+#define VKI_TIOCSPTLCK   _VKI_IOW('T', 0x31, int) /* Lock/unlock Pty */
+#define VKI_TIOCGDEV     _VKI_IOR('T', 0x32, unsigned int) /* Get primary device node of /dev/console */
+#define VKI_TCGETX       0x5432 /* SYS5 TCGETX compatibility */
+#define VKI_TCSETX       0x5433
+#define VKI_TCSETXF      0x5434
+#define VKI_TCSETXW      0x5435
+#define VKI_TIOCSIG      _VKI_IOW('T', 0x36, int) /* pty: generate signal */
+#define VKI_TIOCVHANGUP  0x5437
+#define VKI_TIOCGPKT     _VKI_IOR('T', 0x38, int) /* Get packet mode state */
+#define VKI_TIOCGPTLCK   _VKI_IOR('T', 0x39, int) /* Get Pty lock state */
+#define VKI_TIOCGEXCL    _VKI_IOR('T', 0x40, int) /* Get exclusive mode state */
+#define VKI_TIOCGPTPEER  _VKI_IO('T', 0x41)       /* Safely open the slave */
+#define VKI_TIOCGISO7816 _VKI_IOR('T', 0x42, struct serial_iso7816)
+#define VKI_TIOCSISO7816 _VKI_IOWR('T', 0x43, struct serial_iso7816)
+
+#define VKI_FIONCLEX        0x5450
+#define VKI_FIOCLEX         0x5451
+#define VKI_FIOASYNC        0x5452
+#define VKI_TIOCSERCONFIG   0x5453
+#define VKI_TIOCSERGWILD    0x5454
+#define VKI_TIOCSERSWILD    0x5455
+#define VKI_TIOCGLCKTRMIOS  0x5456
+#define VKI_TIOCSLCKTRMIOS  0x5457
+#define VKI_TIOCSERGSTRUCT  0x5458 /* For debugging only */
+#define VKI_TIOCSERGETLSR   0x5459 /* Get line status register */
+#define VKI_TIOCSERGETMULTI 0x545A /* Get multiport config  */
+#define VKI_TIOCSERSETMULTI 0x545B /* Set multiport config */
+
+#define VKI_TIOCMIWAIT      0x545C /* wait for a change on serial input line(s) */
+#define VKI_TIOCGICOUNT     0x545D /* read serial port inline interrupt counts */
+
+#define VKI_FIOQSIZE        0x5460
+
+#define VKI_TIOCPKT_DATA       0
+#define VKI_TIOCPKT_FLUSHREAD  1
+#define VKI_TIOCPKT_FLUSHWRITE 2
+#define VKI_TIOCPKT_STOP       4
+#define VKI_TIOCPKT_START      8
+#define VKI_TIOCPKT_NOSTOP    16
+#define VKI_TIOCPKT_DOSTOP    32
+#define VKI_TIOCPKT_IOCTL     64
+
+#define VKI_TIOCSER_TEMT 0x01 /* Transmitter physically empty */
+
+//----------------------------------------------------------------------
+// From linux-5.19-rc1/include/uapi/asm-generic/poll.h
+//----------------------------------------------------------------------
+
+#define VKI_POLLIN 0x0001
+
+struct vki_pollfd {
+   int   fd;
+   short events;
+   short revents;
+};
+
+//----------------------------------------------------------------------
+// From linux-5.19-rc1/arch/loongarch/include/asm/elf.h
+//----------------------------------------------------------------------
+
+#define VKI_ELF_NGREG  45
+#define VKI_ELF_NFPREG 34
+
+typedef unsigned long vki_elf_greg_t;
+typedef vki_elf_greg_t vki_elf_gregset_t[VKI_ELF_NGREG];
+
+typedef double vki_elf_fpreg_t;
+typedef vki_elf_fpreg_t vki_elf_fpregset_t[VKI_ELF_NFPREG];
+
+//----------------------------------------------------------------------
+// From linux-5.19-rc1/arch/loongarch/include/uapi/asm/ucontext.h
+//----------------------------------------------------------------------
+
+struct vki_ucontext {
+   unsigned long         uc_flags;
+   struct vki_ucontext   *uc_link;
+   vki_stack_t           uc_stack;
+   vki_sigset_t          uc_sigmask;
+   __vki_u8              __unused[1024 / 8 - sizeof(vki_sigset_t)];
+   struct vki_sigcontext uc_mcontext;
+};
+
+typedef char vki_modify_ldt_t;
+
+
+
+//----------------------------------------------------------------------
+// From linux-5.19-rc1/include/uapi/asm-generic/ipcbuf.h
+//----------------------------------------------------------------------
+
+struct vki_ipc64_perm {
+   __vki_kernel_key_t   key;
+   __vki_kernel_uid32_t uid;
+   __vki_kernel_gid32_t gid;
+   __vki_kernel_uid32_t cuid;
+   __vki_kernel_gid32_t cgid;
+   __vki_kernel_mode_t  mode;
+   unsigned char        __pad1[4 - sizeof(__vki_kernel_mode_t)]; /* pad if mode_t is u16: */
+   unsigned short       seq;
+   unsigned short       __pad2;
+   __vki_kernel_ulong_t __unused1;
+   __vki_kernel_ulong_t __unused2;
+};
+
+//----------------------------------------------------------------------
+// From linux-5.19-rc1/include/uapi/asm-generic/sembuf.h
+//----------------------------------------------------------------------
+struct vki_semid64_ds {
+   struct vki_ipc64_perm sem_perm;  /* permissions .. see ipc.h */
+   long                  sem_otime; /* last semop time */
+   long                  sem_ctime; /* last change time */
+   unsigned long         sem_nsems; /* no. of semaphores in array */
+   unsigned long         __unused3;
+   unsigned long         __unused4;
+};
+
+//----------------------------------------------------------------------
+// From linux-5.19-rc1/include/uapi/asm-generic/msgbuf.h
+//----------------------------------------------------------------------
+
+struct vki_msqid64_ds {
+   struct vki_ipc64_perm msg_perm;
+   long                  msg_stime;  /* last msgsnd time */
+   long                  msg_rtime;  /* last msgrcv time */
+   long                  msg_ctime;  /* last change time */
+   unsigned long         msg_cbytes; /* current number of bytes on queue */
+   unsigned long         msg_qnum;   /* number of messages in queue */
+   unsigned long         msg_qbytes; /* max number of bytes on queue */
+   __vki_kernel_pid_t    msg_lspid;  /* pid of last msgsnd */
+   __vki_kernel_pid_t    msg_lrpid;  /* last receive pid */
+   unsigned long         __unused4;
+   unsigned long         __unused5;
+};
+
+//----------------------------------------------------------------------
+// From linux-5.19-rc1/include/uapi/asm-generic/shmbuf.h
+//----------------------------------------------------------------------
+
+struct vki_shmid64_ds {
+   struct vki_ipc64_perm shm_perm;   /* operation perms */
+   vki_size_t            shm_segsz;  /* size of segment (bytes) */
+   long                  shm_atime;  /* last attach time */
+   long                  shm_dtime;  /* last detach time */
+   long                  shm_ctime;  /* last change time */
+   __vki_kernel_pid_t    shm_cpid;   /* pid of creator */
+   __vki_kernel_pid_t    shm_lpid;   /* pid of last operator */
+   unsigned long         shm_nattch; /* no. of current attaches */
+   unsigned long         __unused4;
+   unsigned long         __unused5;
+};
+
+struct vki_shminfo64 {
+   unsigned long shmmax;
+   unsigned long shmmin;
+   unsigned long shmmni;
+   unsigned long shmseg;
+   unsigned long shmall;
+   unsigned long __unused1;
+   unsigned long __unused2;
+   unsigned long __unused3;
+   unsigned long __unused4;
+};
+
+//----------------------------------------------------------------------
+// From linux-5.19-rc1/arch/loongarch/include/uapi/asm/ptrace.h
+//----------------------------------------------------------------------
+
+struct vki_user_pt_regs {
+   /* Saved main processor registers. */
+   unsigned long regs[32];
+
+   /* Original syscall arg0. */
+   unsigned long orig_a0;
+
+   /* Saved special registers. */
+   unsigned long csr_era;
+   unsigned long csr_badv;
+   unsigned long reserved[10];
+} __attribute__((aligned(8)));
+
+#define vki_user_regs_struct vki_user_pt_regs
+
+struct vki_user_fp_state {
+   vki_uint64_t fpr[32];
+   vki_uint64_t fcc;
+   vki_uint32_t fcsr;
+};
+
+//----------------------------------------------------------------------
+// From linux-5.19-rc1/include/uapi/asm-generic/errno.h
+//----------------------------------------------------------------------
+
+#define VKI_ENOSYS     38 /* Invalid system call number */
+#define VKI_EOVERFLOW  75 /* Value too large for defined data type */
+
+#endif // __VKI_LOONGARCH64_LINUX_H
+
+/*--------------------------------------------------------------------*/
+/*--- end                                  vki-loongarch64-linux.h ---*/
+/*--------------------------------------------------------------------*/
diff --git a/include/vki/vki-posixtypes-loongarch64-linux.h b/include/vki/vki-posixtypes-loongarch64-linux.h
new file mode 100644
index 000000000..0282a2a39
--- /dev/null
+++ b/include/vki/vki-posixtypes-loongarch64-linux.h
@@ -0,0 +1,76 @@
+
+/*--------------------------------------------------------------------*/
+/*--- loongarch/Linux-specific kernel interface: posix types.      ---*/
+/*---                           vki-posixtypes-loongarch64-linux.h ---*/
+/*--------------------------------------------------------------------*/
+
+/*
+   This file is part of Valgrind, a dynamic binary instrumentation
+   framework.
+
+   Copyright (C) 2021-2022 Loongson Technology Corporation Limited
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, see <http://www.gnu.org/licenses/>.
+
+   The GNU General Public License is contained in the file COPYING.
+*/
+
+#ifndef __VKI_POSIXTYPES_LOONGARCH64_LINUX_H
+#define __VKI_POSIXTYPES_LOONGARCH64_LINUX_H
+
+//----------------------------------------------------------------------
+// From linux-5.19-rc1/include/uapi/asm-generic/posix_types.h
+//----------------------------------------------------------------------
+
+typedef long                 __vki_kernel_long_t;
+typedef unsigned long        __vki_kernel_ulong_t;
+typedef __vki_kernel_ulong_t __vki_kernel_ino_t;
+typedef unsigned int         __vki_kernel_mode_t;
+typedef int                  __vki_kernel_pid_t;
+typedef int                  __vki_kernel_ipc_pid_t;
+typedef unsigned int         __vki_kernel_uid_t;
+typedef unsigned int         __vki_kernel_gid_t;
+typedef __vki_kernel_long_t  __vki_kernel_suseconds_t;
+typedef int                  __vki_kernel_daddr_t;
+typedef unsigned int         __vki_kernel_uid32_t;
+typedef unsigned int         __vki_kernel_gid32_t;
+typedef __vki_kernel_uid_t   __vki_kernel_old_uid_t;
+typedef __vki_kernel_gid_t   __vki_kernel_old_gid_t;
+typedef unsigned int         __vki_kernel_old_dev_t;
+
+typedef __vki_kernel_ulong_t __vki_kernel_size_t;
+typedef __vki_kernel_long_t  __vki_kernel_ssize_t;
+typedef __vki_kernel_long_t  __vki_kernel_ptrdiff_t;
+
+typedef struct {
+   int val[2];
+} __vki_kernel_fsid_t;
+
+typedef __vki_kernel_long_t  __vki_kernel_off_t;
+typedef long long            __vki_kernel_loff_t;
+typedef __vki_kernel_long_t  __vki_kernel_old_time_t;
+typedef __vki_kernel_long_t  __vki_kernel_time_t;
+typedef long long            __vki_kernel_time64_t;
+typedef __vki_kernel_long_t  __vki_kernel_clock_t;
+typedef int                  __vki_kernel_timer_t;
+typedef int                  __vki_kernel_clockid_t;
+typedef char *               __vki_kernel_caddr_t;
+typedef unsigned short       __vki_kernel_uid16_t;
+typedef unsigned short       __vki_kernel_gid16_t;
+
+#endif // __VKI_POSIXTYPES_LOONGARCH64_LINUX_H
+
+/*--------------------------------------------------------------------*/
+/*--- end                       vki-posixtypes-loongarch64-linux.h ---*/
+/*--------------------------------------------------------------------*/
diff --git a/include/vki/vki-scnums-loongarch64-linux.h b/include/vki/vki-scnums-loongarch64-linux.h
new file mode 100644
index 000000000..9390010d6
--- /dev/null
+++ b/include/vki/vki-scnums-loongarch64-linux.h
@@ -0,0 +1,356 @@
+/*--------------------------------------------------------------------*/
+/*--- System call numbers for loongarch-linux.                     ---*/
+/*---                               vki-scnums-loongarch64-linux.h ---*/
+/*--------------------------------------------------------------------*/
+
+/*
+   This file is part of Valgrind, a dynamic binary instrumentation
+   framework.
+
+   Copyright (C) 2021-2022 Loongson Technology Corporation Limited
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, see <http://www.gnu.org/licenses/>.
+
+   The GNU General Public License is contained in the file COPYING.
+*/
+
+#ifndef __VKI_SCNUMS_LOONGARCH64_LINUX_H
+#define __VKI_SCNUMS_LOONGARCH64_LINUX_H
+
+//----------------------------------------------------------------------
+// From linux-5.19-rc1/include/uapi/asm-generic/unistd.h
+//----------------------------------------------------------------------
+
+#define __NR_io_setup 0
+#define __NR_io_destroy 1
+#define __NR_io_submit 2
+#define __NR_io_cancel 3
+#define __NR_io_getevents 4
+#define __NR_setxattr 5
+#define __NR_lsetxattr 6
+#define __NR_fsetxattr 7
+#define __NR_getxattr 8
+#define __NR_lgetxattr 9
+#define __NR_fgetxattr 10
+#define __NR_listxattr 11
+#define __NR_llistxattr 12
+#define __NR_flistxattr 13
+#define __NR_removexattr 14
+#define __NR_lremovexattr 15
+#define __NR_fremovexattr 16
+#define __NR_getcwd 17
+#define __NR_lookup_dcookie 18
+#define __NR_eventfd2 19
+#define __NR_epoll_create1 20
+#define __NR_epoll_ctl 21
+#define __NR_epoll_pwait 22
+#define __NR_dup 23
+#define __NR_dup3 24
+#define __NR3264_fcntl 25
+#define __NR_inotify_init1 26
+#define __NR_inotify_add_watch 27
+#define __NR_inotify_rm_watch 28
+#define __NR_ioctl 29
+#define __NR_ioprio_set 30
+#define __NR_ioprio_get 31
+#define __NR_flock 32
+#define __NR_mknodat 33
+#define __NR_mkdirat 34
+#define __NR_unlinkat 35
+#define __NR_symlinkat 36
+#define __NR_linkat 37
+// #define __NR_renameat 38
+#define __NR_umount2 39
+#define __NR_mount 40
+#define __NR_pivot_root 41
+#define __NR_nfsservctl 42
+#define __NR3264_statfs 43
+#define __NR3264_fstatfs 44
+#define __NR3264_truncate 45
+#define __NR3264_ftruncate 46
+#define __NR_fallocate 47
+#define __NR_faccessat 48
+#define __NR_chdir 49
+#define __NR_fchdir 50
+#define __NR_chroot 51
+#define __NR_fchmod 52
+#define __NR_fchmodat 53
+#define __NR_fchownat 54
+#define __NR_fchown 55
+#define __NR_openat 56
+#define __NR_close 57
+#define __NR_vhangup 58
+#define __NR_pipe2 59
+#define __NR_quotactl 60
+#define __NR_getdents64 61
+#define __NR3264_lseek 62
+#define __NR_read 63
+#define __NR_write 64
+#define __NR_readv 65
+#define __NR_writev 66
+#define __NR_pread64 67
+#define __NR_pwrite64 68
+#define __NR_preadv 69
+#define __NR_pwritev 70
+#define __NR3264_sendfile 71
+#define __NR_pselect6 72
+#define __NR_ppoll 73
+#define __NR_signalfd4 74
+#define __NR_vmsplice 75
+#define __NR_splice 76
+#define __NR_tee 77
+#define __NR_readlinkat 78
+// #define __NR3264_fstatat 79
+// #define __NR3264_fstat 80
+#define __NR_sync 81
+#define __NR_fsync 82
+#define __NR_fdatasync 83
+#define __NR_sync_file_range 84
+#define __NR_timerfd_create 85
+#define __NR_timerfd_settime 86
+#define __NR_timerfd_gettime 87
+#define __NR_utimensat 88
+#define __NR_acct 89
+#define __NR_capget 90
+#define __NR_capset 91
+#define __NR_personality 92
+#define __NR_exit 93
+#define __NR_exit_group 94
+#define __NR_waitid 95
+#define __NR_set_tid_address 96
+#define __NR_unshare 97
+#define __NR_futex 98
+#define __NR_set_robust_list 99
+#define __NR_get_robust_list 100
+#define __NR_nanosleep 101
+#define __NR_getitimer 102
+#define __NR_setitimer 103
+#define __NR_kexec_load 104
+#define __NR_init_module 105
+#define __NR_delete_module 106
+#define __NR_timer_create 107
+#define __NR_timer_gettime 108
+#define __NR_timer_getoverrun 109
+#define __NR_timer_settime 110
+#define __NR_timer_delete 111
+#define __NR_clock_settime 112
+#define __NR_clock_gettime 113
+#define __NR_clock_getres 114
+#define __NR_clock_nanosleep 115
+#define __NR_syslog 116
+#define __NR_ptrace 117
+#define __NR_sched_setparam 118
+#define __NR_sched_setscheduler 119
+#define __NR_sched_getscheduler 120
+#define __NR_sched_getparam 121
+#define __NR_sched_setaffinity 122
+#define __NR_sched_getaffinity 123
+#define __NR_sched_yield 124
+#define __NR_sched_get_priority_max 125
+#define __NR_sched_get_priority_min 126
+#define __NR_sched_rr_get_interval 127
+#define __NR_restart_syscall 128
+#define __NR_kill 129
+#define __NR_tkill 130
+#define __NR_tgkill 131
+#define __NR_sigaltstack 132
+#define __NR_rt_sigsuspend 133
+#define __NR_rt_sigaction 134
+#define __NR_rt_sigprocmask 135
+#define __NR_rt_sigpending 136
+#define __NR_rt_sigtimedwait 137
+#define __NR_rt_sigqueueinfo 138
+#define __NR_rt_sigreturn 139
+#define __NR_setpriority 140
+#define __NR_getpriority 141
+#define __NR_reboot 142
+#define __NR_setregid 143
+#define __NR_setgid 144
+#define __NR_setreuid 145
+#define __NR_setuid 146
+#define __NR_setresuid 147
+#define __NR_getresuid 148
+#define __NR_setresgid 149
+#define __NR_getresgid 150
+#define __NR_setfsuid 151
+#define __NR_setfsgid 152
+#define __NR_times 153
+#define __NR_setpgid 154
+#define __NR_getpgid 155
+#define __NR_getsid 156
+#define __NR_setsid 157
+#define __NR_getgroups 158
+#define __NR_setgroups 159
+#define __NR_uname 160
+#define __NR_sethostname 161
+#define __NR_setdomainname 162
+// #define __NR_getrlimit 163
+// #define __NR_setrlimit 164
+#define __NR_getrusage 165
+#define __NR_umask 166
+#define __NR_prctl 167
+#define __NR_getcpu 168
+#define __NR_gettimeofday 169
+#define __NR_settimeofday 170
+#define __NR_adjtimex 171
+#define __NR_getpid 172
+#define __NR_getppid 173
+#define __NR_getuid 174
+#define __NR_geteuid 175
+#define __NR_getgid 176
+#define __NR_getegid 177
+#define __NR_gettid 178
+#define __NR_sysinfo 179
+#define __NR_mq_open 180
+#define __NR_mq_unlink 181
+#define __NR_mq_timedsend 182
+#define __NR_mq_timedreceive 183
+#define __NR_mq_notify 184
+#define __NR_mq_getsetattr 185
+#define __NR_msgget 186
+#define __NR_msgctl 187
+#define __NR_msgrcv 188
+#define __NR_msgsnd 189
+#define __NR_semget 190
+#define __NR_semctl 191
+#define __NR_semtimedop 192
+#define __NR_semop 193
+#define __NR_shmget 194
+#define __NR_shmctl 195
+#define __NR_shmat 196
+#define __NR_shmdt 197
+#define __NR_socket 198
+#define __NR_socketpair 199
+#define __NR_bind 200
+#define __NR_listen 201
+#define __NR_accept 202
+#define __NR_connect 203
+#define __NR_getsockname 204
+#define __NR_getpeername 205
+#define __NR_sendto 206
+#define __NR_recvfrom 207
+#define __NR_setsockopt 208
+#define __NR_getsockopt 209
+#define __NR_shutdown 210
+#define __NR_sendmsg 211
+#define __NR_recvmsg 212
+#define __NR_readahead 213
+#define __NR_brk 214
+#define __NR_munmap 215
+#define __NR_mremap 216
+#define __NR_add_key 217
+#define __NR_request_key 218
+#define __NR_keyctl 219
+#define __NR_clone 220
+#define __NR_execve 221
+#define __NR3264_mmap 222
+#define __NR3264_fadvise64 223
+#define __NR_swapon 224
+#define __NR_swapoff 225
+#define __NR_mprotect 226
+#define __NR_msync 227
+#define __NR_mlock 228
+#define __NR_munlock 229
+#define __NR_mlockall 230
+#define __NR_munlockall 231
+#define __NR_mincore 232
+#define __NR_madvise 233
+#define __NR_remap_file_pages 234
+#define __NR_mbind 235
+#define __NR_get_mempolicy 236
+#define __NR_set_mempolicy 237
+#define __NR_migrate_pages 238
+#define __NR_move_pages 239
+#define __NR_rt_tgsigqueueinfo 240
+#define __NR_perf_event_open 241
+#define __NR_accept4 242
+#define __NR_recvmmsg 243
+
+#define __NR_wait4 260
+#define __NR_prlimit64 261
+#define __NR_fanotify_init 262
+#define __NR_fanotify_mark 263
+#define __NR_name_to_handle_at 264
+#define __NR_open_by_handle_at 265
+#define __NR_clock_adjtime 266
+#define __NR_syncfs 267
+#define __NR_setns 268
+#define __NR_sendmmsg 269
+#define __NR_process_vm_readv 270
+#define __NR_process_vm_writev 271
+#define __NR_kcmp 272
+#define __NR_finit_module 273
+#define __NR_sched_setattr 274
+#define __NR_sched_getattr 275
+#define __NR_renameat2 276
+#define __NR_seccomp 277
+#define __NR_getrandom 278
+#define __NR_memfd_create 279
+#define __NR_bpf 280
+#define __NR_execveat 281
+#define __NR_userfaultfd 282
+#define __NR_membarrier 283
+#define __NR_mlock2 284
+#define __NR_copy_file_range 285
+#define __NR_preadv2 286
+#define __NR_pwritev2 287
+#define __NR_pkey_mprotect 288
+#define __NR_pkey_alloc 289
+#define __NR_pkey_free 290
+#define __NR_statx 291
+#define __NR_io_pgetevents 292
+#define __NR_rseq 293
+#define __NR_kexec_file_load 294
+
+#define __NR_pidfd_send_signal 424
+#define __NR_io_uring_setup 425
+#define __NR_io_uring_enter 426
+#define __NR_io_uring_register 427
+#define __NR_open_tree 428
+#define __NR_move_mount 429
+#define __NR_fsopen 430
+#define __NR_fsconfig 431
+#define __NR_fsmount 432
+#define __NR_fspick 433
+#define __NR_pidfd_open 434
+#define __NR_clone3 435
+#define __NR_close_range 436
+#define __NR_openat2 437
+#define __NR_pidfd_getfd 438
+#define __NR_faccessat2 439
+#define __NR_process_madvise 440
+#define __NR_epoll_pwait2 441
+#define __NR_mount_setattr 442
+#define __NR_quotactl_fd 443
+#define __NR_landlock_create_ruleset 444
+#define __NR_landlock_add_rule 445
+#define __NR_landlock_restrict_self 446
+// #define __NR_memfd_secret 447
+#define __NR_process_mrelease 448
+
+#define __NR_fcntl __NR3264_fcntl
+#define __NR_statfs __NR3264_statfs
+#define __NR_fstatfs __NR3264_fstatfs
+#define __NR_truncate __NR3264_truncate
+#define __NR_ftruncate __NR3264_ftruncate
+#define __NR_lseek __NR3264_lseek
+#define __NR_sendfile __NR3264_sendfile
+#define __NR_mmap __NR3264_mmap
+#define __NR_fadvise64 __NR3264_fadvise64
+
+#endif /* __VKI_SCNUMS_LOONGARCH64_LINUX_H */
+
+/*--------------------------------------------------------------------*/
+/*--- end                           vki-scnums-loongarch64-linux.h ---*/
+/*--------------------------------------------------------------------*/
diff --git a/memcheck/mc_machine.c b/memcheck/mc_machine.c
index 176c8e5cb..697321c5f 100644
--- a/memcheck/mc_machine.c
+++ b/memcheck/mc_machine.c
@@ -1396,6 +1396,12 @@ static Int get_otrack_shadow_offset_wrk ( Int offset, Int szB )
 #  undef GOF
 #  undef SZB
 
+   /* ----------------- loongarch64 ----------------- */
+
+#  elif defined(VGA_loongarch64)
+
+   /* TODO */
+
 #  else
 #    error "FIXME: not implemented for this architecture"
 #  endif
@@ -1517,6 +1523,10 @@ IRType MC_(get_otrack_reg_array_equiv_int_type) ( IRRegArray* arr )
    VG_(printf)("\n");
    tl_assert(0);
 
+   /* ----------------- loongarch64 ----------------- */
+#  elif defined(VGA_loongarch64)
+   /* TODO */
+
 #  else
 #    error "FIXME: not implemented for this architecture"
 #  endif
diff --git a/memcheck/tests/atomic_incs.c b/memcheck/tests/atomic_incs.c
index 1c738c530..83deeafca 100644
--- a/memcheck/tests/atomic_incs.c
+++ b/memcheck/tests/atomic_incs.c
@@ -245,6 +245,9 @@ __attribute__((noinline)) void atomic_add_8bit ( char* p, int n )
       );
    } while (block[2] != 1);
 #endif
+#elif defined(VGA_loongarch64)
+   /* TODO */
+   assert(0);
 #else
 # error "Unsupported arch"
 #endif
@@ -461,6 +464,9 @@ __attribute__((noinline)) void atomic_add_16bit ( short* p, int n )
       );
    } while (block[2] != 1);
 #endif
+#elif defined(VGA_loongarch64)
+   /* TODO */
+   assert(0);
 #else
 # error "Unsupported arch"
 #endif
@@ -616,6 +622,9 @@ __attribute__((noinline)) void atomic_add_32bit ( int* p, int n )
          : /*trash*/ "memory", "t0", "t1", "t2", "t3"
       );
    } while (block[2] != 1);
+#elif defined(VGA_loongarch64)
+   /* TODO */
+   assert(0);
 #else
 # error "Unsupported arch"
 #endif
@@ -718,6 +727,9 @@ __attribute__((noinline)) void atomic_add_64bit ( long long int* p, int n )
          : /*trash*/ "memory", "t0", "t1", "t2", "t3"
       );
    } while (block[2] != 1);
+#elif defined(VGA_loongarch64)
+   /* TODO */
+   assert(0);
 #else
 # error "Unsupported arch"
 #endif
@@ -731,7 +743,8 @@ __attribute__((noinline)) void atomic_add_128bit ( MyU128* p,
     || defined(VGA_amd64) \
     || defined(VGA_ppc64be) || defined(VGA_ppc64le) \
     || defined(VGA_arm) \
-    || defined(VGA_s390x)
+    || defined(VGA_s390x) \
+    || defined(VGA_loongarch64)
    /* do nothing; is not supported */
 #elif defined(VGA_arm64)
    unsigned long long int block[3]
diff --git a/memcheck/tests/unit_libcbase.c b/memcheck/tests/unit_libcbase.c
index 0ce65be26..48036033e 100644
--- a/memcheck/tests/unit_libcbase.c
+++ b/memcheck/tests/unit_libcbase.c
@@ -9,14 +9,14 @@
 #include "pub_tool_vki.h"
 #include "m_libcbase.c"
 
-/* On PPC, MIPS and ARM64 Linux VKI_PAGE_SIZE is a variable, not a macro. */
+/* On PPC, MIPS, ARM64 and LOONGARCH64 Linux VKI_PAGE_SIZE is a variable, not a macro. */
 #if defined(VGP_ppc32_linux) || defined(VGP_ppc64be_linux) \
     || defined(VGP_ppc64le_linux)
 unsigned long VKI_PAGE_SIZE  = 1UL << 12;
 #elif defined(VGP_arm64_linux)
 unsigned long VKI_PAGE_SIZE  = 1UL << 16;
 #elif defined(VGP_mips32_linux) || defined(VGP_mips64_linux) \
-    || defined (VGP_nanomips_linux)
+    || defined (VGP_nanomips_linux) || defined(VGP_loongarch64_linux)
 #include <unistd.h>
 unsigned long VKI_PAGE_SIZE;
 #endif
diff --git a/none/tests/libvex_test.c b/none/tests/libvex_test.c
index 5b57a4c2e..3080ce667 100644
--- a/none/tests/libvex_test.c
+++ b/none/tests/libvex_test.c
@@ -76,6 +76,8 @@ __attribute__((noinline)) static void get_guest_arch(VexArch    *ga)
    *ga = VexArchMIPS64;
 #elif defined(VGA_nanomips)
    *ga = VexArchNANOMIPS;
+#elif defined(VGA_loongarch64)
+   *ga = VexArchLOONGARCH64;
 #else
    missing arch;
 #endif
@@ -113,6 +115,7 @@ static VexEndness arch_endness (VexArch va) {
          else
             return VexEndnessBE;
       }
+   case VexArchLOONGARCH64: return VexEndnessLE;
    default: failure_exit();
    }
 }
@@ -139,6 +142,7 @@ static UInt arch_hwcaps (VexArch va) {
    case VexArchMIPS64: return VEX_PRID_COMP_MIPS | VEX_MIPS_HOST_FR;
 #endif
    case VexArchNANOMIPS: return 0;
+   case VexArchLOONGARCH64: return VEX_HWCAPS_LOONGARCH_ISA_64BIT;
    default: failure_exit();
    }
 }
@@ -156,6 +160,7 @@ static Bool mode64 (VexArch va) {
    case VexArchMIPS32: return False;
    case VexArchMIPS64: return True;
    case VexArchNANOMIPS: return False;
+   case VexArchLOONGARCH64: return True;
    default: failure_exit();
    }
 }
@@ -275,7 +280,7 @@ int main(int argc, char **argv)
    // explicitly via command line arguments.
    if (multiarch) {
       VexArch va;
-      for (va = VexArchX86; va <= VexArchNANOMIPS; va++) {
+      for (va = VexArchX86; va <= VexArchLOONGARCH64; va++) {
          vta.arch_host = va;
          vta.archinfo_host.endness = arch_endness (vta.arch_host);
          vta.archinfo_host.hwcaps = arch_hwcaps (vta.arch_host);
diff --git a/tests/Makefile.am b/tests/Makefile.am
index 916e5085d..e21f68bf5 100644
--- a/tests/Makefile.am
+++ b/tests/Makefile.am
@@ -52,7 +52,8 @@ check_PROGRAMS = \
 	power_insn_available \
 	is_ppc64_BE \
 	min_power_isa \
-	arm64_features
+	arm64_features \
+	loongarch64_features
 
 
 AM_CFLAGS   += $(AM_FLAG_M3264_PRI)
diff --git a/tests/arch_test.c b/tests/arch_test.c
index 37cc1bc76..97b6bc7c8 100644
--- a/tests/arch_test.c
+++ b/tests/arch_test.c
@@ -34,6 +34,7 @@ char* all_archs[] = {
    "mips32",
    "mips64",
    "nanomips",
+   "loongarch64",
    NULL
 };
 
@@ -79,6 +80,10 @@ static Bool go(char* arch)
 
 #elif defined(VGP_nanomips_linux)
    if ( 0 == strcmp( arch, "nanomips" ) ) return True;
+
+#elif defined(VGP_loongarch64_linux)
+   if ( 0 == strcmp( arch, "loongarch64" ) ) return True;
+
 #else
 #  error Unknown platform
 #endif   // VGP_*
diff --git a/tests/loongarch64_features.c b/tests/loongarch64_features.c
new file mode 100644
index 000000000..45ba2d1c0
--- /dev/null
+++ b/tests/loongarch64_features.c
@@ -0,0 +1,81 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+// This file determines loongarch64 features a processor supports.
+// For now, we only support loongarch64-linux.
+//
+// We return:
+// - 0 if the machine has the asked-for feature.
+// - 1 if the machine doesn't have the asked-for feature.
+// - 2 if the asked-for feature isn't recognised (this will always be the case
+//     for any feature if run on a non-loongarch64 machine).
+// - 3 if there was a usage error (it also prints an error message).
+#define FEATURE_PRESENT       0
+#define FEATURE_NOT_PRESENT   1
+#define UNRECOGNISED_FEATURE  2
+#define USAGE_ERROR           3
+
+#if defined(VGA_loongarch64)
+
+static int go(const char* feature_name)
+{
+   int i, len, found;
+   FILE* fp;
+   char buf[256];
+   const char* features[] = {
+      "cpucfg", "lam", "ual", "fpu",
+      "lsx", "lasx", "complex", "crypto",
+      "lvz", "lbt_x86", "lbt_arm", "lbt_mips"
+   };
+
+   found = 0;
+   len = sizeof(features) / sizeof(features[0]);
+   for (i = 0; i < len; i++) {
+      if (strcmp(feature_name, features[i]) == 0) {
+         found = 1;
+         break;
+      }
+   }
+
+   if (!found)
+      return UNRECOGNISED_FEATURE;
+
+   fp = fopen("/proc/cpuinfo", "r");
+   if(fp == NULL)
+      return UNRECOGNISED_FEATURE;
+
+   while (fgets(buf, sizeof(buf), fp) != NULL) {
+      if (strstr(buf, feature_name) != NULL) {
+         fclose(fp);
+         return FEATURE_PRESENT;
+      }
+   }
+
+   fclose(fp);
+   return FEATURE_NOT_PRESENT;
+}
+
+#else
+
+static int go(const char* feature_name)
+{
+   // Feature not recognised (non-loongarch64 machine!)
+   return UNRECOGNISED_FEATURE;
+}
+
+#endif // defined(VGA_loongarch64)
+
+
+//---------------------------------------------------------------------------
+// main
+//---------------------------------------------------------------------------
+int main(int argc, char **argv)
+{
+   if (argc != 2) {
+      fprintf(stderr, "usage: loongarch64_features <feature>\n");
+      exit(USAGE_ERROR);
+   }
+
+   return go(argv[1]);
+}
diff --git a/tests/platform_test b/tests/platform_test
index c23a4f645..a1eaf8f1c 100644
--- a/tests/platform_test
+++ b/tests/platform_test
@@ -14,6 +14,7 @@ all_platforms=
 all_platforms="$all_platforms x86-linux amd64-linux ppc32-linux ppc64-linux"
 all_platforms="$all_platforms arm-linux arm64-linux"
 all_platforms="$all_platforms s390x-linux mips32-linux mips64-linux"
+all_platforms="$all_platforms loongarch64-linux"
 all_platforms="$all_platforms x86-darwin amd64-darwin"
 all_platforms="$all_platforms x86-solaris amd64-solaris"
 all_platforms="$all_platforms x86-freebsd amd64-freebsd"
-- 
2.39.1

