From 79783a901891829b825fcd05da132269be1e2054 Mon Sep 17 00:00:00 2001
From: Eric Long <i@hack3r.moe>
Date: Sat, 8 Feb 2025 08:52:06 +0000
Subject: [PATCH] Use khronos-egl crate instead of egl

---
 src/sys_info_v2/gatherer/Cargo.lock           |  65 ++---
 src/sys_info_v2/gatherer/Cargo.toml           |   6 +-
 .../src/platform/linux/gpu_info/mod.rs        | 251 ++++++++++--------
 3 files changed, 168 insertions(+), 154 deletions(-)

diff --git a/src/sys_info_v2/gatherer/Cargo.lock b/src/sys_info_v2/gatherer/Cargo.lock
index fa88391..5d93597 100644
--- a/src/sys_info_v2/gatherer/Cargo.lock
+++ b/src/sys_info_v2/gatherer/Cargo.lock
@@ -1,6 +1,6 @@
 # This file is automatically @generated by Cargo.
 # It is not intended for manual editing.
-version = 3
+version = 4
 
 [[package]]
 name = "adler2"
@@ -120,7 +120,7 @@ dependencies = [
  "hex",
  "ignore",
  "jobserver",
- "libc 0.2.159",
+ "libc",
  "miow",
  "same-file",
  "sha2",
@@ -188,7 +188,7 @@ source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "91e195e091a93c46f7102ec7818a2aa394e1e1771c3ab4825963fa03e45afb8f"
 dependencies = [
  "core-foundation-sys",
- "libc 0.2.159",
+ "libc",
 ]
 
 [[package]]
@@ -203,7 +203,7 @@ version = "0.2.14"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "608697df725056feaccfa42cffdaeeec3fccc4ffc38358ecd19b243e716a78e0"
 dependencies = [
- "libc 0.2.159",
+ "libc",
 ]
 
 [[package]]
@@ -262,7 +262,7 @@ version = "0.9.7"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "1bb21987b9fb1613058ba3843121dd18b163b254d8a6e797e144cbac14d96d1b"
 dependencies = [
- "libc 0.2.159",
+ "libc",
  "libdbus-sys",
  "winapi",
 ]
@@ -330,20 +330,10 @@ version = "0.8.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "bafb66c8dbc944d69e15cfcc661df7e703beffbaec8bd63151368b06c5f9858c"
 dependencies = [
- "libc 0.2.159",
+ "libc",
  "linux-raw-sys 0.6.5",
 ]
 
-[[package]]
-name = "egl"
-version = "0.2.7"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "a373bc9844200b1ff15bd1b245931d1c20d09d06e4ec09f361171f29a4b0752d"
-dependencies = [
- "khronos",
- "libc 0.2.159",
-]
-
 [[package]]
 name = "either"
 version = "1.13.0"
@@ -356,7 +346,7 @@ version = "0.3.9"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "534c5cf6194dfab3db3242765c03bbe257cf92f22b38f6bc0c58d59108a820ba"
 dependencies = [
- "libc 0.2.159",
+ "libc",
  "windows-sys 0.52.0",
 ]
 
@@ -373,7 +363,7 @@ source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "35c0522e981e68cbfa8c3f978441a5f34b30b96e146b33cd3359176b50fe8586"
 dependencies = [
  "cfg-if",
- "libc 0.2.159",
+ "libc",
  "libredox",
  "windows-sys 0.59.0",
 ]
@@ -412,12 +402,12 @@ dependencies = [
  "dbus",
  "dbus-crossroads",
  "drm",
- "egl",
  "flate2",
  "gbm",
  "glob",
+ "khronos-egl",
  "lazy_static",
- "libc 0.2.159",
+ "libc",
  "libloading",
  "log",
  "nix",
@@ -443,7 +433,7 @@ dependencies = [
  "drm",
  "drm-fourcc",
  "gbm-sys",
- "libc 0.2.159",
+ "libc",
 ]
 
 [[package]]
@@ -452,7 +442,7 @@ version = "0.3.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "a9cc2f64de9fa707b5c6b2d2f10d7a7e49e845018a9f5685891eb40d3bab2538"
 dependencies = [
- "libc 0.2.159",
+ "libc",
 ]
 
 [[package]]
@@ -472,7 +462,7 @@ source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "c4567c8db10ae91089c99af84c68c38da3ec2f087c3f82960bcdbf3656b6f4d7"
 dependencies = [
  "cfg-if",
- "libc 0.2.159",
+ "libc",
  "wasi",
 ]
 
@@ -545,16 +535,17 @@ version = "0.1.32"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "48d1dbcbbeb6a7fec7e059840aa538bd62aaccf972c7346c4d9d2059312853d0"
 dependencies = [
- "libc 0.2.159",
+ "libc",
 ]
 
 [[package]]
-name = "khronos"
-version = "0.1.2"
+name = "khronos-egl"
+version = "6.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "c0711aaa80e6ba6eb1fa8978f1f46bfcb38ceb2f3f33f3736efbff39dac89f50"
+checksum = "6aae1df220ece3c0ada96b8153459b67eebe9ae9212258bb0134ae60416fdf76"
 dependencies = [
- "libc 0.1.12",
+ "libc",
+ "libloading",
 ]
 
 [[package]]
@@ -563,12 +554,6 @@ version = "1.5.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "bbd2bcb4c963f2ddae06a2efc7e9f3591312473c50c6685e1f298068316e66fe"
 
-[[package]]
-name = "libc"
-version = "0.1.12"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "e32a70cf75e5846d53a673923498228bbec6a8624708a9ea5645f075d6276122"
-
 [[package]]
 name = "libc"
 version = "0.2.159"
@@ -602,7 +587,7 @@ source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "c0ff37bd590ca25063e35af745c343cb7a0271906fb7b37e4813e8f79f00268d"
 dependencies = [
  "bitflags",
- "libc 0.2.159",
+ "libc",
  "redox_syscall",
 ]
 
@@ -657,7 +642,7 @@ dependencies = [
  "bitflags",
  "cfg-if",
  "cfg_aliases",
- "libc 0.2.159",
+ "libc",
 ]
 
 [[package]]
@@ -767,7 +752,7 @@ dependencies = [
  "cc",
  "cfg-if",
  "getrandom",
- "libc 0.2.159",
+ "libc",
  "spin",
  "untrusted",
  "windows-sys 0.52.0",
@@ -792,7 +777,7 @@ checksum = "8acb788b847c24f28525660c4d7758620a7210875711f79e7f663cc152726811"
 dependencies = [
  "bitflags",
  "errno",
- "libc 0.2.159",
+ "libc",
  "linux-raw-sys 0.4.14",
  "windows-sys 0.52.0",
 ]
@@ -935,7 +920,7 @@ source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "4ff6c40d3aedb5e06b57c6f669ad17ab063dd1e63d977c6a88e7f4dfa4f04020"
 dependencies = [
  "filetime",
- "libc 0.2.159",
+ "libc",
  "xattr",
 ]
 
@@ -1303,7 +1288,7 @@ version = "1.3.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "8da84f1a25939b27f6820d92aed108f83ff920fdf11a7b19366c27c4cda81d4f"
 dependencies = [
- "libc 0.2.159",
+ "libc",
  "linux-raw-sys 0.4.14",
  "rustix",
 ]
diff --git a/src/sys_info_v2/gatherer/Cargo.toml b/src/sys_info_v2/gatherer/Cargo.toml
index aaa6cda..5545e7b 100644
--- a/src/sys_info_v2/gatherer/Cargo.toml
+++ b/src/sys_info_v2/gatherer/Cargo.toml
@@ -15,8 +15,10 @@ dbus = { version = "0.9", features = ["vendored"] }
 dbus-crossroads = { version = "0.5" }
 glob = { version = "0.3.1" }
 drm = { version = "0.14.0" }
-egl = { version = "0.2" }
-gbm = { version = "0.16.0", default-features = false, features = ["drm-support"] }
+egl = { version = "6", package = "khronos-egl", features = ["dynamic"] }
+gbm = { version = "0.16.0", default-features = false, features = [
+  "drm-support",
+] }
 lazy_static = { version = "1.4" }
 libc = { version = "0.2" }
 libloading = { version = "0.8" }
diff --git a/src/sys_info_v2/gatherer/src/platform/linux/gpu_info/mod.rs b/src/sys_info_v2/gatherer/src/platform/linux/gpu_info/mod.rs
index a4448cf..1fb33d9 100644
--- a/src/sys_info_v2/gatherer/src/platform/linux/gpu_info/mod.rs
+++ b/src/sys_info_v2/gatherer/src/platform/linux/gpu_info/mod.rs
@@ -266,7 +266,7 @@ impl LinuxGpuInfo {
 
         let gpu_list = Arc::new(RwLock::new(nvtop::ListHead {
             next: std::ptr::null_mut(),
-            prev: std::ptr::null_mut(),
+                                            prev: std::ptr::null_mut(),
         }));
         {
             let mut gl = gpu_list.write().unwrap();
@@ -341,62 +341,96 @@ impl LinuxGpuInfo {
             Ok(gbm_device) => gbm_device,
         };
 
-        const EGL_CONTEXT_MAJOR_VERSION_KHR: egl::EGLint = 0x3098;
-        const EGL_CONTEXT_MINOR_VERSION_KHR: egl::EGLint = 0x30FB;
-        const EGL_PLATFORM_GBM_KHR: egl::EGLenum = 0x31D7;
-        const EGL_OPENGL_ES3_BIT: egl::EGLint = 0x0040;
+        const EGL_CONTEXT_MAJOR_VERSION_KHR: egl::Int = 0x3098;
+        const EGL_CONTEXT_MINOR_VERSION_KHR: egl::Int = 0x30FB;
+        const EGL_PLATFORM_GBM_KHR: egl::Enum = 0x31D7;
+        const EGL_OPENGL_ES3_BIT: egl::Int = 0x0040;
 
-        let eglGetPlatformDisplayEXT =
-            egl::get_proc_address("eglGetPlatformDisplayEXT") as *const Void;
-        let egl_display = if !eglGetPlatformDisplayEXT.is_null() {
+        let lib = match libloading::Library::new("libEGL.so.1") {
+            Ok(lib) => lib,
+            Err(e) => {
+                error!("Gatherer::GpuInfo", "Failed to load libEGL.so.1: {}", e);
+                return None;
+            }
+        };
+
+        let e = match egl::DynamicInstance::<egl::EGL1_2>::load_required_from(lib) {
+            Ok(e) => e,
+            Err(e) => {
+                error!(
+                    "Gatherer::GpuInfo",
+                    "Failed to load symbols from libEGL.so.1: {}", e
+                );
+                return None;
+            }
+        };
+
+        let eglGetPlatformDisplayEXT = e.get_proc_address("eglGetPlatformDisplayEXT");
+        let egl_display = if let Some(eglGetPlatformDisplayEXT) = eglGetPlatformDisplayEXT {
             let eglGetPlatformDisplayEXT: extern "C" fn(
-                egl::EGLenum,
+                egl::Enum,
                 *mut Void,
-                *const egl::EGLint,
+                *const egl::Int,
             ) -> egl::EGLDisplay = std::mem::transmute(eglGetPlatformDisplayEXT);
-            eglGetPlatformDisplayEXT(
+            let display_ptr = eglGetPlatformDisplayEXT(
                 EGL_PLATFORM_GBM_KHR,
                 gbm_device.as_raw() as *mut Void,
-                std::ptr::null(),
-            )
+                                                       std::ptr::null(),
+            );
+            if display_ptr.is_null() {
+                None
+            } else {
+                Some(egl::Display::from_ptr(display_ptr))
+            }
         } else {
-            let eglGetPlatformDisplay =
-                egl::get_proc_address("eglGetPlatformDisplay") as *const Void;
-            if !eglGetPlatformDisplay.is_null() {
+            let eglGetPlatformDisplay = e.get_proc_address("eglGetPlatformDisplay");
+            if let Some(eglGetPlatformDisplay) = eglGetPlatformDisplay {
                 let eglGetPlatformDisplay: extern "C" fn(
-                    egl::EGLenum,
+                    egl::Enum,
                     *mut Void,
-                    *const egl::EGLint,
+                    *const egl::Int,
                 ) -> egl::EGLDisplay = std::mem::transmute(eglGetPlatformDisplay);
-                eglGetPlatformDisplay(
+                let display_ptr = eglGetPlatformDisplay(
                     EGL_PLATFORM_GBM_KHR,
                     gbm_device.as_raw() as *mut Void,
-                    std::ptr::null(),
-                )
+                                                        std::ptr::null(),
+                );
+                if display_ptr.is_null() {
+                    None
+                } else {
+                    Some(egl::Display::from_ptr(display_ptr))
+                }
             } else {
-                egl::get_display(gbm_device.as_raw() as *mut Void)
-                    .map_or(std::ptr::null_mut(), |d| d)
+                e.get_display(gbm_device.as_raw() as *mut Void)
             }
         };
-        if egl_display.is_null() {
-            error!(
-                "Gatherer::GpuInfo",
-                "Failed to get OpenGL information: Failed to initialize an EGL display ({:X})",
-                egl::get_error()
-            );
-            return None;
-        }
 
-        let mut egl_major = 0;
-        let mut egl_minor = 0;
-        if !egl::initialize(egl_display, &mut egl_major, &mut egl_minor) {
-            error!(
-                "Gathereer::GpuInfo",
-                "Failed to get OpenGL information: Failed to initialize an EGL display ({:X})",
-                egl::get_error()
-            );
+        let Some(egl_display) = egl_display else {
+            match e.get_error() {
+                Some(error) => error!(
+                    "Gatherer::GpuInfo",
+                    "Failed to get OpenGL information: Failed to initialize an EGL display ({:X})",
+                                      error.native()
+                ),
+                None => error!(
+                    "Gatherer::GpuInfo",
+                    "Failed to get OpenGL information: Failed to initialize an EGL display (no error code)",
+                ),
+            }
             return None;
-        }
+        };
+
+        let (egl_major, egl_minor) = match e.initialize(egl_display) {
+            Ok(result) => result,
+            Err(error) => {
+                error!(
+                    "Gathereer::GpuInfo",
+                    "Failed to get OpenGL information: Failed to initialize an EGL display ({:X})",
+                       error.native()
+                );
+                return None;
+            }
+        };
 
         if egl_major < 1 || (egl_major == 1 && egl_minor < 4) {
             error!(
@@ -406,89 +440,82 @@ impl LinuxGpuInfo {
             return None;
         }
 
-        let mut gl_api = egl::EGL_OPENGL_API;
-        if !egl::bind_api(gl_api) {
-            gl_api = egl::EGL_OPENGL_ES_API;
-            if !egl::bind_api(gl_api) {
+        let mut gl_api = egl::OPENGL_API;
+        if e.bind_api(gl_api).is_err() {
+            gl_api = egl::OPENGL_ES_API;
+            if let Err(error) = e.bind_api(gl_api) {
                 error!(
                     "Gatherer::GpuInfo",
                     "Failed to get OpenGL information: Failed to bind an EGL API ({:X})",
-                    egl::get_error()
+                       error.native()
                 );
                 return None;
             }
         }
 
-        let egl_config = if gl_api == egl::EGL_OPENGL_ES_API {
-            let mut config_attribs = [
-                egl::EGL_SURFACE_TYPE,
-                egl::EGL_WINDOW_BIT,
-                egl::EGL_RENDERABLE_TYPE,
-                EGL_OPENGL_ES3_BIT,
-                egl::EGL_NONE,
-            ];
-
-            let mut egl_config = egl::choose_config(egl_display, &config_attribs, 1);
-            if egl_config.is_some() {
-                egl_config
-            } else {
-                config_attribs[3] = egl::EGL_OPENGL_ES2_BIT;
-                egl_config = egl::choose_config(egl_display, &config_attribs, 1);
-                if egl_config.is_some() {
-                    egl_config
-                } else {
-                    config_attribs[3] = egl::EGL_OPENGL_ES_BIT;
-                    egl::choose_config(egl_display, &config_attribs, 1)
+        let mut egl_configs = Vec::with_capacity(1);
+        let error = if gl_api == egl::OPENGL_ES_API {
+            let mut error = None;
+            for es_bit in [EGL_OPENGL_ES3_BIT, egl::OPENGL_ES2_BIT, egl::OPENGL_ES_BIT] {
+                let attrs = [
+                    egl::SURFACE_TYPE,
+                    egl::WINDOW_BIT,
+                    egl::RENDERABLE_TYPE,
+                    es_bit,
+                    egl::NONE,
+                ];
+                match e.choose_config(egl_display, &attrs, &mut egl_configs) {
+                    Ok(()) => break,
+                    Err(e) => error = Some(e),
                 }
             }
+            error
         } else {
-            let config_attribs = [
-                egl::EGL_SURFACE_TYPE,
-                egl::EGL_WINDOW_BIT,
-                egl::EGL_RENDERABLE_TYPE,
-                egl::EGL_OPENGL_BIT,
-                egl::EGL_NONE,
+            let attrs = [
+                egl::SURFACE_TYPE,
+                egl::WINDOW_BIT,
+                egl::RENDERABLE_TYPE,
+                egl::OPENGL_BIT,
+                egl::NONE,
             ];
-
-            egl::choose_config(egl_display, &config_attribs, 1)
+            e.choose_config(egl_display, &attrs, &mut egl_configs).err()
         };
 
-        if egl_config.is_none() {
-            return None;
-        }
-        let egl_config = match egl_config {
-            Some(ec) => ec,
-            None => {
+        let egl_config = match (egl_configs.into_iter().next(), error) {
+            (Some(egl_config), _) => egl_config,
+            (None, Some(error)) => {
                 error!(
                     "Gatherer::GpuInfo",
                     "Failed to get OpenGL information: Failed to choose an EGL config ({:X})",
-                    egl::get_error()
+                       error.native()
+                );
+                return None;
+            }
+            (None, None) => {
+                error!(
+                    "Gatherer::GpuInfo",
+                    "Failed to get OpenGL information: Failed to choose an EGL config (no error code)",
                 );
                 return None;
             }
         };
 
-        let mut ver_major = if gl_api == egl::EGL_OPENGL_API { 4 } else { 3 };
-        let mut ver_minor = if gl_api == egl::EGL_OPENGL_API { 6 } else { 0 };
+        let mut ver_major = if gl_api == egl::OPENGL_API { 4 } else { 3 };
+        let mut ver_minor = if gl_api == egl::OPENGL_API { 6 } else { 0 };
 
         let mut context_attribs = [
             EGL_CONTEXT_MAJOR_VERSION_KHR,
             ver_major,
             EGL_CONTEXT_MINOR_VERSION_KHR,
             ver_minor,
-            egl::EGL_NONE,
+            egl::NONE,
         ];
 
         let mut egl_context;
         loop {
-            egl_context = egl::create_context(
-                egl_display,
-                egl_config,
-                egl::EGL_NO_CONTEXT,
-                &context_attribs,
-            );
+            egl_context = e.create_context(egl_display, egl_config, None, &context_attribs);
 
-            if egl_context.is_some() || (ver_major == 1 && ver_minor == 0) {
+            if egl_context.is_ok() || (ver_major == 1 && ver_minor == 0) {
                 break;
             }
 
@@ -504,12 +531,12 @@ impl LinuxGpuInfo {
         }
 
         match egl_context {
-            Some(ec) => egl::destroy_context(egl_display, ec),
-            None => {
+            Ok(ec) => _ = e.destroy_context(egl_display, ec),
+            Err(error) => {
                 error!(
                     "Gatherer::GpuInfo",
                     "Failed to get OpenGL information: Failed to create an EGL context ({:X})",
-                    egl::get_error()
+                       error.native()
                 );
                 return None;
             }
@@ -518,7 +545,7 @@ impl LinuxGpuInfo {
         Some(OpenGLApiVersion {
             major: ver_major as u8,
             minor: ver_minor as u8,
-            api: if gl_api != egl::EGL_OPENGL_API {
+            api: if gl_api != egl::OPENGL_API {
                 OpenGLApi::OpenGLES
             } else {
                 OpenGLApi::OpenGL
@@ -532,8 +559,8 @@ impl<'a> GpuInfoExt<'a> for LinuxGpuInfo {
     type D = LinuxGpuDynamicInfo;
     type P = crate::platform::Processes;
     type Iter = std::iter::Map<
-        std::collections::hash_map::Keys<'a, arrayvec::ArrayString<16>, LinuxGpuStaticInfo>,
-        fn(&arrayvec::ArrayString<16>) -> &str,
+    std::collections::hash_map::Keys<'a, arrayvec::ArrayString<16>, LinuxGpuStaticInfo>,
+    fn(&arrayvec::ArrayString<16>) -> &str,
     >;
 
     fn refresh_gpu_list(&mut self) {
@@ -617,14 +644,14 @@ impl<'a> GpuInfoExt<'a> for LinuxGpuInfo {
             }
 
             let device_name =
-                unsafe { std::ffi::CStr::from_ptr(dev.static_info.device_name.as_ptr()) };
+            unsafe { std::ffi::CStr::from_ptr(dev.static_info.device_name.as_ptr()) };
             let device_name = device_name.to_str().unwrap_or_else(|_| "Unknown");
 
             let mut uevent_path = ArrayString::<64>::new();
             let _ = write!(uevent_path, "/sys/bus/pci/devices/{}/uevent", pdev);
             let uevent_file = match std::fs::OpenOptions::new()
-                .read(true)
-                .open(uevent_path.as_str())
+            .read(true)
+            .open(uevent_path.as_str())
             {
                 Ok(f) => Some(f),
                 Err(_) => {
@@ -635,8 +662,8 @@ impl<'a> GpuInfoExt<'a> for LinuxGpuInfo {
                         pdev.to_lowercase()
                     );
                     match std::fs::OpenOptions::new()
-                        .read(true)
-                        .open(uevent_path.as_str())
+                    .read(true)
+                    .open(uevent_path.as_str())
                     {
                         Ok(f) => Some(f),
                         Err(_) => {
@@ -678,13 +705,13 @@ impl<'a> GpuInfoExt<'a> for LinuxGpuInfo {
                             if line.starts_with("PCI_ID=") {
                                 let mut ids = line[7..].split(':');
                                 vendor_id = ids
-                                    .next()
-                                    .and_then(|id| u16::from_str_radix(id, 16).ok())
-                                    .unwrap_or(0);
+                                .next()
+                                .and_then(|id| u16::from_str_radix(id, 16).ok())
+                                .unwrap_or(0);
                                 device_id = ids
-                                    .next()
-                                    .and_then(|id| u16::from_str_radix(id, 16).ok())
-                                    .unwrap_or(0);
+                                .next()
+                                .and_then(|id| u16::from_str_radix(id, 16).ok())
+                                .unwrap_or(0);
                                 break;
                             }
                         }
@@ -722,7 +749,7 @@ impl<'a> GpuInfoExt<'a> for LinuxGpuInfo {
 
             self.static_info.insert(pci_bus_id.clone(), static_info);
             self.dynamic_info
-                .insert(pci_bus_id, LinuxGpuDynamicInfo::new());
+            .insert(pci_bus_id, LinuxGpuDynamicInfo::new());
         }
     }
 
@@ -744,8 +771,8 @@ impl<'a> GpuInfoExt<'a> for LinuxGpuInfo {
             run_forked(|| {
                 if let Some(vulkan_info) = vulkan_info::VulkanInfo::new() {
                     Ok(vulkan_info
-                        .supported_vulkan_versions()
-                        .unwrap_or(HashMap::new()))
+                    .supported_vulkan_versions()
+                    .unwrap_or(HashMap::new()))
                 } else {
                     Ok(HashMap::new())
                 }
@@ -933,14 +960,14 @@ impl<'a> GpuInfoExt<'a> for LinuxGpuInfo {
         use arrayvec::ArrayString;
 
         self.static_info
-            .get(&ArrayString::<16>::from(id).unwrap_or_default())
+        .get(&ArrayString::<16>::from(id).unwrap_or_default())
     }
 
     fn dynamic_info(&self, id: &str) -> Option<&Self::D> {
         use arrayvec::ArrayString;
 
         self.dynamic_info
-            .get(&ArrayString::<16>::from(id).unwrap_or_default())
+        .get(&ArrayString::<16>::from(id).unwrap_or_default())
     }
 }
 
-- 
2.48.1

