From c05f9c3ab7f5e25f410c60466ed2278bf47eebe0 Mon Sep 17 00:00:00 2001
From: liushuyu <liushuyu011@gmail.com>
Date: Thu, 28 Apr 2022 00:53:04 -0600
Subject: [PATCH 2/2] WIP

---
 .../LegalizeFunctionSignatures.cpp            |   8 ++
 IGC/AdaptorCommon/ProcessFuncAttributes.cpp   |   9 ++
 IGC/AdaptorCommon/RayTracing/RTBuilder.cpp    |  24 ++++
 IGC/AdaptorOCL/SPIRV/SPIRVReader.cpp          |   8 ++
 IGC/AdaptorOCL/SPIRV/SPIRVUtil.cpp            |   4 +-
 IGC/AdaptorOCL/UnifyIROCL.cpp                 |   7 +-
 IGC/Compiler/CISACodeGen/CodeSinking.cpp      |   4 +
 IGC/Compiler/CISACodeGen/GenCodeGenModule.cpp |   4 +
 IGC/Compiler/CISACodeGen/ResolveGAS.cpp       |   3 +-
 IGC/Compiler/GenTTI.cpp                       |   6 +-
 IGC/Compiler/GenTTI.h                         |   6 +-
 IGC/Compiler/Optimizer/BuiltInFuncImport.cpp  |  16 +++
 .../IGCInstCombiner/4.0/InstCombineCalls.cpp  |   2 +-
 .../IGCInstCombiner/7.0/InstCombineCalls.cpp  |   2 +-
 .../IGCInstructionCombining.hpp               |   2 +-
 .../Optimizer/IntDivConstantReduction.cpp     |  53 ++++++++
 .../AlignmentAnalysis/AlignmentAnalysis.cpp   |  26 +++-
 .../AlignmentAnalysis/AlignmentAnalysis.hpp   |   9 +-
 .../DebuggerSupport/ImplicitGIDPass.cpp       |   4 +
 .../DeviceEnqueueFuncs/TransformBlocks.cpp    |  15 ++-
 .../TransformUnmaskedFunctionsPass.cpp        |   6 +
 .../Optimizer/PreCompiledFuncImport.cpp       |   4 +
 IGC/DebugInfo/StreamEmitter.cpp               |  10 +-
 .../BuiltinsFrontendDefinitions.hpp           |   5 +-
 .../CMCL/tools/Translator/Main.cpp            |   1 +
 .../include/vc/Support/GenXDiagnostic.h       |   2 +-
 .../lib/GenXCodeGen/GenXCisaBuilder.cpp       |   6 +-
 .../lib/GenXCodeGen/GenXCoalescing.cpp        |   3 +-
 .../lib/GenXCodeGen/GenXDepressurizer.cpp     |   3 +-
 .../lib/GenXCodeGen/GenXEmulate.cpp           |   3 +-
 .../lib/GenXCodeGen/GenXLowering.cpp          |   3 +-
 .../lib/GenXCodeGen/GenXPatternMatch.cpp      |   3 +-
 .../GenXCodeGen/GenXPrologEpilogInsertion.cpp |   6 +
 .../lib/GenXCodeGen/GenXPromotePredicate.cpp  |   3 +-
 .../GenXPromoteStatefulToBindless.cpp         |   2 +-
 .../lib/GenXCodeGen/GenXStackUsage.cpp        |  18 +++
 .../lib/GenXCodeGen/GenXTargetMachine.h       |   6 +-
 .../lib/GenXCodeGen/GenXVectorCombiner.cpp    |   3 +-
 IGC/VectorCompiler/lib/GenXCodeGen/GenXVisa.h |   4 +
 .../GenXOpts/CMPacketize/GenXPacketize.cpp    |   2 +-
 .../lib/GenXOpts/CMTrans/CMABI.cpp            |  22 +++-
 .../lib/GenXOpts/CMTrans/CMImpParam.cpp       |  17 +++
 .../lib/Support/BackendConfig.cpp             |   4 +-
 .../lib/Utils/GenX/TransformArgCopy.cpp       |  23 +++-
 IGC/VectorCompiler/lib/Utils/General/BiF.cpp  |   2 +-
 .../lib/Utils/General/DebugInfo.cpp           |  12 +-
 .../utils/vcb/UniqueCompilation.cpp           |   4 +-
 IGC/VectorCompiler/utils/vcb/vcb.cpp          |   4 +-
 .../include/lldWrapper/Common/Driver.h        |   4 +-
 .../include/llvmWrapper/IR/ConstantFolder.h   | 122 +++++++++++-------
 .../include/llvmWrapper/IR/IRBuilder.h        |   8 ++
 .../include/llvmWrapper/IR/Instructions.h     |   9 ++
 IGC/common/debug/Debug.cpp                    |  12 ++
 53 files changed, 456 insertions(+), 92 deletions(-)

diff --git a/IGC/AdaptorCommon/LegalizeFunctionSignatures.cpp b/IGC/AdaptorCommon/LegalizeFunctionSignatures.cpp
index dd36da462..be07513ef 100644
--- a/IGC/AdaptorCommon/LegalizeFunctionSignatures.cpp
+++ b/IGC/AdaptorCommon/LegalizeFunctionSignatures.cpp
@@ -548,7 +548,11 @@ void LegalizeFunctionSignatures::FixCallInstruction(Module& M, CallInst* callIns
         {
             // legal argument
             callArgs.push_back(arg);
+#if LLVM_VERSION_MAJOR >= 14
+            ArgAttrVec.push_back(PAL.getParamAttrs(opNum));
+#else
             ArgAttrVec.push_back(PAL.getParamAttributes(opNum));
+#endif
         }
     }
 
@@ -581,7 +585,11 @@ void LegalizeFunctionSignatures::FixCallInstruction(Module& M, CallInst* callIns
         // Create the new call instruction
         CallInst* newCallInst = builder.CreateCall(newCalledValue, callArgs);
         newCallInst->setCallingConv(callInst->getCallingConv());
+#if LLVM_VERSION_MAJOR >= 14
+        newCallInst->setAttributes(AttributeList::get(M.getContext(), PAL.getFnAttrs(), PAL.getRetAttrs(), ArgAttrVec));
+#else
         newCallInst->setAttributes(AttributeList::get(M.getContext(), PAL.getFnAttributes(), PAL.getRetAttributes(), ArgAttrVec));
+#endif
         newCallInst->setDebugLoc(callInst->getDebugLoc());
 
         if (legalizeReturnType)
diff --git a/IGC/AdaptorCommon/ProcessFuncAttributes.cpp b/IGC/AdaptorCommon/ProcessFuncAttributes.cpp
index a6d22e613..20ed19a1d 100644
--- a/IGC/AdaptorCommon/ProcessFuncAttributes.cpp
+++ b/IGC/AdaptorCommon/ProcessFuncAttributes.cpp
@@ -379,12 +379,21 @@ bool ProcessFuncAttributes::runOnModule(Module& M)
                 // Go through call sites and remove NoInline atrributes.
                 // Verifier fails if a call has optnone but not noinline, so if we remove noinline, we must also remove optnone
                 if (callInst->hasFnAttr(llvm::Attribute::NoInline)) {
+#if LLVM_VERSION_MAJOR >= 14
+                    callInst->removeAttributeAtIndex(AttributeList::FunctionIndex, llvm::Attribute::NoInline);
+                    callInst->removeAttributeAtIndex(AttributeList::FunctionIndex, llvm::Attribute::OptimizeNone);
+#else
                     callInst->removeAttribute(AttributeList::FunctionIndex, llvm::Attribute::NoInline);
                     callInst->removeAttribute(AttributeList::FunctionIndex, llvm::Attribute::OptimizeNone);
+#endif
                 }
                 // Remove AlwaysInline at callsites
                 if (isOptDisable && callInst->hasFnAttr(llvm::Attribute::AlwaysInline)) {
+#if LLVM_VERSION_MAJOR >= 14
+                    callInst->removeAttributeAtIndex(AttributeList::FunctionIndex, llvm::Attribute::AlwaysInline);
+#else
                     callInst->removeAttribute(AttributeList::FunctionIndex, llvm::Attribute::AlwaysInline);
+#endif
                 }
             }
         }
diff --git a/IGC/AdaptorCommon/RayTracing/RTBuilder.cpp b/IGC/AdaptorCommon/RayTracing/RTBuilder.cpp
index 1cbaa229b..77eb3e99c 100644
--- a/IGC/AdaptorCommon/RayTracing/RTBuilder.cpp
+++ b/IGC/AdaptorCommon/RayTracing/RTBuilder.cpp
@@ -3233,30 +3233,54 @@ Value* RTBuilder::createAllocaNumber(const AllocaInst* AI, uint32_t Number)
 void RTBuilder::setReturnAlignment(CallInst* CI, uint32_t AlignVal)
 {
     auto Attrs = CI->getAttributes();
+#if LLVM_VERSION_MAJOR >= 14
+    AttrBuilder AB{ CI->getContext(), Attrs.getRetAttrs() };
+#else
     AttrBuilder AB{ Attrs, AttributeList::ReturnIndex };
+#endif
     AB.addAlignmentAttr(AlignVal);
     auto AL =
+#if LLVM_VERSION_MAJOR >= 14
+        Attrs.addAttributesAtIndex(CI->getContext(), AttributeList::ReturnIndex, AB);
+#else
         Attrs.addAttributes(CI->getContext(), AttributeList::ReturnIndex, AB);
+#endif
     CI->setAttributes(AL);
 }
 
 void RTBuilder::setNoAlias(CallInst* CI)
 {
     auto Attrs = CI->getAttributes();
+#if LLVM_VERSION_MAJOR >= 14
+    AttrBuilder AB{ CI->getContext(), Attrs.getRetAttrs() };
+#else
     AttrBuilder AB{ Attrs, AttributeList::ReturnIndex };
+#endif
     AB.addAttribute(Attribute::AttrKind::NoAlias);
     auto AL =
+#if LLVM_VERSION_MAJOR >= 14
+        Attrs.addAttributesAtIndex(CI->getContext(), AttributeList::ReturnIndex, AB);
+#else
         Attrs.addAttributes(CI->getContext(), AttributeList::ReturnIndex, AB);
+#endif
     CI->setAttributes(AL);
 }
 
 void RTBuilder::setDereferenceable(CallInst* CI, uint32_t Size)
 {
     auto Attrs = CI->getAttributes();
+#if LLVM_VERSION_MAJOR >= 14
+    AttrBuilder AB{ CI->getContext(), Attrs.getRetAttrs() };
+#else
     AttrBuilder AB{ Attrs, AttributeList::ReturnIndex };
+#endif
     AB.addDereferenceableAttr(Size);
     auto AL =
+#if LLVM_VERSION_MAJOR >= 14
+        Attrs.addAttributesAtIndex(CI->getContext(), AttributeList::ReturnIndex, AB);
+#else
         Attrs.addAttributes(CI->getContext(), AttributeList::ReturnIndex, AB);
+#endif
     CI->setAttributes(AL);
 }
 
diff --git a/IGC/AdaptorOCL/SPIRV/SPIRVReader.cpp b/IGC/AdaptorOCL/SPIRV/SPIRVReader.cpp
index ad6c62888..d36919733 100644
--- a/IGC/AdaptorOCL/SPIRV/SPIRVReader.cpp
+++ b/IGC/AdaptorOCL/SPIRV/SPIRVReader.cpp
@@ -4211,8 +4211,12 @@ SPIRVToLLVM::transFunction(SPIRVFunction *BF) {
   BF->foreachReturnValueAttr([&](SPIRVFuncParamAttrKind Kind){
     if (Kind == FunctionParameterAttributeCount)
       return;
+#if LLVM_VERSION_MAJOR >= 14
+    F->addRetAttr(SPIRSPIRVFuncParamAttrMap::rmap(Kind));
+#else
     F->addAttribute(AttributeList::ReturnIndex,
         SPIRSPIRVFuncParamAttrMap::rmap(Kind));
+#endif
   });
 
   // Creating all basic blocks before creating instructions.
@@ -5052,7 +5056,11 @@ SPIRVToLLVM::transOCLBuiltinFromExtInst(SPIRVExtInst *BC, BasicBlock *BB) {
       BC->getName(),
       BB);
   setCallingConv(Call);
+#if LLVM_VERSION_MAJOR >= 14
+  Call->addFnAttr(Attribute::NoUnwind);
+#else
   Call->addAttribute(AttributeList::FunctionIndex, Attribute::NoUnwind);
+#endif
   return Call;
 }
 
diff --git a/IGC/AdaptorOCL/SPIRV/SPIRVUtil.cpp b/IGC/AdaptorOCL/SPIRV/SPIRVUtil.cpp
index d6e68bb8b..a598b134b 100644
--- a/IGC/AdaptorOCL/SPIRV/SPIRVUtil.cpp
+++ b/IGC/AdaptorOCL/SPIRV/SPIRVUtil.cpp
@@ -54,7 +54,9 @@ THE SOFTWARE.
 
 #include <llvm/Support/ScaledNumber.h>
 #include "llvm/ADT/StringExtras.h"
+#include "llvm/Support/Regex.h"
 #include "llvmWrapper/IR/IRBuilder.h"
+#include "llvmWrapper/IR/Instructions.h"
 #include "llvmWrapper/Transforms/Utils/Cloning.h"
 #include "common/LLVMWarningsPop.hpp"
 
@@ -121,7 +123,7 @@ getOrCreateFunction(Module *M, Type *RetTy, ArrayRef<Type *> ArgTypes,
 std::vector<Value *>
 getArguments(CallInst* CI) {
   std::vector<Value*> Args;
-  for (unsigned I = 0, E = CI->getNumArgOperands(); I != E; ++I) {
+  for (unsigned I = 0, E = IGCLLVM::getNumArgOperands(CI); I != E; ++I) {
     Args.push_back(CI->getArgOperand(I));
   }
   return Args;
diff --git a/IGC/AdaptorOCL/UnifyIROCL.cpp b/IGC/AdaptorOCL/UnifyIROCL.cpp
index 5606644cc..93eb2469d 100644
--- a/IGC/AdaptorOCL/UnifyIROCL.cpp
+++ b/IGC/AdaptorOCL/UnifyIROCL.cpp
@@ -21,7 +21,12 @@ SPDX-License-Identifier: MIT
 #include <llvm/IR/Module.h>
 #include <llvm/IR/Function.h>
 #include <llvm/Analysis/TargetLibraryInfo.h>
-#include <llvm/Transforms/InstCombine/InstCombineWorklist.h>
+#if LLVM_VERSION_MAJOR <= 13
+#include "llvm/Transforms/InstCombine/InstCombineWorklist.h"
+#else
+#include "llvm/Transforms/Utils/InstructionWorklist.h"
+using InstCombineWorklist = llvm::InstructionWorklist;
+#endif
 #include <llvm/Transforms/InstCombine/InstCombine.h>
 
 #include <llvmWrapper/Transforms/Utils.h>
diff --git a/IGC/Compiler/CISACodeGen/CodeSinking.cpp b/IGC/Compiler/CISACodeGen/CodeSinking.cpp
index 9ce359b3a..c851ed949 100644
--- a/IGC/Compiler/CISACodeGen/CodeSinking.cpp
+++ b/IGC/Compiler/CISACodeGen/CodeSinking.cpp
@@ -767,7 +767,11 @@ namespace IGC {
 
             if (!call0->getCalledFunction() ||
                 call0->getCalledFunction() != call1->getCalledFunction() ||
+#if LLVM_VERSION_MAJOR >= 14
+                !call0->getCalledFunction()->onlyWritesMemory() ||
+#else
                 !call0->getCalledFunction()->doesNotReadMemory() ||
+#endif
                 call0->isConvergent())
             {
                 return false;
diff --git a/IGC/Compiler/CISACodeGen/GenCodeGenModule.cpp b/IGC/Compiler/CISACodeGen/GenCodeGenModule.cpp
index 6c6eadbf2..17c6d85f8 100644
--- a/IGC/Compiler/CISACodeGen/GenCodeGenModule.cpp
+++ b/IGC/Compiler/CISACodeGen/GenCodeGenModule.cpp
@@ -368,7 +368,11 @@ static bool DeduceNonNullAttribute(Module& M)
             if (NotNull) {
                 // FIXME: Below lines possibly can be refactored to be simpler.
                 AttributeList attrSet = AttributeList::get(Arg.getParent()->getContext(), Arg.getArgNo() + 1, llvm::Attribute::NonNull);
+#if LLVM_VERSION_MAJOR >= 14
+                Arg.addAttr(attrSet.getAttributeAtIndex(Arg.getArgNo() + 1, llvm::Attribute::NonNull));
+#else
                 Arg.addAttr(attrSet.getAttribute(Arg.getArgNo() + 1, llvm::Attribute::NonNull));
+#endif
                 Modifided = true;
             }
         }
diff --git a/IGC/Compiler/CISACodeGen/ResolveGAS.cpp b/IGC/Compiler/CISACodeGen/ResolveGAS.cpp
index f01dc96b0..39f66b664 100644
--- a/IGC/Compiler/CISACodeGen/ResolveGAS.cpp
+++ b/IGC/Compiler/CISACodeGen/ResolveGAS.cpp
@@ -16,6 +16,7 @@ SPDX-License-Identifier: MIT
 #include "llvm/ADT/PostOrderIterator.h"
 #include "llvm/Analysis/CallGraph.h"
 #include "llvm/Support/Debug.h"
+#include "llvmWrapper/IR/Instructions.h"
 #include "llvmWrapper/IR/Constant.h"
 #include "LLVM3DBuilder/MetadataBuilder.h"
 #include "common/LLVMWarningsPush.hpp"
@@ -1520,7 +1521,7 @@ bool LowerGPCallArg::processCallArg(Module& M)
             if (CallInst* callInst = dyn_cast<CallInst>(*UI))
             {
                 Function::arg_iterator funcArg = F.arg_begin();
-                for (unsigned int i = 0; i < callInst->getNumArgOperands(); ++i, ++funcArg)
+                for (unsigned int i = 0; i < IGCLLVM::getNumArgOperands(callInst); ++i, ++funcArg)
                 {
                     Value* callArg = callInst->getOperand(i);
                     if (callArg->getType() != funcArg->getType())
diff --git a/IGC/Compiler/GenTTI.cpp b/IGC/Compiler/GenTTI.cpp
index 5c1248f01..09988f9e6 100644
--- a/IGC/Compiler/GenTTI.cpp
+++ b/IGC/Compiler/GenTTI.cpp
@@ -158,7 +158,11 @@ namespace llvm {
 #if LLVM_VERSION_MAJOR >= 7
         ScalarEvolution& SE,
 #endif
-        TTI::UnrollingPreferences& UP)
+        TTI::UnrollingPreferences& UP
+#if LLVM_VERSION_MAJOR >= 14
+        , OptimizationRemarkEmitter* ORE
+#endif
+        )
     {
         unsigned LoopUnrollThreshold = ctx->m_DriverInfo.GetLoopUnrollThreshold();
 
diff --git a/IGC/Compiler/GenTTI.h b/IGC/Compiler/GenTTI.h
index 57a9852ee..aec2ca414 100644
--- a/IGC/Compiler/GenTTI.h
+++ b/IGC/Compiler/GenTTI.h
@@ -55,7 +55,11 @@ namespace llvm
 #if LLVM_VERSION_MAJOR >= 7
             ScalarEvolution & SE,
 #endif
-            TTI::UnrollingPreferences & UP);
+            TTI::UnrollingPreferences & UP
+#if LLVM_VERSION_MAJOR >= 14
+        , OptimizationRemarkEmitter* ORE
+#endif
+        );
 
 #if LLVM_VERSION_MAJOR >= 11
         void getPeelingPreferences(Loop* L, ScalarEvolution& SE,
diff --git a/IGC/Compiler/Optimizer/BuiltInFuncImport.cpp b/IGC/Compiler/Optimizer/BuiltInFuncImport.cpp
index ddbbaf959..6ed5c6ebc 100644
--- a/IGC/Compiler/Optimizer/BuiltInFuncImport.cpp
+++ b/IGC/Compiler/Optimizer/BuiltInFuncImport.cpp
@@ -385,7 +385,11 @@ std::unique_ptr<llvm::Module> BIImport::Construct(Module& M, CLElfLib::CElfReade
                     IGC_ASSERT_MESSAGE(0, "Failed to materialize Global Variables");
                 }
                 else {
+#if LLVM_VERSION_MAJOR >= 14
+                    pFunc->addAttributeAtIndex(AttributeList::FunctionIndex, llvm::Attribute::get(pFunc->getContext(), llvm::Attribute::Builtin));
+#else
                     pFunc->addAttribute(AttributeList::FunctionIndex, llvm::Attribute::Builtin);
+#endif
                     Explore(pFunc);
                 }
             }
@@ -542,7 +546,11 @@ bool BIImport::runOnModule(Module& M)
                     IGC_ASSERT_MESSAGE(0, "Failed to materialize Global Variables");
                 }
                 else {
+#if LLVM_VERSION_MAJOR >= 14
+                    pFunc->addAttributeAtIndex(AttributeList::FunctionIndex, llvm::Attribute::get(pFunc->getContext(), llvm::Attribute::Builtin));
+#else
                     pFunc->addAttribute(AttributeList::FunctionIndex, llvm::Attribute::Builtin);
+#endif
                     Explore(pFunc);
                 }
             }
@@ -699,7 +707,11 @@ bool BIImport::runOnModule(Module& M)
                     Function* calledF = dyn_cast<Function>(CI->getArgOperand(0));
                     IGC_ASSERT(calledF && CI->hasFnAttr("vector-variant"));
                     StringRef VariantName = CI->getAttributes()
+#if LLVM_VERSION_MAJOR >= 14
+                        .getAttributeAtIndex(AttributeList::FunctionIndex, "vector-variant")
+#else
                         .getAttribute(AttributeList::FunctionIndex, "vector-variant")
+#endif
                         .getValueAsString();
 
                     // Parse the variant string, and create a function declaration that represents a variant of the called function.
@@ -744,7 +756,11 @@ bool BIImport::runOnModule(Module& M)
                     {
                         // Get the list of metadata strings indicating the function variant per index
                         StringRef VariantsStr = CI->getAttributes()
+#if LLVM_VERSION_MAJOR >= 14
+                            .getAttributeAtIndex(AttributeList::FunctionIndex, "vector-variants")
+#else
                             .getAttribute(AttributeList::FunctionIndex, "vector-variants")
+#endif
                             .getValueAsString();
                         SmallVector<StringRef, 8> VariantsTable;
                         VariantsStr.split(VariantsTable, ',');
diff --git a/IGC/Compiler/Optimizer/IGCInstCombiner/4.0/InstCombineCalls.cpp b/IGC/Compiler/Optimizer/IGCInstCombiner/4.0/InstCombineCalls.cpp
index 6baca12ea..9487a70f4 100644
--- a/IGC/Compiler/Optimizer/IGCInstCombiner/4.0/InstCombineCalls.cpp
+++ b/IGC/Compiler/Optimizer/IGCInstCombiner/4.0/InstCombineCalls.cpp
@@ -1388,7 +1388,7 @@ Instruction *InstCombiner::visitVACopyInst(VACopyInst &I) {
 /// instructions. For normal calls, it allows visitCallSite to do the heavy
 /// lifting.
 Instruction *InstCombiner::visitCallInst(CallInst &CI) {
-  auto Args = CI.arg_operands();
+  auto Args = IGCLLVM::args(CI);
   if (Value *V = SimplifyCall(CI.getCalledValue(), Args.begin(), Args.end(), DL,
                               &TLI, &DT, &AC))
     return replaceInstUsesWith(CI, V);
diff --git a/IGC/Compiler/Optimizer/IGCInstCombiner/7.0/InstCombineCalls.cpp b/IGC/Compiler/Optimizer/IGCInstCombiner/7.0/InstCombineCalls.cpp
index d82284c1a..04a5155c4 100644
--- a/IGC/Compiler/Optimizer/IGCInstCombiner/7.0/InstCombineCalls.cpp
+++ b/IGC/Compiler/Optimizer/IGCInstCombiner/7.0/InstCombineCalls.cpp
@@ -1816,7 +1816,7 @@ static Instruction* SimplifyNVVMIntrinsic(IntrinsicInst* II, InstCombiner& IC) {
 
     // Simplify to target-generic intrinsic.
     if (Action.IID) {
-        SmallVector<Value*, 4> Args(II->arg_operands());
+        SmallVector<Value*, 4> Args(IGCLLVM::args(II));
         // All the target-generic intrinsics currently of interest to us have one
         // type argument, equal to that of the nvvm intrinsic's argument.
         Type* Tys[] = { II->getArgOperand(0)->getType() };
diff --git a/IGC/Compiler/Optimizer/IGCInstCombiner/IGCInstructionCombining.hpp b/IGC/Compiler/Optimizer/IGCInstCombiner/IGCInstructionCombining.hpp
index 46fe0e23c..bc61482a7 100644
--- a/IGC/Compiler/Optimizer/IGCInstCombiner/IGCInstructionCombining.hpp
+++ b/IGC/Compiler/Optimizer/IGCInstCombiner/IGCInstructionCombining.hpp
@@ -15,7 +15,7 @@ SPDX-License-Identifier: MIT
 #include "llvm/Transforms/InstCombine/InstCombineWorklist.h"
 #else
 #include "llvm/Transforms/Utils/InstructionWorklist.h"
-using llvm::InstCombineWorklist = llvm::InstructionWorklist;
+using InstCombineWorklist = llvm::InstructionWorklist;
 #endif
 #include "llvm/IR/PassManager.h"
 #include "Compiler/InitializePasses.h"
diff --git a/IGC/Compiler/Optimizer/IntDivConstantReduction.cpp b/IGC/Compiler/Optimizer/IntDivConstantReduction.cpp
index af5c4744c..9419eca51 100644
--- a/IGC/Compiler/Optimizer/IntDivConstantReduction.cpp
+++ b/IGC/Compiler/Optimizer/IntDivConstantReduction.cpp
@@ -27,6 +27,10 @@ SPDX-License-Identifier: MIT
 #include "Probe/Assertion.h"
 #include "Compiler/CISACodeGen/helper.h"
 
+#if LLVM_VERSION_MAJOR >= 14
+#include "llvm/Support/DivisionByConstantInfo.h"
+#endif
+
 using namespace llvm;
 
 // This pass reduces division and remainder instructions with constant
@@ -479,8 +483,28 @@ struct IntDivConstantReduction : public FunctionPass
         //
         const int bitSize = dividend->getType()->getIntegerBitWidth();
         //
+#if LLVM_VERSION_MAJOR >= 14
+        SignedDivisionByConstantInfo appxRecip = SignedDivisionByConstantInfo::get(divisor);
+#else
         APInt::ms appxRecip = divisor.magic();
+#endif
         //
+#if LLVM_VERSION_MAJOR >= 14
+        ConstantInt *appxRcp = IGC::getConstantSInt(
+            B, bitSize, appxRecip.Magic.getSExtValue());
+        Value *appxQ =
+            IGC::CreateMulh(F, B, true, dividend, appxRcp);
+        if (divisor.isStrictlyPositive() && appxRecip.Magic.isNegative()) {
+            appxQ = B.CreateAdd(appxQ, dividend, "q_appx");
+        }
+        if (divisor.isNegative() && appxRecip.Magic.isStrictlyPositive()) {
+            appxQ = B.CreateSub(appxQ, dividend, "q_appx");
+        }
+        if (appxRecip.ShiftAmount > 0) {
+            ConstantInt *shift = IGC::getConstantSInt(B, bitSize, appxRecip.ShiftAmount);
+            appxQ = B.CreateAShr(appxQ, shift, "q_appx");
+        }
+#else
         ConstantInt *appxRcp = IGC::getConstantSInt(
             B, bitSize, appxRecip.m.getSExtValue());
         Value *appxQ =
@@ -495,6 +519,7 @@ struct IntDivConstantReduction : public FunctionPass
             ConstantInt *shift = IGC::getConstantSInt(B, bitSize, appxRecip.s);
             appxQ = B.CreateAShr(appxQ, shift, "q_appx");
         }
+#endif
         //
         // Extract the sign bit and add it to the quotient
         if (IGC_GET_FLAG_VALUE(EnableConstIntDivReduction) == 3) {
@@ -520,13 +545,29 @@ struct IntDivConstantReduction : public FunctionPass
     {
         //////////////////////////////////////////////////
         // C.f. Hacker's Delight 10-8
+#if LLVM_VERSION_MAJOR >= 14
+        UnsignedDivisonByConstantInfo appxRecip = UnsignedDivisonByConstantInfo::get(divisor);
+#else
         APInt::mu appxRecip = divisor.magicu();
+#endif
         //
         const int bitSize = dividend->getType()->getIntegerBitWidth();
         //
         // even divisors can pre-shift the dividend to avoid
         // extra work at the end.
         Value *shiftedDividend = dividend;
+#if LLVM_VERSION_MAJOR >= 14
+        if (appxRecip.IsAdd && !divisor[0]) {
+            unsigned s = divisor.countTrailingZeros();
+            shiftedDividend = B.CreateLShr(shiftedDividend, s);
+            appxRecip = UnsignedDivisonByConstantInfo::get(divisor.lshr(s));
+            IGC_ASSERT_MESSAGE(!appxRecip.IsAdd, "expected to subtract now");
+            IGC_ASSERT_MESSAGE(appxRecip.ShiftAmount < divisor.getBitWidth(), "undefined shift");
+        }
+        //
+        ConstantInt *appxRcp = IGC::getConstantUInt(
+            B, bitSize, appxRecip.Magic.getZExtValue());
+#else
         if (appxRecip.a && !divisor[0]) {
             unsigned s = divisor.countTrailingZeros();
             shiftedDividend = B.CreateLShr(shiftedDividend, s);
@@ -537,9 +578,20 @@ struct IntDivConstantReduction : public FunctionPass
         //
         ConstantInt *appxRcp = IGC::getConstantUInt(
             B, bitSize, appxRecip.m.getZExtValue());
+#endif
         Value *appxQ =
             IGC::CreateMulh(F, B, false, shiftedDividend, appxRcp);
         //
+#if LLVM_VERSION_MAJOR >= 14
+        if (!appxRecip.IsAdd) {
+            appxQ = B.CreateLShr(appxQ, appxRecip.ShiftAmount, "q_appx");
+        } else {
+            Value *fixup = B.CreateSub(dividend, appxQ, "q_appx");
+            fixup = B.CreateLShr(fixup, 1);
+            appxQ = B.CreateAdd(fixup, appxQ, "q_appx");
+            appxQ = B.CreateLShr(appxQ, appxRecip.ShiftAmount - 1, "q_appx");
+        }
+#else
         if (!appxRecip.a) {
             appxQ = B.CreateLShr(appxQ, appxRecip.s, "q_appx");
         } else {
@@ -548,6 +600,7 @@ struct IntDivConstantReduction : public FunctionPass
             appxQ = B.CreateAdd(fixup, appxQ, "q_appx");
             appxQ = B.CreateLShr(appxQ, appxRecip.s - 1, "q_appx");
         }
+#endif
         return appxQ;
     }
 
diff --git a/IGC/Compiler/Optimizer/OpenCLPasses/AlignmentAnalysis/AlignmentAnalysis.cpp b/IGC/Compiler/Optimizer/OpenCLPasses/AlignmentAnalysis/AlignmentAnalysis.cpp
index d1f5d59c4..251431fba 100644
--- a/IGC/Compiler/Optimizer/OpenCLPasses/AlignmentAnalysis/AlignmentAnalysis.cpp
+++ b/IGC/Compiler/Optimizer/OpenCLPasses/AlignmentAnalysis/AlignmentAnalysis.cpp
@@ -165,7 +165,11 @@ unsigned int AlignmentAnalysis::visitSelectInst(SelectInst& I)
 
 unsigned int AlignmentAnalysis::visitPHINode(PHINode& I)
 {
+#if LLVM_VERSION_MAJOR >= 14
+    uint64_t newAlign = Value::MaximumAlignment;
+#else
     unsigned int newAlign = Value::MaximumAlignment;
+#endif
 
     // The alignment of a PHI is the minimal alignment of any of the
     // incoming values.
@@ -440,9 +444,13 @@ void AlignmentAnalysis::SetInstAlignment(MemSetInst& I)
 #if LLVM_VERSION_MAJOR == 4
     unsigned alignment = iSTD::Max(I.getAlignment(), getAlignValue(I.getRawDest()));
     I.setAlignment(ConstantInt::get(Type::getInt32Ty(I.getContext()), alignment));
-#elif LLVM_VERSION_MAJOR >= 7
+#elif LLVM_VERSION_MAJOR >= 7 && LLVM_VERSION_MAJOR < 14
     unsigned alignment = iSTD::Max(I.getDestAlignment(), getAlignValue(I.getRawDest()));
     I.setDestAlignment(alignment);
+#elif LLVM_VERSION_MAJOR >= 14
+    uint64_t alignment_value = iSTD::Max(I.getDestAlign()->value(), getAlignValue(I.getRawDest()));
+    llvm::Align alignment = llvm::Align(alignment_value);
+    I.setDestAlignment(alignment);
 #endif
 }
 
@@ -472,7 +480,11 @@ void AlignmentAnalysis::SetInstAlignment(MemMoveInst& I)
 #endif
 }
 
+#if LLVM_VERSION_MAJOR >= 14
+uint64_t AlignmentAnalysis::getAlignValue(Value* V) const
+#else
 unsigned int AlignmentAnalysis::getAlignValue(Value* V) const
+#endif
 {
     if (dyn_cast<Instruction>(V))
     {
@@ -541,6 +553,17 @@ unsigned int AlignmentAnalysis::getAlignValue(Value* V) const
     return MinimumAlignment;
 }
 
+#if LLVM_VERSION_MAJOR >= 14
+uint64_t AlignmentAnalysis::getConstantAlignment(uint64_t C) const
+{
+    if (!C)
+    {
+        return Value::MaximumAlignment;
+    }
+
+    return iSTD::Min(Value::MaximumAlignment, 1UL << llvm::countTrailingZeros(C));
+}
+#else
 unsigned int AlignmentAnalysis::getConstantAlignment(uint64_t C) const
 {
     if (!C)
@@ -550,3 +573,4 @@ unsigned int AlignmentAnalysis::getConstantAlignment(uint64_t C) const
 
     return iSTD::Min(Value::MaximumAlignment, 1U << llvm::countTrailingZeros(C));
 }
+#endif
diff --git a/IGC/Compiler/Optimizer/OpenCLPasses/AlignmentAnalysis/AlignmentAnalysis.hpp b/IGC/Compiler/Optimizer/OpenCLPasses/AlignmentAnalysis/AlignmentAnalysis.hpp
index 8836958bb..6d60eecd1 100644
--- a/IGC/Compiler/Optimizer/OpenCLPasses/AlignmentAnalysis/AlignmentAnalysis.hpp
+++ b/IGC/Compiler/Optimizer/OpenCLPasses/AlignmentAnalysis/AlignmentAnalysis.hpp
@@ -88,12 +88,19 @@ namespace IGC
         /// @brief Returns the alignment for V, if it is known.
         ///        Otherwise, returns the maximum alignment.
         /// @param V the value the alignment of which we're interested in
+#if LLVM_VERSION_MAJOR >= 14
+        uint64_t getAlignValue(llvm::Value* V) const;
+#else
         unsigned int getAlignValue(llvm::Value* V) const;
-
+#endif
         /// @brief Returns the alignment of a constant integer.
         ///        This is normally 1 << ctz(C) (the highest power of 2 that divides C),
         ///        except when C is 0, when it is the max alignment
+#if LLVM_VERSION_MAJOR >= 14
+        uint64_t getConstantAlignment(uint64_t C) const;
+#else
         unsigned int getConstantAlignment(uint64_t C) const;
+#endif
 
         /// @brief This map stores the known alignment of every value.
         llvm::MapVector<llvm::Value*, unsigned int> m_alignmentMap;
diff --git a/IGC/Compiler/Optimizer/OpenCLPasses/DebuggerSupport/ImplicitGIDPass.cpp b/IGC/Compiler/Optimizer/OpenCLPasses/DebuggerSupport/ImplicitGIDPass.cpp
index be493117b..70f655e5a 100644
--- a/IGC/Compiler/Optimizer/OpenCLPasses/DebuggerSupport/ImplicitGIDPass.cpp
+++ b/IGC/Compiler/Optimizer/OpenCLPasses/DebuggerSupport/ImplicitGIDPass.cpp
@@ -305,7 +305,11 @@ Value* ImplicitGlobalId::CreateGetId(IRBuilder<>& B, GlobalOrLocal wi)
 
         // Set function attributes
         AttributeList funcAttrs;
+#if LLVM_VERSION_MAJOR >= 14
+        AttrBuilder attBuilder(pNewFunc->getContext());
+#else
         AttrBuilder attBuilder;
+#endif
         attBuilder.addAttribute(Attribute::NoUnwind).addAttribute(Attribute::ReadNone);
         funcAttrs = AttributeList::get(pNewFunc->getContext(), AttributeList::FunctionIndex, attBuilder);
         pNewFunc->setAttributes(funcAttrs);
diff --git a/IGC/Compiler/Optimizer/OpenCLPasses/DeviceEnqueueFuncs/TransformBlocks.cpp b/IGC/Compiler/Optimizer/OpenCLPasses/DeviceEnqueueFuncs/TransformBlocks.cpp
index 3485bb50a..f500d4a8e 100644
--- a/IGC/Compiler/Optimizer/OpenCLPasses/DeviceEnqueueFuncs/TransformBlocks.cpp
+++ b/IGC/Compiler/Optimizer/OpenCLPasses/DeviceEnqueueFuncs/TransformBlocks.cpp
@@ -46,6 +46,7 @@ SPDX-License-Identifier: MIT
 #include "llvm/Support/CommandLine.h"
 #include "llvmWrapper/IR/DIBuilder.h"
 #include "common/LLVMWarningsPop.hpp"
+#include "llvm/Support/Regex.h"
 #include <algorithm>
 #include <map>
 #include <unordered_set>
@@ -838,7 +839,7 @@ namespace //Anonymous
             : ObjCBlockCallArgs(call, dataContext)
             , _block(nullptr)
         {
-            auto arg = call.arg_operands().begin();
+            auto arg = IGCLLVM::args(call).begin();
 
             _queue = *(arg++);
             _flags = *(arg++);
@@ -852,7 +853,7 @@ namespace //Anonymous
 
             _block = *(arg++);
 
-            while (arg != call.arg_operands().end())
+            while (arg != IGCLLVM::args(call).end())
             {
                 if ((*arg)->getType()->isIntegerTy(32))
                 {
@@ -1564,7 +1565,7 @@ namespace //Anonymous
                     auto callInst = dyn_cast<CallInst>(user);
                     if (!callInst) continue;
 
-                    for (auto& arg : callInst->arg_operands()) {
+                    for (auto& arg : IGCLLVM::args(callInst)) {
                         if (Function * invoke = dyn_cast<Function>(arg)) {
                             if (isInvokeFunctionKernelWrapper(invoke, dataContext)) {
                                 // Inline the wrapped invoke function.
@@ -2450,7 +2451,13 @@ namespace //Anonymous
                 {
                     // FIXME: This potentially can be rewritted to be simpler.
                     AttributeList attrSet = AttributeList::get(arg.getParent()->getContext(), AttributeList::FunctionIndex, llvm::Attribute::ByVal);
-                    arg.addAttr(attrSet.getAttribute(AttributeList::FunctionIndex, llvm::Attribute::ByVal));
+                    arg.addAttr(
+#if LLVM_VERSION_MAJOR >= 14
+                        attrSet.getAttributeAtIndex(AttributeList::FunctionIndex, llvm::Attribute::ByVal)
+#else
+                        attrSet.getAttribute(AttributeList::FunctionIndex, llvm::Attribute::ByVal)
+#endif
+                    );
                     ++byValI;
                 }
             }
diff --git a/IGC/Compiler/Optimizer/OpenCLPasses/TransformUnmaskedFunctionsPass.cpp b/IGC/Compiler/Optimizer/OpenCLPasses/TransformUnmaskedFunctionsPass.cpp
index 9355af9e9..efbd55c43 100644
--- a/IGC/Compiler/Optimizer/OpenCLPasses/TransformUnmaskedFunctionsPass.cpp
+++ b/IGC/Compiler/Optimizer/OpenCLPasses/TransformUnmaskedFunctionsPass.cpp
@@ -254,9 +254,15 @@ bool TransformUnmaskedFunctionsPass::runOnFunction(llvm::Function& F)
     for (User *U : F.users()) {
         if (CallInst* CI = dyn_cast<CallInst>(U)) {
             if (CI->hasFnAttr(llvm::Attribute::AlwaysInline)) {
+#if LLVM_VERSION_MAJOR >= 14
+                CI->removeAttributeAtIndex(AttributeList::FunctionIndex, llvm::Attribute::AlwaysInline);
+            }
+            CI->addAttributeAtIndex(AttributeList::FunctionIndex, llvm::Attribute::NoInline);
+#else
                 CI->removeAttribute(AttributeList::FunctionIndex, llvm::Attribute::AlwaysInline);
             }
             CI->addAttribute(AttributeList::FunctionIndex, llvm::Attribute::NoInline);
+#endif
         }
     }
     return true;
diff --git a/IGC/Compiler/Optimizer/PreCompiledFuncImport.cpp b/IGC/Compiler/Optimizer/PreCompiledFuncImport.cpp
index e07c6ff64..bc75dcb05 100644
--- a/IGC/Compiler/Optimizer/PreCompiledFuncImport.cpp
+++ b/IGC/Compiler/Optimizer/PreCompiledFuncImport.cpp
@@ -950,7 +950,11 @@ void PreCompiledFuncImport::processInt32Divide(BinaryOperator& inst, Int32Emulat
             funcName,
             m_pModule);
     }
+#if LLVM_VERSION_MAJOR >= 14
+    func->addAttributeAtIndex(0, llvm::Attribute::get(func->getContext(), llvm::Attribute::AlwaysInline));
+#else
     func->addAttribute(0, llvm::Attribute::AlwaysInline);
+#endif
 
 
 
diff --git a/IGC/DebugInfo/StreamEmitter.cpp b/IGC/DebugInfo/StreamEmitter.cpp
index 00a210fea..a4f4f40de 100644
--- a/IGC/DebugInfo/StreamEmitter.cpp
+++ b/IGC/DebugInfo/StreamEmitter.cpp
@@ -32,7 +32,7 @@ See LICENSE.TXT for details.
 #include "llvm/MC/MCSymbol.h"
 #include "llvm/MC/MCValue.h"
 #include "llvm/Support/SourceMgr.h"
-#include "llvm/Support/TargetRegistry.h"
+#include "llvmWrapper/Support/TargetRegistry.h"
 #include "common/LLVMWarningsPop.hpp"
 // clang-format on
 
@@ -322,7 +322,11 @@ public:
   }
 #endif
 
+#if LLVM_VERSION_MAJOR >= 14
+  bool writeNopData(raw_ostream &OS, uint64_t Count, const MCSubtargetInfo *STI) const override {
+#else
   bool writeNopData(raw_ostream &OS, uint64_t Count) const override {
+#endif
     const char nop = (char)0x90;
     for (uint64_t i = 0; i < Count; ++i) {
       OS.write(&nop, 1);
@@ -417,7 +421,11 @@ StreamEmitter::StreamEmitter(raw_pwrite_stream &outStream,
                                     std::move(pObjectWriter),
                                     std::move(pCodeEmitter), isRelaxAll);
 
+#if LLVM_VERSION_MAJOR >= 14
+  m_pMCStreamer->initSections(isNoExecStack, *m_pContext->getSubtargetInfo());
+#else
   m_pMCStreamer->InitSections(isNoExecStack);
+#endif
 }
 
 StreamEmitter::~StreamEmitter() {
diff --git a/IGC/LLVM3DBuilder/BuiltinsFrontendDefinitions.hpp b/IGC/LLVM3DBuilder/BuiltinsFrontendDefinitions.hpp
index 7e8074bde..8f74f2097 100644
--- a/IGC/LLVM3DBuilder/BuiltinsFrontendDefinitions.hpp
+++ b/IGC/LLVM3DBuilder/BuiltinsFrontendDefinitions.hpp
@@ -3736,7 +3736,10 @@ inline llvm::Value* LLVM3DBuilder<preserveNames, T, Inserter>::create_wavePrefix
 inline llvm::CallInst* setUnsafeToHoistAttr(llvm::CallInst *CI)
     {
         CI->setConvergent();
-#if LLVM_VERSION_MAJOR >= 7
+#if LLVM_VERSION_MAJOR >= 14
+        CI->setOnlyAccessesInaccessibleMemory();
+        CI->removeAttributeAtIndex(llvm::AttributeList::FunctionIndex, llvm::Attribute::ReadNone);
+#elif LLVM_VERSION_MAJOR >= 7
         CI->setOnlyAccessesInaccessibleMemory();
         CI->removeAttribute(llvm::AttributeList::FunctionIndex, llvm::Attribute::ReadNone);
 #else
diff --git a/IGC/VectorCompiler/CMCL/tools/Translator/Main.cpp b/IGC/VectorCompiler/CMCL/tools/Translator/Main.cpp
index f1b3214a0..c7e23271d 100644
--- a/IGC/VectorCompiler/CMCL/tools/Translator/Main.cpp
+++ b/IGC/VectorCompiler/CMCL/tools/Translator/Main.cpp
@@ -8,6 +8,7 @@ SPDX-License-Identifier: MIT
 
 #include "cmcl/Support/BuiltinTranslator.h"
 
+#include <llvm/Pass.h>
 #include <llvm/Bitcode/BitcodeWriterPass.h>
 #include <llvm/IR/IRPrintingPasses.h>
 #include <llvm/IR/LLVMContext.h>
diff --git a/IGC/VectorCompiler/include/vc/Support/GenXDiagnostic.h b/IGC/VectorCompiler/include/vc/Support/GenXDiagnostic.h
index 67ba8a50d..acc94faa9 100644
--- a/IGC/VectorCompiler/include/vc/Support/GenXDiagnostic.h
+++ b/IGC/VectorCompiler/include/vc/Support/GenXDiagnostic.h
@@ -126,7 +126,7 @@ public:
 
   void print(llvm::DiagnosticPrinter &DP) const override {
     if (Severity == llvm::DS_Error)
-      llvm::report_fatal_error(Description);
+      llvm::report_fatal_error(llvm::StringRef(Description));
     DP << Description;
   }
 
diff --git a/IGC/VectorCompiler/lib/GenXCodeGen/GenXCisaBuilder.cpp b/IGC/VectorCompiler/lib/GenXCodeGen/GenXCisaBuilder.cpp
index b4d616a3c..0bae2e334 100644
--- a/IGC/VectorCompiler/lib/GenXCodeGen/GenXCisaBuilder.cpp
+++ b/IGC/VectorCompiler/lib/GenXCodeGen/GenXCisaBuilder.cpp
@@ -6378,7 +6378,7 @@ void GenXKernelBuilder::buildStackCall(CallInst *CI,
 
   // Check whether the called function has a predicate arg that is EM.
   int EMOperandNum = -1, EMIdx = -1;
-  for (auto &Arg : CI->arg_operands()) {
+  for (auto &Arg : IGCLLVM::args(CI)) {
     ++EMIdx;
     if (!Arg->getType()->getScalarType()->isIntegerTy(1))
       continue;
@@ -6389,7 +6389,7 @@ void GenXKernelBuilder::buildStackCall(CallInst *CI,
   }
 
   int TotalArgSize = 0;
-  for (auto &CallArg : CI->arg_operands())
+  for (auto &CallArg : IGCLLVM::args(CI))
     TotalArgSize += getValueSize(CallArg->getType());
 
   VISA_GenVar *Sp = nullptr, *Arg = nullptr, *Ret = nullptr;
@@ -6403,7 +6403,7 @@ void GenXKernelBuilder::buildStackCall(CallInst *CI,
   uint64_t StackOff = 0;
   bool StackStarted = false;
   // pack arguments
-  for (auto &CallArg : CI->arg_operands()) {
+  for (auto &CallArg : IGCLLVM::args(CI)) {
     auto *CallArgLR = Liveness->getLiveRangeOrNull(CallArg.get());
     if (CallArgLR && CallArgLR->getCategory() == vc::RegCategory::EM)
       continue;
diff --git a/IGC/VectorCompiler/lib/GenXCodeGen/GenXCoalescing.cpp b/IGC/VectorCompiler/lib/GenXCodeGen/GenXCoalescing.cpp
index 6325fd01a..3a2ff7ac0 100644
--- a/IGC/VectorCompiler/lib/GenXCodeGen/GenXCoalescing.cpp
+++ b/IGC/VectorCompiler/lib/GenXCodeGen/GenXCoalescing.cpp
@@ -160,7 +160,6 @@ SPDX-License-Identifier: MIT
 /// and insert an extra copy at the start of the function.
 ///
 //===----------------------------------------------------------------------===//
-#define DEBUG_TYPE "GENX_COALESCING"
 
 #include "FunctionGroup.h"
 #include "GenX.h"
@@ -203,6 +202,8 @@ SPDX-License-Identifier: MIT
 #include <map>
 #include <vector>
 
+#define DEBUG_TYPE "GENX_COALESCING"
+
 using namespace llvm;
 using namespace genx;
 
diff --git a/IGC/VectorCompiler/lib/GenXCodeGen/GenXDepressurizer.cpp b/IGC/VectorCompiler/lib/GenXCodeGen/GenXDepressurizer.cpp
index 5a9727632..72a415622 100644
--- a/IGC/VectorCompiler/lib/GenXCodeGen/GenXDepressurizer.cpp
+++ b/IGC/VectorCompiler/lib/GenXCodeGen/GenXDepressurizer.cpp
@@ -101,7 +101,6 @@ SPDX-License-Identifier: MIT
 /// flag pressure.
 ///
 //===----------------------------------------------------------------------===//
-#define DEBUG_TYPE "GENX_DEPRESSURIZER"
 
 #include "FunctionGroup.h"
 #include "GenX.h"
@@ -127,6 +126,8 @@ SPDX-License-Identifier: MIT
 using namespace llvm;
 using namespace genx;
 
+#define DEBUG_TYPE "GENX_DEPRESSURIZER"
+
 static cl::opt<unsigned>
     LimitGenXDepressurizer("limit-genx-depressurizer", cl::init(UINT_MAX),
                            cl::Hidden, cl::desc("Limit GenX depressurizer."));
diff --git a/IGC/VectorCompiler/lib/GenXCodeGen/GenXEmulate.cpp b/IGC/VectorCompiler/lib/GenXCodeGen/GenXEmulate.cpp
index 8a409a0f3..b6323095d 100644
--- a/IGC/VectorCompiler/lib/GenXCodeGen/GenXEmulate.cpp
+++ b/IGC/VectorCompiler/lib/GenXCodeGen/GenXEmulate.cpp
@@ -14,6 +14,7 @@ SPDX-License-Identifier: MIT
 ///
 //===----------------------------------------------------------------------===//
 
+#include "llvmWrapper/IR/Instructions.h"
 #define DEBUG_TYPE "GENX_EMULATION"
 
 #include "GenX.h"
@@ -1220,7 +1221,7 @@ Value *GenXEmulate::Emu64Expander::visitGenxFPToISat(CallInst &CI) {
     vc::diagnose(CI.getContext(), "GenXEmulate",
                  "Unsupported instruction for emulation", &CI);
 
-  SmallVector<Value *, 8> Args(CI.arg_operands());
+  SmallVector<Value *, 8> Args(IGCLLVM::args(CI));
 
   return Builder.CreateCall(Iter->second, Args);
 }
diff --git a/IGC/VectorCompiler/lib/GenXCodeGen/GenXLowering.cpp b/IGC/VectorCompiler/lib/GenXCodeGen/GenXLowering.cpp
index f3bcc780c..8f3135de0 100644
--- a/IGC/VectorCompiler/lib/GenXCodeGen/GenXLowering.cpp
+++ b/IGC/VectorCompiler/lib/GenXCodeGen/GenXLowering.cpp
@@ -85,7 +85,6 @@ SPDX-License-Identifier: MIT
 /// GenXLiveness has another go at splitting them up.
 ///
 //===----------------------------------------------------------------------===//
-#define DEBUG_TYPE "GENX_LOWERING"
 
 #include "GenX.h"
 #include "GenXGotoJoin.h"
@@ -131,6 +130,8 @@ SPDX-License-Identifier: MIT
 #include <numeric>
 #include "Probe/Assertion.h"
 
+#define DEBUG_TYPE "GENX_LOWERING"
+
 using namespace llvm;
 using namespace genx;
 
diff --git a/IGC/VectorCompiler/lib/GenXCodeGen/GenXPatternMatch.cpp b/IGC/VectorCompiler/lib/GenXCodeGen/GenXPatternMatch.cpp
index 29969cc97..9b3dacf40 100644
--- a/IGC/VectorCompiler/lib/GenXCodeGen/GenXPatternMatch.cpp
+++ b/IGC/VectorCompiler/lib/GenXCodeGen/GenXPatternMatch.cpp
@@ -42,7 +42,6 @@ SPDX-License-Identifier: MIT
 ///
 //===----------------------------------------------------------------------===//
 
-#define DEBUG_TYPE "GENX_PATTERN_MATCH"
 #include "GenX.h"
 #include "GenXConstants.h"
 #include "GenXModule.h"
@@ -88,6 +87,8 @@ SPDX-License-Identifier: MIT
 #include "IGC/common/StringMacros.hpp"
 #include "IGC/common/debug/DebugMacros.hpp"
 
+#define DEBUG_TYPE "GENX_PATTERN_MATCH"
+
 using namespace llvm;
 using namespace llvm::PatternMatch;
 using namespace genx;
diff --git a/IGC/VectorCompiler/lib/GenXCodeGen/GenXPrologEpilogInsertion.cpp b/IGC/VectorCompiler/lib/GenXCodeGen/GenXPrologEpilogInsertion.cpp
index 869c4881e..ef2a0ab4d 100644
--- a/IGC/VectorCompiler/lib/GenXCodeGen/GenXPrologEpilogInsertion.cpp
+++ b/IGC/VectorCompiler/lib/GenXCodeGen/GenXPrologEpilogInsertion.cpp
@@ -401,9 +401,15 @@ void GenXPrologEpilogInsertion::removeAttrs(Function &F) const {
 }
 
 static void removeCallInstAttrs(CallInst &CI) {
+#if LLVM_VERSION_MAJOR >= 14
+  CI.removeAttributeAtIndex(AttributeList::FunctionIndex, Attribute::ReadNone);
+  CI.removeAttributeAtIndex(AttributeList::FunctionIndex, Attribute::ReadOnly);
+  CI.removeAttributeAtIndex(AttributeList::FunctionIndex, Attribute::WriteOnly);
+#else
   CI.removeAttribute(AttributeList::FunctionIndex, Attribute::ReadNone);
   CI.removeAttribute(AttributeList::FunctionIndex, Attribute::ReadOnly);
   CI.removeAttribute(AttributeList::FunctionIndex, Attribute::WriteOnly);
+#endif
 }
 
 bool GenXPrologEpilogInsertion::runOnFunction(Function &F) {
diff --git a/IGC/VectorCompiler/lib/GenXCodeGen/GenXPromotePredicate.cpp b/IGC/VectorCompiler/lib/GenXCodeGen/GenXPromotePredicate.cpp
index 240a7c3ba..1adf1282d 100644
--- a/IGC/VectorCompiler/lib/GenXCodeGen/GenXPromotePredicate.cpp
+++ b/IGC/VectorCompiler/lib/GenXCodeGen/GenXPromotePredicate.cpp
@@ -16,7 +16,6 @@ SPDX-License-Identifier: MIT
 ///
 //===----------------------------------------------------------------------===//
 
-#define DEBUG_TYPE "GENX_PROMOTE_PREDICATE"
 
 #include "GenX.h"
 #include "GenXUtil.h"
@@ -28,6 +27,8 @@ SPDX-License-Identifier: MIT
 
 #include "llvmWrapper/IR/DerivedTypes.h"
 
+#define DEBUG_TYPE "GENX_PROMOTE_PREDICATE"
+
 using namespace llvm;
 using namespace genx;
 
diff --git a/IGC/VectorCompiler/lib/GenXCodeGen/GenXPromoteStatefulToBindless.cpp b/IGC/VectorCompiler/lib/GenXCodeGen/GenXPromoteStatefulToBindless.cpp
index 6489e7d84..f234a7b07 100644
--- a/IGC/VectorCompiler/lib/GenXCodeGen/GenXPromoteStatefulToBindless.cpp
+++ b/IGC/VectorCompiler/lib/GenXCodeGen/GenXPromoteStatefulToBindless.cpp
@@ -140,7 +140,7 @@ static void reportUnhandledIntrinsic(const char *Func, GenXIntrinsic::ID Id) {
   std::ostringstream SS;
   SS << "In function '" << Func << "': Intrinsic '" << getGenXName(Id)
      << "' is not yet supported";
-  llvm::report_fatal_error(SS.str());
+  llvm::report_fatal_error(llvm::StringRef(SS.str()));
 }
 
 // Buffer argument kind is converted to GENERAL to denote that
diff --git a/IGC/VectorCompiler/lib/GenXCodeGen/GenXStackUsage.cpp b/IGC/VectorCompiler/lib/GenXCodeGen/GenXStackUsage.cpp
index bc99f8a67..423b58a1b 100644
--- a/IGC/VectorCompiler/lib/GenXCodeGen/GenXStackUsage.cpp
+++ b/IGC/VectorCompiler/lib/GenXCodeGen/GenXStackUsage.cpp
@@ -103,7 +103,11 @@ class StackAnalysis : public InstVisitor<StackAnalysis> {
       NotStarted // function has not started processing but will start
     };
     uint64_t m_UsedSz{0};
+#if LLVM_VERSION_MAJOR >= 14
+    uint64_t m_RequiredAlign{0};
+#else
     unsigned m_RequiredAlign{0};
+#endif
     bool m_HasIndirect{false};
     Function *m_pHeavyFunction{nullptr};
     ProcessingState m_ProcessingFlag{ProcessingState::NotStarted};
@@ -112,7 +116,11 @@ class StackAnalysis : public InstVisitor<StackAnalysis> {
   // map between Function and its State
   std::unordered_map<Function *, FunctionState> m_ProcessedFs{};
 
+#if LLVM_VERSION_MAJOR >= 14
+  llvm::Optional<std::pair<uint64_t, uint64_t>> checkFunction(Function &F);
+#else
   llvm::Optional<std::pair<uint64_t, unsigned>> checkFunction(Function &F);
+#endif
   std::string GenerateCallSequence(Function &F);
   void checkKernel(Function &Kernel);
 
@@ -156,7 +164,11 @@ void StackAnalysis::visitFunction(Function &F) {
 }
 
 // Check CallGraph and usage of allocas in function
+#if LLVM_VERSION_MAJOR >= 14
+llvm::Optional<std::pair<uint64_t, uint64_t>>
+#else
 llvm::Optional<std::pair<uint64_t, unsigned>>
+#endif
 StackAnalysis::checkFunction(Function &F) {
   auto pOnF = m_ProcessedFs.find(&F);
   IGC_ASSERT_MESSAGE(pOnF != m_ProcessedFs.end(),
@@ -248,7 +260,13 @@ void StackAnalysis::checkKernel(Function &Kernel) {
                << Kernel.getName() << ")\n");
     return;
   }
+
+#if LLVM_VERSION_MAJOR >= 14
+  auto [KernelUsedStack, KernelAlignment_] = *Res;
+  uint64_t KernelAlignment = static_cast<uint64_t>(KernelAlignment_);
+#else
   auto [KernelUsedStack, KernelAlignment] = *Res;
+#endif
 
   KernelAlignment = std::max(KernelAlignment, visa::BytesPerSVMPtr);
   // align stack size to kernel alignment requirement
diff --git a/IGC/VectorCompiler/lib/GenXCodeGen/GenXTargetMachine.h b/IGC/VectorCompiler/lib/GenXCodeGen/GenXTargetMachine.h
index 25f1184f1..fd64b8b1f 100644
--- a/IGC/VectorCompiler/lib/GenXCodeGen/GenXTargetMachine.h
+++ b/IGC/VectorCompiler/lib/GenXCodeGen/GenXTargetMachine.h
@@ -172,7 +172,11 @@ public:
   }
 
   void getUnrollingPreferences(Loop *L, ScalarEvolution &SE,
-                               TTI::UnrollingPreferences &UP) {
+                               TTI::UnrollingPreferences &UP
+#if LLVM_VERSION_MAJOR >= 14
+                             , OptimizationRemarkEmitter* ORE
+#endif
+                               ) {
     if (BC.ignoreLoopUnrollThresholdOnPragma()) {
       if (GetUnrollMetadataForLoop(L, "llvm.loop.unroll.full"))
         UP.Threshold = std::numeric_limits<unsigned>::max();
diff --git a/IGC/VectorCompiler/lib/GenXCodeGen/GenXVectorCombiner.cpp b/IGC/VectorCompiler/lib/GenXCodeGen/GenXVectorCombiner.cpp
index 8f5746de3..68b85c576 100644
--- a/IGC/VectorCompiler/lib/GenXCodeGen/GenXVectorCombiner.cpp
+++ b/IGC/VectorCompiler/lib/GenXCodeGen/GenXVectorCombiner.cpp
@@ -14,7 +14,6 @@ SPDX-License-Identifier: MIT
 // and if we can combine them together, we do this
 ///
 //===----------------------------------------------------------------------===//
-#define DEBUG_TYPE "GENX_VECTOR_COMBINER"
 
 #include <algorithm>
 
@@ -34,6 +33,8 @@ SPDX-License-Identifier: MIT
 using namespace llvm;
 using namespace genx;
 
+#define DEBUG_TYPE "GENX_VECTOR_COMBINER"
+
 STATISTIC(NumOfWidenInsructions,
           "Number of combined to wider variant instructions");
 
diff --git a/IGC/VectorCompiler/lib/GenXCodeGen/GenXVisa.h b/IGC/VectorCompiler/lib/GenXCodeGen/GenXVisa.h
index e23f472ec..3f8241751 100644
--- a/IGC/VectorCompiler/lib/GenXCodeGen/GenXVisa.h
+++ b/IGC/VectorCompiler/lib/GenXCodeGen/GenXVisa.h
@@ -63,7 +63,11 @@ namespace llvm {
     // convention limits them to 12 and 8.
     constexpr static unsigned ArgRegSizeInGRFs = 12;
     constexpr static unsigned RetRegSizeInGRFs = 8;
+#if LLVM_VERSION_MAJOR >= 14
+    constexpr static uint64_t BytesPerSVMPtr = 8;
+#else
     constexpr static unsigned BytesPerSVMPtr = 8;
+#endif
     constexpr static unsigned BytesPerOword = 16;
     constexpr static unsigned StackPerThreadScratch = 256;
     constexpr static unsigned StackPerThreadSVM = 8192*2;
diff --git a/IGC/VectorCompiler/lib/GenXOpts/CMPacketize/GenXPacketize.cpp b/IGC/VectorCompiler/lib/GenXOpts/CMPacketize/GenXPacketize.cpp
index ef7552797..97c26d19f 100644
--- a/IGC/VectorCompiler/lib/GenXOpts/CMPacketize/GenXPacketize.cpp
+++ b/IGC/VectorCompiler/lib/GenXOpts/CMPacketize/GenXPacketize.cpp
@@ -818,7 +818,7 @@ Value *GenXPacketize::packetizeLLVMIntrinsic(Instruction *pInst) {
   // packetize intrinsic operands
   std::vector<Type *> vectorArgTys;
   std::vector<Value *> packetizedArgs;
-  for (auto &operand : pCall->arg_operands()) {
+  for (auto &operand : IGCLLVM::args(pCall)) {
     auto VV = getPacketizeValue(operand.get());
     packetizedArgs.push_back(VV);
     vectorArgTys.push_back(VV->getType());
diff --git a/IGC/VectorCompiler/lib/GenXOpts/CMTrans/CMABI.cpp b/IGC/VectorCompiler/lib/GenXOpts/CMTrans/CMABI.cpp
index 7650aa460..19f2dfb33 100644
--- a/IGC/VectorCompiler/lib/GenXOpts/CMTrans/CMABI.cpp
+++ b/IGC/VectorCompiler/lib/GenXOpts/CMTrans/CMABI.cpp
@@ -21,7 +21,6 @@ SPDX-License-Identifier: MIT
 ///
 //===----------------------------------------------------------------------===//
 
-#define DEBUG_TYPE "cmabi"
 
 #include "llvmWrapper/Analysis/CallGraph.h"
 #include "llvmWrapper/IR/DerivedTypes.h"
@@ -84,6 +83,8 @@ SPDX-License-Identifier: MIT
 #include <unordered_set>
 #include <vector>
 
+#define DEBUG_TYPE "cmabi"
+
 using namespace llvm;
 
 static cl::opt<unsigned>
@@ -493,9 +494,17 @@ CallGraphNode *CMABI::TransformKernel(Function *F) {
         ArgTys.push_back(Ty);
     } else {
       // Unchanged argument
+#if LLVM_VERSION_MAJOR >= 14
+      AttributeSet attrs = PAL.getParamAttrs(ArgIndex);
+#else
       AttributeSet attrs = PAL.getParamAttributes(ArgIndex);
+#endif
       if (attrs.hasAttributes()) {
+#if LLVM_VERSION_MAJOR >= 14
+        AttrBuilder B(Context, attrs);
+#else
         AttrBuilder B(attrs);
+#endif
         AttrVec = AttrVec.addParamAttributes(Context, ArgTys.size(), B);
       }
       ArgTys.push_back(I->getType());
@@ -507,10 +516,19 @@ CallGraphNode *CMABI::TransformKernel(Function *F) {
     "type out of sync, expect bool arguments");
 
   // Add any function attributes.
+#if LLVM_VERSION_MAJOR >= 14
+  AttributeSet FnAttrs = PAL.getFnAttrs();
+#else
   AttributeSet FnAttrs = PAL.getFnAttributes();
+#endif
   if (FnAttrs.hasAttributes()) {
+#if LLVM_VERSION_MAJOR >= 14
+    AttrBuilder B(Context, FnAttrs);
+    AttrVec = AttrVec.addAttributesAtIndex(Context, AttributeList::FunctionIndex, B);
+#else
     AttrBuilder B(FnAttrs);
     AttrVec = AttrVec.addAttributes(Context, AttributeList::FunctionIndex, B);
+#endif
   }
 
   // Create the new function body and insert it into the module.
@@ -1308,7 +1326,7 @@ void ArgRefPattern::process(DominatorTree &DT) {
     Builder.SetInsertPoint(LI);
     Value *SrcVal = Builder.CreateLoad(
         BaseAlloca->getType()->getPointerElementType(), BaseAlloca);
-    SmallVector<Value *, 8> Args(CopyInRegion->arg_operands());
+    SmallVector<Value *, 8> Args(IGCLLVM::args(CopyInRegion));
     Args[0] = SrcVal;
     Value *Val = Builder.CreateCall(RdFn, Args);
     LI->replaceAllUsesWith(Val);
diff --git a/IGC/VectorCompiler/lib/GenXOpts/CMTrans/CMImpParam.cpp b/IGC/VectorCompiler/lib/GenXOpts/CMTrans/CMImpParam.cpp
index 624872696..81ee2b409 100644
--- a/IGC/VectorCompiler/lib/GenXOpts/CMTrans/CMImpParam.cpp
+++ b/IGC/VectorCompiler/lib/GenXOpts/CMTrans/CMImpParam.cpp
@@ -1085,9 +1085,17 @@ CMImpParam::processKernelParameters(Function *F,
   for (Function::arg_iterator I = F->arg_begin(), E = F->arg_end(); I != E;
        ++I, ++ArgIndex) {
     ArgTys.push_back(I->getType());
+#if LLVM_VERSION_MAJOR >= 14
+    AttributeSet attrs = PAL.getParamAttrs(ArgIndex);
+#else
     AttributeSet attrs = PAL.getParamAttributes(ArgIndex);
+#endif
     if (attrs.hasAttributes()) {
+#if LLVM_VERSION_MAJOR >= 14
+      AttrBuilder B(Context, attrs);
+#else
       AttrBuilder B(attrs);
+#endif
       AttrVec = AttrVec.addParamAttributes(Context, ArgIndex, B);
     }
   }
@@ -1111,10 +1119,19 @@ CMImpParam::processKernelParameters(Function *F,
     "type out of sync, expect bool arguments)");
 
   // Add any function attributes
+#if LLVM_VERSION_MAJOR >= 14
+  AttributeSet FnAttrs = PAL.getFnAttrs();
+#else
   AttributeSet FnAttrs = PAL.getFnAttributes();
+#endif
   if (FnAttrs.hasAttributes()) {
+#if LLVM_VERSION_MAJOR >= 14
+    AttrBuilder B(Context, FnAttrs);
+    AttrVec = AttrVec.addAttributesAtIndex(Context, AttributeList::FunctionIndex, B);
+#else
     AttrBuilder B(FnAttrs);
     AttrVec = AttrVec.addAttributes(Context, AttributeList::FunctionIndex, B);
+#endif
   }
 
   // Create new function body and insert into the module
diff --git a/IGC/VectorCompiler/lib/Support/BackendConfig.cpp b/IGC/VectorCompiler/lib/Support/BackendConfig.cpp
index 840e30d40..0784d6aba 100644
--- a/IGC/VectorCompiler/lib/Support/BackendConfig.cpp
+++ b/IGC/VectorCompiler/lib/Support/BackendConfig.cpp
@@ -193,8 +193,8 @@ readBiFModuleFromFile(const cl::opt<std::string> &File) {
   ErrorOr<std::unique_ptr<MemoryBuffer>> FileOrErr =
       MemoryBuffer::getFileOrSTDIN(File);
   if (!FileOrErr)
-    report_fatal_error("opening OpenCL BiF file failed: " +
-                       FileOrErr.getError().message());
+    report_fatal_error(llvm::StringRef("opening OpenCL BiF file failed: " +
+                       FileOrErr.getError().message()));
   return std::move(FileOrErr.get());
 }
 
diff --git a/IGC/VectorCompiler/lib/Utils/GenX/TransformArgCopy.cpp b/IGC/VectorCompiler/lib/Utils/GenX/TransformArgCopy.cpp
index b74416508..fcf28bc16 100644
--- a/IGC/VectorCompiler/lib/Utils/GenX/TransformArgCopy.cpp
+++ b/IGC/VectorCompiler/lib/Utils/GenX/TransformArgCopy.cpp
@@ -371,19 +371,38 @@ vc::TransformedFuncInfo::gatherAttributes(LLVMContext &Context,
     if (OrigArgInfoEntry.getKind() == ArgKind::General) {
       IGC_ASSERT_MESSAGE(!OrigArgInfoEntry.isOmittedArg(),
                          "unexpected omitted argument");
+#if LLVM_VERSION_MAJOR >= 14
+      AttributeSet ArgAttrs = AL.getParamAttrs(OrigIdx);
+#else
       AttributeSet ArgAttrs = AL.getParamAttributes(OrigIdx);
+#endif
       if (ArgAttrs.hasAttributes())
         GatheredAttrs = GatheredAttrs.addParamAttributes(
-            Context, OrigArgInfoEntry.getNewIdx(), AttrBuilder{ArgAttrs});
+            Context, OrigArgInfoEntry.getNewIdx(), AttrBuilder{
+#if LLVM_VERSION_MAJOR >= 14
+              Context,
+#endif
+              ArgAttrs
+            });
     }
   }
 
   // Gather function attributes.
-  AttributeSet FnAttrs = AL.getFnAttributes();
+#if LLVM_VERSION_MAJOR >= 14
+      AttributeSet FnAttrs = AL.getFnAttrs();
+#else
+      AttributeSet FnAttrs = AL.getFnAttributes();
+#endif
   if (FnAttrs.hasAttributes()) {
+#if LLVM_VERSION_MAJOR >= 14
+    AttrBuilder B(Context, FnAttrs);
+    GatheredAttrs =
+        GatheredAttrs.addAttributesAtIndex(Context, AttributeList::FunctionIndex, B);
+#else
     AttrBuilder B(FnAttrs);
     GatheredAttrs =
         GatheredAttrs.addAttributes(Context, AttributeList::FunctionIndex, B);
+#endif
   }
 
   return GatheredAttrs;
diff --git a/IGC/VectorCompiler/lib/Utils/General/BiF.cpp b/IGC/VectorCompiler/lib/Utils/General/BiF.cpp
index 4982e8369..67a79ff6d 100644
--- a/IGC/VectorCompiler/lib/Utils/General/BiF.cpp
+++ b/IGC/VectorCompiler/lib/Utils/General/BiF.cpp
@@ -32,7 +32,7 @@ getBiFModuleOrReportErrorImpl(MemoryBufferRef BiFModuleBuffer, LLVMContext &Ctx,
                     [&ErrStream](const llvm::ErrorInfoBase &EI) {
                       ErrStream << EI.message() << std::endl;
                     });
-    report_fatal_error(ErrStream.str());
+    report_fatal_error(llvm::StringRef(ErrStream.str()));
   }
   return std::move(BiFModule.get());
 }
diff --git a/IGC/VectorCompiler/lib/Utils/General/DebugInfo.cpp b/IGC/VectorCompiler/lib/Utils/General/DebugInfo.cpp
index 83a5c3dbb..30bf771c1 100644
--- a/IGC/VectorCompiler/lib/Utils/General/DebugInfo.cpp
+++ b/IGC/VectorCompiler/lib/Utils/General/DebugInfo.cpp
@@ -150,7 +150,11 @@ llvm::DIGlobalVariableExpression *vc::DIBuilder::createGlobalVariableExpression(
   auto *GV = DIGlobalVariable::getDistinct(
       Ctx, cast_or_null<DIScope>(CU), Name, LinkageName, CU->getFile(),
       0 /*Line No*/, Type, true /*IsLocalToUnit*/, true /*isDefined*/,
-      nullptr /*Decl*/, nullptr /*TemplateParams*/, 0 /*AlignInBits*/);
+      nullptr /*Decl*/, nullptr /*TemplateParams*/, 0 /*AlignInBits*/
+#if LLVM_VERSION_MAJOR >= 14
+      , nullptr /*Annotation*/
+#endif
+      );
   auto *EmptyExpr = DIExpression::get(Ctx, llvm::None);
   auto *GVE = DIGlobalVariableExpression::get(Ctx, GV, EmptyExpr);
 
@@ -182,5 +186,9 @@ llvm::DILocalVariable *vc::DIBuilder::createLocalVariable(
     unsigned LineNo, llvm::DIType *Type, unsigned ArgNo,
     llvm::DINode::DIFlags Flags, unsigned AlignInBits) const {
   return DILocalVariable::get(M.getContext(), Scope, Name, File, LineNo, Type,
-                              ArgNo, Flags, AlignInBits);
+                              ArgNo, Flags, AlignInBits
+#if LLVM_VERSION_MAJOR >= 14
+                            , nullptr
+#endif
+                            );
 }
diff --git a/IGC/VectorCompiler/utils/vcb/UniqueCompilation.cpp b/IGC/VectorCompiler/utils/vcb/UniqueCompilation.cpp
index 3f5599d17..66759a214 100644
--- a/IGC/VectorCompiler/utils/vcb/UniqueCompilation.cpp
+++ b/IGC/VectorCompiler/utils/vcb/UniqueCompilation.cpp
@@ -17,8 +17,8 @@ SPDX-License-Identifier: MIT
 #include <llvm/Support/FileSystem.h>
 #include <llvm/Support/MD5.h>
 #include <llvm/Support/MemoryBuffer.h>
-#include <llvm/Support/TargetRegistry.h>
 #include <llvm/Support/ToolOutputFile.h>
+#include <llvmWrapper/Support/TargetRegistry.h>
 #include <llvmWrapper/Target/TargetMachine.h>
 
 #include <llvm/Transforms/Utils/Cloning.h>
@@ -89,7 +89,7 @@ void generateBifSelectionProcedure(
   int FD;
   auto EC = llvm::sys::fs::openFileForWrite(Output, FD);
   if (EC)
-    report_fatal_error("vcb : can't open output file " + Output);
+    report_fatal_error(llvm::StringRef("vcb : can't open output file " + Output));
   raw_fd_ostream OS{FD, /*shouldClose=*/true};
 
   OS << "// This file is auto generated by vcb tool, DO NOT EDIT\n\n";
diff --git a/IGC/VectorCompiler/utils/vcb/vcb.cpp b/IGC/VectorCompiler/utils/vcb/vcb.cpp
index 617e56339..954aa15c7 100644
--- a/IGC/VectorCompiler/utils/vcb/vcb.cpp
+++ b/IGC/VectorCompiler/utils/vcb/vcb.cpp
@@ -24,11 +24,11 @@ SPDX-License-Identifier: MIT
 #include <llvm/Support/CommandLine.h>
 #include <llvm/Support/FileSystem.h>
 #include <llvm/Support/InitLLVM.h>
-#include <llvm/Support/TargetRegistry.h>
 #include <llvm/Support/ToolOutputFile.h>
 
 #include <llvm/Pass.h>
 #include <llvmWrapper/Target/TargetMachine.h>
+#include <llvmWrapper/Support/TargetRegistry.h>
 
 using namespace llvm;
 
@@ -121,7 +121,7 @@ void vcbCompileModule(std::unique_ptr<Module> &M, std::string Platform) {
   sys::fs::OpenFlags Flags = TextOutput ? sys::fs::OF_Text : sys::fs::OF_None;
   ToolOutputFile Output{OutputFilename, EC, Flags};
   if (EC)
-    report_fatal_error("Can't open file : " + OutputFilename);
+    report_fatal_error(llvm::StringRef("Can't open file : " + OutputFilename));
   if (TextOutput)
     PM.add(createPrintModulePass(Output.os()));
   else
diff --git a/IGC/WrapperLLVM/include/lldWrapper/Common/Driver.h b/IGC/WrapperLLVM/include/lldWrapper/Common/Driver.h
index 352a7ecd1..84340589a 100644
--- a/IGC/WrapperLLVM/include/lldWrapper/Common/Driver.h
+++ b/IGC/WrapperLLVM/include/lldWrapper/Common/Driver.h
@@ -19,7 +19,9 @@ namespace IGCLLD {
     namespace elf {
         inline bool link(llvm::ArrayRef<const char *> Args, bool CanExitEarly,
                          llvm::raw_ostream &stdoutOS, llvm::raw_ostream &stderrOS) {
-#if LLVM_VERSION_MAJOR >= 10
+#if LLVM_VERSION_MAJOR >= 14
+            return lld::elf::link(Args, stdoutOS, stderrOS, CanExitEarly, false);
+#elif LLVM_VERSION_MAJOR >= 10
             return lld::elf::link(Args, CanExitEarly, stdoutOS, stderrOS);
 #else
             (void)stdoutOS;
diff --git a/IGC/WrapperLLVM/include/llvmWrapper/IR/ConstantFolder.h b/IGC/WrapperLLVM/include/llvmWrapper/IR/ConstantFolder.h
index 41b1f81b4..6a7cb068a 100644
--- a/IGC/WrapperLLVM/include/llvmWrapper/IR/ConstantFolder.h
+++ b/IGC/WrapperLLVM/include/llvmWrapper/IR/ConstantFolder.h
@@ -31,11 +31,85 @@ namespace IGCLLVM
         ConstantFolderBase() :
             m_baseConstantFolder(llvm::ConstantFolder()) {}
 
+#if LLVM_VERSION_MAJOR < 14
         inline llvm::Constant* CreateAdd(llvm::Constant* LHS, llvm::Constant* RHS,
             bool HasNUW = false, bool HasNSW = false) const override {
             return m_baseConstantFolder.CreateAdd(LHS, RHS, HasNUW, HasNSW);
         }
 
+        inline llvm::Constant* CreateAnd(llvm::Constant* LHS, llvm::Constant* RHS) const override {
+            return m_baseConstantFolder.CreateAnd(LHS, RHS);
+        }
+
+        inline llvm::Constant* CreateOr(llvm::Constant* LHS, llvm::Constant* RHS) const override {
+            return m_baseConstantFolder.CreateOr(LHS, RHS);
+        }
+
+        inline llvm::Constant* CreateICmp(llvm::CmpInst::Predicate P, llvm::Constant* LHS,
+            llvm::Constant* RHS) const override {
+            return m_baseConstantFolder.CreateICmp(P, LHS, RHS);
+        }
+        inline llvm::Constant* CreateSelect(llvm::Constant* C, llvm::Constant* True,
+            llvm::Constant* False) const override {
+            return m_baseConstantFolder.CreateSelect(C, True, False);
+        }
+
+        inline llvm::Constant* CreateGetElementPtr(llvm::Type* Ty, llvm::Constant* C,
+            llvm::ArrayRef<llvm::Constant*> IdxList) const override {
+            return m_baseConstantFolder.CreateGetElementPtr(Ty, C, IdxList);
+        }
+
+        inline llvm::Constant* CreateGetElementPtr(llvm::Type* Ty, llvm::Constant* C,
+            llvm::Constant* Idx) const override {
+            return m_baseConstantFolder.CreateGetElementPtr(Ty, C, Idx);
+        }
+
+        inline llvm::Constant* CreateGetElementPtr(llvm::Type* Ty, llvm::Constant* C,
+            llvm::ArrayRef<llvm::Value*> IdxList) const override {
+            return m_baseConstantFolder.CreateGetElementPtr(Ty, C, IdxList);
+        }
+
+        inline llvm::Constant* CreateInBoundsGetElementPtr(llvm::Type* Ty, llvm::Constant* C,
+            llvm::ArrayRef<llvm::Constant*> IdxList) const override {
+            return m_baseConstantFolder.CreateInBoundsGetElementPtr(Ty, C, IdxList);
+        }
+
+        inline llvm::Constant* CreateInBoundsGetElementPtr(llvm::Type* Ty, llvm::Constant* C,
+            llvm::Constant* Idx) const override {
+            return m_baseConstantFolder.CreateInBoundsGetElementPtr(Ty, C, Idx);
+        }
+
+        inline llvm::Constant* CreateInBoundsGetElementPtr(llvm::Type* Ty, llvm::Constant* C,
+            llvm::ArrayRef<llvm::Value*> IdxList) const override {
+            return m_baseConstantFolder.CreateInBoundsGetElementPtr(Ty, C, IdxList);
+        }
+#else
+        inline llvm::Value* FoldAdd(llvm::Value* LHS, llvm::Value* RHS, bool HasNUW = false,
+            bool HasNSW = false) const override {
+            return m_baseConstantFolder.FoldAdd(LHS, RHS, HasNUW, HasNSW);
+        }
+
+        inline llvm::Value* FoldAnd(llvm::Value* LHS, llvm::Value* RHS) const override {
+            return m_baseConstantFolder.FoldAnd(LHS, RHS);
+        }
+
+        inline llvm::Value* FoldOr(llvm::Value* LHS, llvm::Value* RHS) const override {
+            return m_baseConstantFolder.FoldOr(LHS, RHS);
+        }
+
+        inline llvm::Value* FoldICmp(llvm::CmpInst::Predicate P, llvm::Value* LHS, llvm::Value* RHS) const override {
+            return m_baseConstantFolder.FoldICmp(P, LHS, RHS);
+        }
+
+        inline llvm::Value* FoldSelect(llvm::Value* C, llvm::Value* True, llvm::Value* False) const override {
+            return m_baseConstantFolder.FoldSelect(C, True, False);
+        }
+
+        inline llvm::Value* FoldGEP(llvm::Type* Ty, llvm::Value* Ptr, llvm::ArrayRef<llvm::Value*> IdxList,
+            bool IsInBounds = false) const override {
+            return m_baseConstantFolder.FoldGEP(Ty, Ptr, IdxList, IsInBounds);
+        }
+#endif
         inline llvm::Constant* CreateFAdd(llvm::Constant* LHS, llvm::Constant* RHS) const override {
             return m_baseConstantFolder.CreateFAdd(LHS, RHS);
         }
@@ -99,14 +173,6 @@ namespace IGCLLVM
             return m_baseConstantFolder.CreateAShr(LHS, RHS, isExact);
         }
 
-        inline llvm::Constant* CreateAnd(llvm::Constant* LHS, llvm::Constant* RHS) const override {
-            return m_baseConstantFolder.CreateAnd(LHS, RHS);
-        }
-
-        inline llvm::Constant* CreateOr(llvm::Constant* LHS, llvm::Constant* RHS) const override {
-            return m_baseConstantFolder.CreateOr(LHS, RHS);
-        }
-
         inline llvm::Constant* CreateXor(llvm::Constant* LHS, llvm::Constant* RHS) const override {
             return m_baseConstantFolder.CreateXor(LHS, RHS);
         }
@@ -133,36 +199,6 @@ namespace IGCLLVM
             return m_baseConstantFolder.CreateUnOp(Opc, C);
         }
 
-        inline llvm::Constant* CreateGetElementPtr(llvm::Type* Ty, llvm::Constant* C,
-            llvm::ArrayRef<llvm::Constant*> IdxList) const override {
-            return m_baseConstantFolder.CreateGetElementPtr(Ty, C, IdxList);
-        }
-
-        inline llvm::Constant* CreateGetElementPtr(llvm::Type* Ty, llvm::Constant* C,
-            llvm::Constant* Idx) const override {
-            return m_baseConstantFolder.CreateGetElementPtr(Ty, C, Idx);
-        }
-
-        inline llvm::Constant* CreateGetElementPtr(llvm::Type* Ty, llvm::Constant* C,
-            llvm::ArrayRef<llvm::Value*> IdxList) const override {
-            return m_baseConstantFolder.CreateGetElementPtr(Ty, C, IdxList);
-        }
-
-        inline llvm::Constant* CreateInBoundsGetElementPtr(llvm::Type* Ty, llvm::Constant* C,
-            llvm::ArrayRef<llvm::Constant*> IdxList) const override {
-            return m_baseConstantFolder.CreateInBoundsGetElementPtr(Ty, C, IdxList);
-        }
-
-        inline llvm::Constant* CreateInBoundsGetElementPtr(llvm::Type* Ty, llvm::Constant* C,
-            llvm::Constant* Idx) const override {
-            return m_baseConstantFolder.CreateInBoundsGetElementPtr(Ty, C, Idx);
-        }
-
-        inline llvm::Constant* CreateInBoundsGetElementPtr(llvm::Type* Ty, llvm::Constant* C,
-            llvm::ArrayRef<llvm::Value*> IdxList) const override {
-            return m_baseConstantFolder.CreateInBoundsGetElementPtr(Ty, C, IdxList);
-        }
-
         inline llvm::Constant* CreateCast(llvm::Instruction::CastOps Op, llvm::Constant* C,
             llvm::Type* DestTy) const override {
             return m_baseConstantFolder.CreateCast(Op, C, DestTy);
@@ -210,21 +246,11 @@ namespace IGCLLVM
             return m_baseConstantFolder.CreateTruncOrBitCast(C, DestTy);
         }
 
-        inline llvm::Constant* CreateICmp(llvm::CmpInst::Predicate P, llvm::Constant* LHS,
-            llvm::Constant* RHS) const override {
-            return m_baseConstantFolder.CreateICmp(P, LHS, RHS);
-        }
-
         inline llvm::Constant* CreateFCmp(llvm::CmpInst::Predicate P, llvm::Constant* LHS,
             llvm::Constant* RHS) const override {
             return m_baseConstantFolder.CreateFCmp(P, LHS, RHS);
         }
 
-        inline llvm::Constant* CreateSelect(llvm::Constant* C, llvm::Constant* True,
-            llvm::Constant* False) const override {
-            return m_baseConstantFolder.CreateSelect(C, True, False);
-        }
-
         inline llvm::Constant* CreateExtractElement(llvm::Constant* Vec, llvm::Constant* Idx) const override {
             return m_baseConstantFolder.CreateExtractElement(Vec, Idx);
         }
diff --git a/IGC/WrapperLLVM/include/llvmWrapper/IR/IRBuilder.h b/IGC/WrapperLLVM/include/llvmWrapper/IR/IRBuilder.h
index c9347c191..54eae7648 100644
--- a/IGC/WrapperLLVM/include/llvmWrapper/IR/IRBuilder.h
+++ b/IGC/WrapperLLVM/include/llvmWrapper/IR/IRBuilder.h
@@ -301,6 +301,14 @@ namespace IGCLLVM
 
 #endif
 
+#if LLVM_VERSION_MAJOR >= 14
+        Value* CreatePtrDiff(Value *LHS, Value *RHS, const Twine &Name = "") {
+          auto *PtrTy = cast<PointerType>(LHS->getType());
+          Type *Ty = PtrTy->getElementType();
+          return llvm::IRBuilder<T, InserterTyDef()>::CreatePtrDiff(Ty, LHS, RHS, Name);
+        }
+#endif
+
         inline llvm::Value* CreateConstInBoundsGEP2_64(
             llvm::Value* Ptr,
             uint64_t Idx0,
diff --git a/IGC/WrapperLLVM/include/llvmWrapper/IR/Instructions.h b/IGC/WrapperLLVM/include/llvmWrapper/IR/Instructions.h
index a0dda4a30..fa58622a3 100644
--- a/IGC/WrapperLLVM/include/llvmWrapper/IR/Instructions.h
+++ b/IGC/WrapperLLVM/include/llvmWrapper/IR/Instructions.h
@@ -80,6 +80,15 @@ namespace IGCLLVM
 #endif
     }
 
+    inline llvm::iterator_range<llvm::User::op_iterator> args(llvm::CallInst* CI)
+    {
+#if LLVM_VERSION_MAJOR < 8
+        return CI->arg_operands();
+#else
+        return CI->args();
+#endif
+    }
+
     inline unsigned getNumArgOperands(const llvm::CallInst* CI)
     {
 #if LLVM_VERSION_MAJOR < 14
diff --git a/IGC/common/debug/Debug.cpp b/IGC/common/debug/Debug.cpp
index 96804d32b..92551b95f 100644
--- a/IGC/common/debug/Debug.cpp
+++ b/IGC/common/debug/Debug.cpp
@@ -228,18 +228,30 @@ void Warning(
 }
 
 namespace {
+#if LLVM_VERSION_MAJOR >= 14
+    void FatalErrorHandler(void *user_data, const char* reason, bool gen_crash_diag)
+#else
     void FatalErrorHandler(void *user_data, const std::string& reason, bool gen_crash_diag)
+#endif
     {
         (void)user_data;
         (void)reason;
 #if defined( _DEBUG )
 #if defined( _WIN32 )
         OutputDebugStringA("LLVM Error: ");
+    #if LLVM_VERSION_MAJOR >= 14
+        OutputDebugStringA(reason);
+    #else
         OutputDebugStringA(reason.c_str());
+    #endif
         OutputDebugStringA("\n");
 #endif
         fprintf( stderr, "%s", "LLVM Error: " );
+    #if LLVM_VERSION_MAJOR >= 14
+        fprintf( stderr, "%s", reason);
+    #else
         fprintf( stderr, "%s", reason.c_str());
+    #endif
         fprintf( stderr, "%s", "\n");
         fflush( stderr );
 
-- 
2.36.0

