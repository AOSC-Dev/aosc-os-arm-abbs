#
#  Support for Nullish Coalescing for SeaMonkey 2.53.11
#
#  Manually backported from Mozilla's bugs:
#    1566141 part 1-3,5-8
#    1593415
#    1599163
#

diff -Nrup mozilla-OLD/js/src/builtin/ReflectParse.cpp mozilla/js/src/builtin/ReflectParse.cpp
--- mozilla-OLD/js/src/builtin/ReflectParse.cpp	2022-01-25 01:04:25.000000000 +0300
+++ mozilla/js/src/builtin/ReflectParse.cpp	2022-02-02 20:44:23.093723134 +0300
@@ -77,7 +77,7 @@ enum BinaryOperator {
     /* binary */
     BINOP_BITOR, BINOP_BITXOR, BINOP_BITAND,
     /* misc */
-    BINOP_IN, BINOP_INSTANCEOF, BINOP_PIPELINE,
+    BINOP_IN, BINOP_INSTANCEOF, BINOP_PIPELINE, BINOP_COALESCE,
 
     BINOP_LIMIT
 };
@@ -154,6 +154,7 @@ static const char* const binopNames[] =
     "in",         /* BINOP_IN */
     "instanceof", /* BINOP_INSTANCEOF */
     "|>",         /* BINOP_PIPELINE */
+    "??",         /* BINOP_COALESCE */
 };
 
 static const char* const unopNames[] = {
@@ -1956,6 +1957,8 @@ ASTSerializer::binop(ParseNodeKind kind)
         return BINOP_INSTANCEOF;
       case ParseNodeKind::Pipeline:
         return BINOP_PIPELINE;
+      case ParseNodeKind::Coalesce:
+        return BINOP_COALESCE;
       default:
         return BINOP_ERR;
     }
@@ -2830,6 +2833,7 @@ ASTSerializer::expression(ParseNode* pn,
                builder.conditionalExpression(test, cons, alt, &pn->pn_pos, dst);
       }
 
+      case ParseNodeKind::Coalesce:
       case ParseNodeKind::Or:
       case ParseNodeKind::And:
         return leftAssociate(pn, dst);
diff -Nrup mozilla-OLD/js/src/frontend/BytecodeEmitter.cpp mozilla/js/src/frontend/BytecodeEmitter.cpp
--- mozilla-OLD/js/src/frontend/BytecodeEmitter.cpp	2022-01-25 01:04:25.000000000 +0300
+++ mozilla/js/src/frontend/BytecodeEmitter.cpp	2022-02-02 20:44:23.096723113 +0300
@@ -45,6 +45,7 @@ using namespace js;
 using namespace js::gc;
 using namespace js::frontend;
 
+using mozilla::ArrayLength;
 using mozilla::AssertedCast;
 using mozilla::DebugOnly;
 using mozilla::Maybe;
@@ -3258,8 +3259,9 @@ BytecodeEmitter::checkSideEffects(ParseN
         return true;
 
       case ParseNodeKind::StatementList:
-      // Strict equality operations and logical operators are well-behaved and
-      // perform no conversions.
+      // Strict equality operations and short circuit operators are well-behaved
+      // and perform no conversions.
+      case ParseNodeKind::Coalesce:
       case ParseNodeKind::Or:
       case ParseNodeKind::And:
       case ParseNodeKind::StrictEq:
@@ -9723,10 +9725,15 @@ BytecodeEmitter::emitCallOrNew(ParseNode
     return true;
 }
 
+// This list must be kept in the same order in several places:
+//   - The binary operators in ParseNode.h ,
+//   - the binary operators in TokenKind.h
+//   - the precedence list in Parser.cpp
 static const JSOp ParseNodeKindToJSOp[] = {
     // JSOP_NOP is for pipeline operator which does not emit its own JSOp
     // but has highest precedence in binary operators
     JSOP_NOP,
+    JSOP_COALESCE,
     JSOP_OR,
     JSOP_AND,
     JSOP_BITOR,
@@ -9758,7 +9765,14 @@ BinaryOpParseNodeKindToJSOp(ParseNodeKin
 {
     MOZ_ASSERT(pnk >= ParseNodeKind::BinOpFirst);
     MOZ_ASSERT(pnk <= ParseNodeKind::BinOpLast);
-    return ParseNodeKindToJSOp[size_t(pnk) - size_t(ParseNodeKind::BinOpFirst)];
+    int parseNodeFirst = size_t(ParseNodeKind::BinOpFirst);
+#ifdef DEBUG
+    int jsopArraySize = ArrayLength(ParseNodeKindToJSOp);
+    int parseNodeKindListSize =
+        size_t(ParseNodeKind::BinOpLast) - parseNodeFirst + 1;
+    MOZ_ASSERT(jsopArraySize == parseNodeKindListSize);
+#endif
+    return ParseNodeKindToJSOp[size_t(pnk) - parseNodeFirst];
 }
 
 bool
@@ -9799,11 +9813,12 @@ BytecodeEmitter::emitLeftAssociative(Par
     return true;
 }
 
+
 bool
-BytecodeEmitter::emitLogical(ParseNode* pn)
+BytecodeEmitter::emitShortCircuit(ParseNode* pn)
 {
     MOZ_ASSERT(pn->isArity(PN_LIST));
-    MOZ_ASSERT(pn->isKind(ParseNodeKind::Or) || pn->isKind(ParseNodeKind::And));
+    MOZ_ASSERT(pn->isKind(ParseNodeKind::Or) || pn->isKind(ParseNodeKind::Coalesce) || pn->isKind(ParseNodeKind::And));
 
     /*
      * JSOP_OR converts the operand on the stack to boolean, leaves the original
@@ -9819,9 +9834,25 @@ BytecodeEmitter::emitLogical(ParseNode*
 
     /* Left-associative operator chain: avoid too much recursion. */
     ParseNode* pn2 = pn->pn_head;
+
     if (!emitTree(pn2))
         return false;
-    JSOp op = pn->isKind(ParseNodeKind::Or) ? JSOP_OR : JSOP_AND;
+
+    JSOp op;
+    switch (pn->getKind()) {
+      case ParseNodeKind::Or:
+        op = JSOP_OR;
+        break;
+      case ParseNodeKind::Coalesce:
+        op = JSOP_COALESCE;
+        break;
+      case ParseNodeKind::And:
+        op = JSOP_AND;
+        break;
+      default:
+        MOZ_CRASH("Unexpected ParseNodeKind");
+    }
+
     JumpList jump;
     if (!emitJump(op, &jump))
         return false;
@@ -11108,8 +11139,9 @@ BytecodeEmitter::emitTree(ParseNode* pn,
         break;
 
       case ParseNodeKind::Or:
+      case ParseNodeKind::Coalesce:
       case ParseNodeKind::And:
-        if (!emitLogical(pn))
+        if (!emitShortCircuit(pn))
             return false;
         break;
 
diff -Nrup mozilla-OLD/js/src/frontend/BytecodeEmitter.h mozilla/js/src/frontend/BytecodeEmitter.h
--- mozilla-OLD/js/src/frontend/BytecodeEmitter.h	2022-01-25 01:04:25.000000000 +0300
+++ mozilla/js/src/frontend/BytecodeEmitter.h	2022-02-02 20:44:23.096723113 +0300
@@ -804,7 +804,7 @@ struct MOZ_STACK_CLASS BytecodeEmitter
     MOZ_MUST_USE bool emitUnary(ParseNode* pn);
     MOZ_MUST_USE bool emitRightAssociative(ParseNode* pn);
     MOZ_MUST_USE bool emitLeftAssociative(ParseNode* pn);
-    MOZ_MUST_USE bool emitLogical(ParseNode* pn);
+    MOZ_MUST_USE bool emitShortCircuit(ParseNode* pn);
     MOZ_MUST_USE bool emitSequenceExpr(ParseNode* pn,
                                        ValueUsage valueUsage = ValueUsage::WantValue);
 
diff -Nrup mozilla-OLD/js/src/frontend/FoldConstants.cpp mozilla/js/src/frontend/FoldConstants.cpp
--- mozilla-OLD/js/src/frontend/FoldConstants.cpp	2022-01-25 01:04:25.000000000 +0300
+++ mozilla/js/src/frontend/FoldConstants.cpp	2022-02-02 20:48:51.185839051 +0300
@@ -322,6 +322,7 @@ ContainsHoistedDeclaration(JSContext* cx
       case ParseNodeKind::PostIncrement:
       case ParseNodeKind::PreDecrement:
       case ParseNodeKind::PostDecrement:
+      case ParseNodeKind::Coalesce:
       case ParseNodeKind::Or:
       case ParseNodeKind::And:
       case ParseNodeKind::BitOr:
@@ -746,15 +747,17 @@ FoldIncrementDecrement(JSContext* cx, Pa
 }
 
 static bool
-FoldAndOr(JSContext* cx, ParseNode** nodePtr, Parser<FullParseHandler, char16_t>& parser,
+FoldAndOrCoalesce(JSContext* cx, ParseNode** nodePtr, Parser<FullParseHandler, char16_t>& parser,
           bool inGenexpLambda)
 {
     ParseNode* node = *nodePtr;
 
-    MOZ_ASSERT(node->isKind(ParseNodeKind::And) || node->isKind(ParseNodeKind::Or));
+    MOZ_ASSERT(node->isKind(ParseNodeKind::And) || node->isKind(ParseNodeKind::Coalesce) || node->isKind(ParseNodeKind::Or));
     MOZ_ASSERT(node->isArity(PN_LIST));
 
     bool isOrNode = node->isKind(ParseNodeKind::Or);
+    bool isAndNode = node->isKind(ParseNodeKind::And);
+    bool isCoalesceNode = node->isKind(ParseNodeKind::Coalesce);
     ParseNode** elem = &node->pn_head;
     do {
         if (!Fold(cx, elem, parser, inGenexpLambda))
@@ -770,11 +773,19 @@ FoldAndOr(JSContext* cx, ParseNode** nod
             continue;
         }
 
+        bool isTruthyCoalesceNode =
+            isCoalesceNode && !((*elem)->isKind(ParseNodeKind::Null) ||
+                                (*elem)->isKind(ParseNodeKind::Void) ||
+                                (*elem)->isKind(ParseNodeKind::RawUndefined));
+        bool canShortCircuit = (isOrNode && t == Truthy) ||
+                               (isAndNode && t == Falsy) || isTruthyCoalesceNode;
+
         // If the constant-folded node's truthiness will terminate the
-        // condition -- `a || true || expr` or |b && false && expr| -- then
-        // trailing nodes will never be evaluated.  Truncate the list after
-        // the known-truthiness node, as it's the overall result.
-        if ((t == Truthy) == isOrNode) {
+        // condition -- `a || true || expr` or `b && false && expr` or
+        // `false ?? c ?? expr` -- then trailing nodes will never be
+        // evaluated.  Truncate the list after the known-truthiness node,
+        // as it's the overall result.
+        if (canShortCircuit) {
             for (ParseNode* next = (*elem)->pn_next; next; next = next->pn_next)
                 --node->pn_count;
 
@@ -785,8 +796,6 @@ FoldAndOr(JSContext* cx, ParseNode** nod
             break;
         }
 
-        MOZ_ASSERT((t == Truthy) == !isOrNode);
-
         // We've encountered a vacuous node that'll never short-circuit
         // evaluation.
         if ((*elem)->pn_next) {
@@ -1668,7 +1677,8 @@ Fold(JSContext* cx, ParseNode** pnp, Par
 
       case ParseNodeKind::And:
       case ParseNodeKind::Or:
-        return FoldAndOr(cx, pnp, parser, inGenexpLambda);
+      case ParseNodeKind::Coalesce:
+        return FoldAndOrCoalesce(cx, pnp, parser, inGenexpLambda);
 
       case ParseNodeKind::Function:
         return FoldFunction(cx, pn, parser, inGenexpLambda);
diff -Nrup mozilla-OLD/js/src/frontend/NameFunctions.cpp mozilla/js/src/frontend/NameFunctions.cpp
--- mozilla-OLD/js/src/frontend/NameFunctions.cpp	2022-01-25 01:04:25.000000000 +0300
+++ mozilla/js/src/frontend/NameFunctions.cpp	2022-02-02 20:44:23.098723099 +0300
@@ -675,6 +675,7 @@ class NameResolver
 
           // Nodes with arbitrary-expression children.
           case ParseNodeKind::Or:
+          case ParseNodeKind::Coalesce:
           case ParseNodeKind::And:
           case ParseNodeKind::BitOr:
           case ParseNodeKind::BitXor:
diff -Nrup mozilla-OLD/js/src/frontend/ParseNode.h mozilla/js/src/frontend/ParseNode.h
--- mozilla-OLD/js/src/frontend/ParseNode.h	2022-01-25 01:04:25.000000000 +0300
+++ mozilla/js/src/frontend/ParseNode.h	2022-02-02 20:44:23.099723092 +0300
@@ -126,9 +126,14 @@ class ObjectBox;
     \
     /* \
      * Binary operators. \
-     * These must be in the same order as TOK_OR and friends in TokenStream.h. \
+     * This list must be kept in the same order in several places: \
+     *   - The binary operators in ParseNode.h \
+     *   - the binary operators in TokenKind.h \
+     *   - the precedence list in Parser.cpp \
+     *   - the JSOp code list in BytecodeEmitter.cpp \
      */ \
     F(Pipeline) \
+    F(Coalesce) \
     F(Or) \
     F(And) \
     F(BitOr) \
@@ -328,6 +333,7 @@ IsTypeofKind(ParseNodeKind kind)
  *                          pn_kid1: cond, pn_kid2: then, pn_kid3: else
  * Or,      list        pn_head; list of pn_count subexpressions
  * And,                 All of these operators are left-associative except (**).
+ * Coalesce,
  * BitOr,
  * BitXor,
  * BitAnd,
diff -Nrup mozilla-OLD/js/src/frontend/Parser.cpp mozilla/js/src/frontend/Parser.cpp
--- mozilla-OLD/js/src/frontend/Parser.cpp	2022-02-02 18:46:49.471446790 +0300
+++ mozilla/js/src/frontend/Parser.cpp	2022-02-02 20:53:26.957910039 +0300
@@ -7930,35 +7930,40 @@ BinaryOpTokenKindToParseNodeKind(TokenKi
     return ParseNodeKind(size_t(ParseNodeKind::BinOpFirst) + (size_t(tok) - size_t(TokenKind::BinOpFirst)));
 }
 
+// This list must be kept in the same order in several places:
+//   - The binary operators in ParseNode.h ,
+//   - the binary operators in TokenKind.h
+//   - the JSOp code list in BytecodeEmitter.cpp
 static const int PrecedenceTable[] = {
     1, /* ParseNodeKind::Pipeline */
-    2, /* ParseNodeKind::Or */
-    3, /* ParseNodeKind::And */
-    4, /* ParseNodeKind::BitOr */
-    5, /* ParseNodeKind::BitXor */
-    6, /* ParseNodeKind::BitAnd */
-    7, /* ParseNodeKind::StrictEq */
-    7, /* ParseNodeKind::Eq */
-    7, /* ParseNodeKind::StrictNe */
-    7, /* ParseNodeKind::Ne */
-    8, /* ParseNodeKind::Lt */
-    8, /* ParseNodeKind::Le */
-    8, /* ParseNodeKind::Gt */
-    8, /* ParseNodeKind::Ge */
-    8, /* ParseNodeKind::InstanceOf */
-    8, /* ParseNodeKind::In */
-    9, /* ParseNodeKind::Lsh */
-    9, /* ParseNodeKind::Rsh */
-    9, /* ParseNodeKind::Ursh */
-    10, /* ParseNodeKind::Add */
-    10, /* ParseNodeKind::Sub */
-    11, /* ParseNodeKind::Star */
-    11, /* ParseNodeKind::Div */
-    11, /* ParseNodeKind::Mod */
-    12  /* ParseNodeKind::Pow */
+    2, /* ParseNodeKind::Coalesce */
+    3, /* ParseNodeKind::Or */
+    4, /* ParseNodeKind::And */
+    5, /* ParseNodeKind::BitOr */
+    6, /* ParseNodeKind::BitXor */
+    7, /* ParseNodeKind::BitAnd */
+    8, /* ParseNodeKind::StrictEq */
+    8, /* ParseNodeKind::Eq */
+    8, /* ParseNodeKind::StrictNe */
+    8, /* ParseNodeKind::Ne */
+    9, /* ParseNodeKind::Lt */
+    9, /* ParseNodeKind::Le */
+    9, /* ParseNodeKind::Gt */
+    9, /* ParseNodeKind::Ge */
+    9, /* ParseNodeKind::InstanceOf */
+    9, /* ParseNodeKind::In */
+    10, /* ParseNodeKind::Lsh */
+    10, /* ParseNodeKind::Rsh */
+    10, /* ParseNodeKind::Ursh */
+    11, /* ParseNodeKind::Add */
+    11, /* ParseNodeKind::Sub */
+    12, /* ParseNodeKind::Star */
+    12, /* ParseNodeKind::Div */
+    12, /* ParseNodeKind::Mod */
+    13  /* ParseNodeKind::Pow */
 };
 
-static const int PRECEDENCE_CLASSES = 12;
+static const int PRECEDENCE_CLASSES = 13;
 
 static int
 Precedence(ParseNodeKind pnk) {
@@ -7973,6 +7978,8 @@ Precedence(ParseNodeKind pnk) {
     return PrecedenceTable[size_t(pnk) - size_t(ParseNodeKind::BinOpFirst)];
 }
 
+enum class EnforcedParentheses : uint8_t { CoalesceExpr, AndOrExpr, None };
+
 template <class ParseHandler, typename CharT>
 MOZ_ALWAYS_INLINE typename ParseHandler::Node
 Parser<ParseHandler, CharT>::orExpr(InHandling inHandling, YieldHandling yieldHandling,
@@ -7989,6 +7996,7 @@ Parser<ParseHandler, CharT>::orExpr(InHa
     ParseNodeKind kindStack[PRECEDENCE_CLASSES];
     int depth = 0;
     Node pn;
+    EnforcedParentheses unparenthesizedExpression = EnforcedParentheses::None;
     for (;;) {
         pn = unaryExpr(yieldHandling, tripledotHandling, possibleError, invoked);
         if (!pn)
@@ -8006,11 +8014,44 @@ Parser<ParseHandler, CharT>::orExpr(InHa
             // pending expression error now.
             if (possibleError && !possibleError->checkForExpressionError())
                 return null();
-            // Report an error for unary expressions on the LHS of **.
-            if (tok == TokenKind::Pow && handler.isUnparenthesizedUnaryExpression(pn)) {
-                error(JSMSG_BAD_POW_LEFTSIDE);
-                return null();
+
+            switch (tok) {
+              // Report an error for unary expressions on the LHS of **.
+              case TokenKind::Pow:
+                if (handler.isUnparenthesizedUnaryExpression(pn)) {
+                  error(JSMSG_BAD_POW_LEFTSIDE);
+                  return null();
+                }
+                break;
+
+              case TokenKind::Or:
+              case TokenKind::And:
+                // In the case that the `??` is on the left hand side of the
+                // expression: Disallow Mixing of ?? and other logical operators (||
+                // and &&) unless one expression is parenthesized
+                if (unparenthesizedExpression == EnforcedParentheses::CoalesceExpr) {
+                  error(JSMSG_BAD_COALESCE_MIXING);
+                  return null();
+                }
+                // If we have not detected a mixing error at this point, record that
+                // we have an unparenthesized expression, in case we have one later.
+                unparenthesizedExpression = EnforcedParentheses::AndOrExpr;
+                break;
+              case TokenKind::Coalesce:
+                if (unparenthesizedExpression == EnforcedParentheses::AndOrExpr) {
+                  error(JSMSG_BAD_COALESCE_MIXING);
+                  return null();
+                }
+                // If we have not detected a mixing error at this point, record that
+                // we have an unparenthesized expression, in case we have one later.
+                unparenthesizedExpression = EnforcedParentheses::CoalesceExpr;
+                break;
+
+              default:
+                // do nothing in other cases
+                break;
             }
+
             pnk = BinaryOpTokenKindToParseNodeKind(tok);
         } else {
             tok = TokenKind::Eof;
diff -Nrup mozilla-OLD/js/src/frontend/TokenKind.h mozilla/js/src/frontend/TokenKind.h
--- mozilla-OLD/js/src/frontend/TokenKind.h	2022-01-25 01:04:25.000000000 +0300
+++ mozilla/js/src/frontend/TokenKind.h	2022-02-02 20:55:11.171179544 +0300
@@ -152,11 +152,15 @@
      * range-testing. \
      */ \
     /* \
-     * Binary operators tokens, Or thru Pow. These must be in the same \
-     * order as F(OR) and friends in FOR_EACH_PARSE_NODE_KIND in ParseNode.h. \
+     * Binary operators. \
+     * This list must be kept in the same order in several places: \
+     *   - the binary operators in ParseNode.h \
+     *   - the precedence list in Parser.cpp \
+     *   - the JSOp code list in BytecodeEmitter.cpp \
      */ \
     macro(Pipeline,     "'|>'") \
     range(BinOpFirst,   Pipeline) \
+    macro(Coalesce,     "'\?\?'") /* escapes to avoid trigraphs warning */ \
     macro(Or,           "'||'")   /* logical or */ \
     macro(And,          "'&&'")   /* logical and */ \
     macro(BitOr,        "'|'")    /* bitwise-or */ \
diff -Nrup mozilla-OLD/js/src/frontend/TokenStream.cpp mozilla/js/src/frontend/TokenStream.cpp
--- mozilla-OLD/js/src/frontend/TokenStream.cpp	2022-02-02 18:46:49.472446783 +0300
+++ mozilla/js/src/frontend/TokenStream.cpp	2022-02-02 20:57:45.943094710 +0300
@@ -1380,8 +1380,8 @@ enum FirstCharKind {
     LastCharKind = Other
 };
 
-// OneChar: 40,  41,  44,  58,  59,  63,  91,  93,  123, 125, 126:
-//          '(', ')', ',', ':', ';', '?', '[', ']', '{', '}', '~'
+// OneChar: 40,  41,  44,  58,  59,  91,  93,  123, 125, 126:
+//          '(', ')', ',', ':', ';', '[', ']', '{', '}', '~'
 // Ident:   36, 65..90, 95, 97..122: '$', 'A'..'Z', '_', 'a'..'z'
 // Dot:     46: '.'
 // Equals:  61: '='
@@ -1413,7 +1413,7 @@ static const uint8_t firstCharKinds[] =
 /*  30+ */ _______, _______,   Space, _______,  String, _______,   Ident, _______, _______,  String,
 /*  40+ */    T_LP,    T_RP, _______, _______, T_COMMA,_______,  _______, _______,BasePrefix,  Dec,
 /*  50+ */     Dec,     Dec,     Dec,     Dec,     Dec,     Dec,     Dec,    Dec,  T_COLON,  T_SEMI,
-/*  60+ */ _______, _______, _______,  T_HOOK, _______,   Ident,   Ident,   Ident,   Ident,   Ident,
+/*  60+ */ _______, _______, _______, _______, _______,   Ident,   Ident,   Ident,   Ident,   Ident,
 /*  70+ */   Ident,   Ident,   Ident,   Ident,   Ident,   Ident,   Ident,   Ident,   Ident,   Ident,
 /*  80+ */   Ident,   Ident,   Ident,   Ident,   Ident,   Ident,   Ident,   Ident,   Ident,   Ident,
 /*  90+ */   Ident,    T_LB, _______,    T_RB, _______,   Ident, Templat,   Ident,   Ident,   Ident,
@@ -1867,6 +1867,10 @@ TokenStreamSpecific<CharT, AnyCharsAcces
             tp->type = matchChar('=') ? TokenKind::BitAndAssign : TokenKind::BitAnd;
         goto out;
 
+      case '?':
+        tp->type = matchChar('?') ? TokenKind::Coalesce : TokenKind::Hook;
+        goto out;
+
       case '!':
         if (matchChar('='))
             tp->type = matchChar('=') ? TokenKind::StrictNe : TokenKind::Ne;
diff -Nrup mozilla-OLD/js/src/jit/BaselineCompiler.cpp mozilla/js/src/jit/BaselineCompiler.cpp
--- mozilla-OLD/js/src/jit/BaselineCompiler.cpp	2021-10-26 19:49:54.000000000 +0300
+++ mozilla/js/src/jit/BaselineCompiler.cpp	2022-02-02 20:44:23.105723050 +0300
@@ -1302,6 +1302,26 @@ BaselineCompiler::emit_JSOP_OR()
 }
 
 bool
+BaselineCompiler::emit_JSOP_COALESCE() {
+    // COALESCE leaves the original value on the stack.
+    frame.syncStack(0);
+  
+    masm.loadValue(frame.addressOfStackValue(frame.peek(-1)), R0);
+  
+    Label undefinedOrNull;
+  
+    masm.branchTestUndefined(Assembler::Equal, R0, &undefinedOrNull);
+    masm.branchTestNull(Assembler::Equal, R0, &undefinedOrNull);
+
+    jsbytecode* target = pc + GET_JUMP_OFFSET(pc);
+    masm.jump(labelOf(target));
+  
+    masm.bind(&undefinedOrNull);
+    // fall through
+    return true;
+}
+
+bool
 BaselineCompiler::emit_JSOP_NOT()
 {
     bool knownBoolean = frame.peek(-1)->isKnownBoolean();
diff -Nrup mozilla-OLD/js/src/jit/BaselineCompiler.h mozilla/js/src/jit/BaselineCompiler.h
--- mozilla-OLD/js/src/jit/BaselineCompiler.h	2021-10-26 19:49:54.000000000 +0300
+++ mozilla/js/src/jit/BaselineCompiler.h	2022-02-02 20:44:23.105723050 +0300
@@ -257,7 +257,8 @@ namespace jit {
     _(JSOP_OBJWITHPROTO)       \
     _(JSOP_FUNWITHPROTO)       \
     _(JSOP_CLASSCONSTRUCTOR)   \
-    _(JSOP_DERIVEDCONSTRUCTOR)
+    _(JSOP_DERIVEDCONSTRUCTOR) \
+    _(JSOP_COALESCE)
 
 class BaselineCompiler : public BaselineCompilerSpecific
 {
@@ -355,6 +356,8 @@ class BaselineCompiler : public Baseline
     MOZ_MUST_USE bool emitToBoolean();
     MOZ_MUST_USE bool emitTest(bool branchIfTrue);
     MOZ_MUST_USE bool emitAndOr(bool branchIfTrue);
+    MOZ_MUST_USE bool emitCoalesce();
+
     MOZ_MUST_USE bool emitCall();
     MOZ_MUST_USE bool emitSpreadCall();
 
diff -Nrup mozilla-OLD/js/src/jit/CodeGenerator.cpp mozilla/js/src/jit/CodeGenerator.cpp
--- mozilla-OLD/js/src/jit/CodeGenerator.cpp	2022-02-02 18:46:49.483446707 +0300
+++ mozilla/js/src/jit/CodeGenerator.cpp	2022-02-02 20:44:23.108723029 +0300
@@ -12120,6 +12120,24 @@ CodeGenerator::visitIsObjectAndBranch(LI
 }
 
 void
+CodeGenerator::visitIsNullOrUndefined(LIsNullOrUndefined* ins)
+{
+    Register output = ToRegister(ins->output());
+    ValueOperand value = ToValue(ins, LIsNullOrUndefined::Input);
+  
+    Label isNotNull, done;
+    masm.branchTestNull(Assembler::NotEqual, value, &isNotNull);
+  
+    masm.move32(Imm32(1), output);
+    masm.jump(&done);
+  
+    masm.bind(&isNotNull);
+    masm.testUndefinedSet(Assembler::Equal, value, output);
+  
+    masm.bind(&done);
+}
+
+void
 CodeGenerator::loadOutermostJSScript(Register reg)
 {
     // The "outermost" JSScript means the script that we are compiling
diff -Nrup mozilla-OLD/js/src/jit/CodeGenerator.h mozilla/js/src/jit/CodeGenerator.h
--- mozilla-OLD/js/src/jit/CodeGenerator.h	2022-01-25 01:04:29.000000000 +0300
+++ mozilla/js/src/jit/CodeGenerator.h	2022-02-02 20:44:23.108723029 +0300
@@ -391,6 +391,7 @@ class CodeGenerator final : public CodeG
     void visitIsTypedArray(LIsTypedArray* lir);
     void visitIsObject(LIsObject* lir);
     void visitIsObjectAndBranch(LIsObjectAndBranch* lir);
+    void visitIsNullOrUndefined(LIsNullOrUndefined* ins);
     void visitHasClass(LHasClass* lir);
     void visitObjectClassToString(LObjectClassToString* lir);
     void visitWasmParameter(LWasmParameter* lir);
diff -Nrup mozilla-OLD/js/src/jit/IonBuilder.cpp mozilla/js/src/jit/IonBuilder.cpp
--- mozilla-OLD/js/src/jit/IonBuilder.cpp	2021-10-26 19:49:54.000000000 +0300
+++ mozilla/js/src/jit/IonBuilder.cpp	2022-02-02 20:44:23.111723007 +0300
@@ -1806,6 +1806,7 @@ IonBuilder::inspectOpcode(JSOp op)
       case JSOP_RETRVAL:
       case JSOP_AND:
       case JSOP_OR:
+      case JSOP_COALESCE:
       case JSOP_TRY:
       case JSOP_THROW:
       case JSOP_GOTO:
@@ -2955,7 +2956,9 @@ IonBuilder::jsop_dup2()
 AbortReasonOr<Ok>
 IonBuilder::visitTest(CFGTest* test)
 {
-    MDefinition* ins = test->mustKeepCondition() ? current->peek(-1) : current->pop();
+    CFGTestKind kind = test->getKind();
+    MDefinition* ins =
+        kind != CFGTestKind::ToBooleanAndPop ? current->peek(-1) : current->pop();
 
     // Create true and false branches.
     MBasicBlock* ifTrue;
@@ -2963,7 +2966,15 @@ IonBuilder::visitTest(CFGTest* test)
     MBasicBlock* ifFalse;
     MOZ_TRY_VAR(ifFalse, newBlock(current, test->falseBranch()->startPc()));
 
-    MTest* mir = newTest(ins, ifTrue, ifFalse);
+    MTest* mir;
+    if (kind == CFGTestKind::Coalesce) {
+        MIsNullOrUndefined* isNullOrUndefined =
+            MIsNullOrUndefined::New(alloc(), ins);
+        current->add(isNullOrUndefined);
+        mir = newTest(isNullOrUndefined, ifFalse, ifTrue);
+    } else {
+        mir = newTest(ins, ifTrue, ifFalse);
+    }
     current->end(mir);
 
     // Filter the types in the true branch.
diff -Nrup mozilla-OLD/js/src/jit/IonControlFlow.cpp mozilla/js/src/jit/IonControlFlow.cpp
--- mozilla-OLD/js/src/jit/IonControlFlow.cpp	2021-10-26 19:49:54.000000000 +0300
+++ mozilla/js/src/jit/IonControlFlow.cpp	2022-02-02 20:44:23.112723000 +0300
@@ -317,9 +317,10 @@ ControlFlowGenerator::snoopControlFlow(J
       case JSOP_IFEQ:
         return processIfStart(JSOP_IFEQ);
 
+      case JSOP_COALESCE:
       case JSOP_AND:
       case JSOP_OR:
-        return processAndOr(op);
+        return processShortCircuit(op);
 
       case JSOP_LABEL:
         return processLabel();
@@ -469,8 +470,8 @@ ControlFlowGenerator::processCfgEntry(CF
       case CFGState::COND_SWITCH_BODY:
         return processCondSwitchBody(state);
 
-      case CFGState::AND_OR:
-        return processAndOrEnd(state);
+      case CFGState::SHORT_CIRCUIT:
+        return processShortCircuitEnd(state);
 
       case CFGState::LABEL:
         return processLabelEnd(state);
@@ -1362,7 +1363,7 @@ ControlFlowGenerator::processCondSwitchB
 }
 
 ControlFlowGenerator::ControlStatus
-ControlFlowGenerator::processAndOrEnd(CFGState& state)
+ControlFlowGenerator::processShortCircuitEnd(CFGState& state)
 {
     MOZ_ASSERT(current);
     CFGBlock* lhs = state.branch.ifFalse;
@@ -2044,10 +2045,10 @@ ControlFlowGenerator::CFGState::IfElse(j
 }
 
 ControlFlowGenerator::CFGState
-ControlFlowGenerator::CFGState::AndOr(jsbytecode* join, CFGBlock* lhs)
+ControlFlowGenerator::CFGState::ShortCircuit(jsbytecode* join, CFGBlock* lhs)
 {
     CFGState state;
-    state.state = AND_OR;
+    state.state = SHORT_CIRCUIT;
     state.stopAt = join;
     state.branch.ifFalse = lhs;
     state.branch.test = nullptr;
@@ -2103,9 +2104,9 @@ ControlFlowGenerator::CFGState::Try(jsby
 }
 
 ControlFlowGenerator::ControlStatus
-ControlFlowGenerator::processAndOr(JSOp op)
+ControlFlowGenerator::processShortCircuit(JSOp op)
 {
-    MOZ_ASSERT(op == JSOP_AND || op == JSOP_OR);
+    MOZ_ASSERT(op == JSOP_AND || op == JSOP_OR || op == JSOP_COALESCE);
 
     jsbytecode* rhsStart = pc + CodeSpec[op].length;
     jsbytecode* joinStart = pc + GetJumpOffset(pc);
@@ -2114,15 +2115,26 @@ ControlFlowGenerator::processAndOr(JSOp
     CFGBlock* evalLhs = CFGBlock::New(alloc(), joinStart);
     CFGBlock* evalRhs = CFGBlock::New(alloc(), rhsStart);
 
-    CFGTest* test = (op == JSOP_AND)
-                  ? CFGTest::New(alloc(), evalRhs, evalLhs)
-                  : CFGTest::New(alloc(), evalLhs, evalRhs);
-    test->keepCondition();
+    CFGTest* test;
+    switch (op) {
+      case JSOP_AND:
+          test = CFGTest::New(alloc(), evalRhs, evalLhs, CFGTestKind::ToBoolean);
+          break;
+      case JSOP_OR:
+          test = CFGTest::New(alloc(), evalLhs, evalRhs, CFGTestKind::ToBoolean);
+          break;
+      case JSOP_COALESCE:
+          test = CFGTest::New(alloc(), evalLhs, evalRhs, CFGTestKind::Coalesce);
+          break;
+      default:
+          MOZ_CRASH("Unexpected op code");
+    }
+
     current->setStopIns(test);
     current->setStopPc(pc);
 
     // Create the rhs block.
-    if (!cfgStack_.append(CFGState::AndOr(joinStart, evalLhs)))
+    if (!cfgStack_.append(CFGState::ShortCircuit(joinStart, evalLhs)))
         return ControlStatus::Error;
 
     if (!addBlock(evalLhs))
diff -Nrup mozilla-OLD/js/src/jit/IonControlFlow.h mozilla/js/src/jit/IonControlFlow.h
--- mozilla-OLD/js/src/jit/IonControlFlow.h	2021-10-26 19:49:54.000000000 +0300
+++ mozilla/js/src/jit/IonControlFlow.h	2022-02-02 20:44:23.112723000 +0300
@@ -376,6 +376,7 @@ class CFGCompare : public CFGAryControlI
     }
 };
 
+enum class CFGTestKind { Coalesce, ToBoolean, ToBooleanAndPop };
 /**
  * CFGTest
  *
@@ -386,18 +387,16 @@ class CFGCompare : public CFGAryControlI
  */
 class CFGTest : public CFGAryControlInstruction<2>
 {
-    // By default the condition gets popped. This variable
-    // keeps track if we want to keep the condition.
-    bool keepCondition_;
+    CFGTestKind kind_;
 
     CFGTest(CFGBlock* succ1, CFGBlock* succ2)
-      : keepCondition_(false)
+      : kind_(CFGTestKind::ToBooleanAndPop)
     {
         replaceSuccessor(0, succ1);
         replaceSuccessor(1, succ2);
     }
-    CFGTest(CFGBlock* succ1, CFGBlock* succ2, bool keepCondition)
-      : keepCondition_(keepCondition)
+    CFGTest(CFGBlock* succ1, CFGBlock* succ2, CFGTestKind kind)
+      : kind_(kind)
     {
         replaceSuccessor(0, succ1);
         replaceSuccessor(1, succ2);
@@ -410,7 +409,7 @@ class CFGTest : public CFGAryControlInst
     static CFGTest* CopyWithNewTargets(TempAllocator& alloc, CFGTest* old,
                                        CFGBlock* succ1, CFGBlock* succ2)
     {
-        return new(alloc) CFGTest(succ1, succ2, old->mustKeepCondition());
+        return new(alloc) CFGTest(succ1, succ2, old->getKind());
     }
 
     CFGBlock* trueBranch() const {
@@ -419,11 +418,8 @@ class CFGTest : public CFGAryControlInst
     CFGBlock* falseBranch() const {
         return getSuccessor(1);
     }
-    void keepCondition() {
-        keepCondition_ = true;
-    }
-    bool mustKeepCondition() const {
-        return keepCondition_;
+    CFGTestKind getKind() const {
+        return kind_;
     }
 };
 
@@ -717,7 +713,7 @@ class ControlFlowGenerator
             TABLE_SWITCH,       // switch() { x }
             COND_SWITCH_CASE,   // switch() { case X: ... }
             COND_SWITCH_BODY,   // switch() { case ...: X }
-            AND_OR,             // && x, || x
+            SHORT_CIRCUIT,      // && x, || x, ?? x
             LABEL,              // label: x
             TRY                 // try { x } catch(e) { }
         };
@@ -804,7 +800,7 @@ class ControlFlowGenerator
 
         static CFGState If(jsbytecode* join, CFGTest* test);
         static CFGState IfElse(jsbytecode* trueEnd, jsbytecode* falseEnd, CFGTest* test);
-        static CFGState AndOr(jsbytecode* join, CFGBlock* lhs);
+        static CFGState ShortCircuit(jsbytecode* join, CFGBlock* lhs);
         static CFGState TableSwitch(TempAllocator& alloc, jsbytecode* exitpc);
         static CFGState CondSwitch(TempAllocator& alloc, jsbytecode* exitpc,
                                    jsbytecode* defaultTarget);
@@ -875,8 +871,8 @@ class ControlFlowGenerator
     ControlStatus snoopControlFlow(JSOp op);
     ControlStatus processBrokenLoop(CFGState& state);
     ControlStatus finishLoop(CFGState& state, CFGBlock* successor);
-    ControlStatus processAndOr(JSOp op);
-    ControlStatus processAndOrEnd(CFGState& state);
+    ControlStatus processShortCircuit(JSOp op);
+    ControlStatus processShortCircuitEnd(CFGState& state);
     ControlStatus processLabel();
     ControlStatus processLabelEnd(CFGState& state);
 
diff -Nrup mozilla-OLD/js/src/jit/Lowering.cpp mozilla/js/src/jit/Lowering.cpp
--- mozilla-OLD/js/src/jit/Lowering.cpp	2021-03-01 21:17:56.000000000 +0300
+++ mozilla/js/src/jit/Lowering.cpp	2022-02-02 20:44:23.114722986 +0300
@@ -4379,6 +4379,16 @@ LIRGenerator::visitIsObject(MIsObject* i
 }
 
 void
+LIRGenerator::visitIsNullOrUndefined(MIsNullOrUndefined* ins)
+{
+    MDefinition* opd = ins->input();
+    MOZ_ASSERT(opd->type() == MIRType::Value);
+    LIsNullOrUndefined* lir =
+        new (alloc()) LIsNullOrUndefined(useBoxAtStart(opd));
+    define(lir, ins);
+}
+
+void
 LIRGenerator::visitHasClass(MHasClass* ins)
 {
     MOZ_ASSERT(ins->object()->type() == MIRType::Object);
diff -Nrup mozilla-OLD/js/src/jit/Lowering.h mozilla/js/src/jit/Lowering.h
--- mozilla-OLD/js/src/jit/Lowering.h	2021-03-01 21:17:56.000000000 +0300
+++ mozilla/js/src/jit/Lowering.h	2022-02-02 20:44:23.114722986 +0300
@@ -295,6 +295,7 @@ class LIRGenerator : public LIRGenerator
     void visitIsArray(MIsArray* ins);
     void visitIsTypedArray(MIsTypedArray* ins);
     void visitIsObject(MIsObject* ins);
+    void visitIsNullOrUndefined(MIsNullOrUndefined* ins);
     void visitHasClass(MHasClass* ins);
     void visitObjectClassToString(MObjectClassToString* ins);
     void visitWasmAddOffset(MWasmAddOffset* ins);
diff -Nrup mozilla-OLD/js/src/jit/MIR.h mozilla/js/src/jit/MIR.h
--- mozilla-OLD/js/src/jit/MIR.h	2022-02-02 18:46:49.487446679 +0300
+++ mozilla/js/src/jit/MIR.h	2022-02-02 20:44:23.117722965 +0300
@@ -13479,6 +13479,29 @@ class MIsObject
     }
 };
 
+class MIsNullOrUndefined
+    : public MUnaryInstruction,
+      public BoxInputsPolicy::Data
+{
+    explicit MIsNullOrUndefined(MDefinition* value)
+        : MUnaryInstruction(classOpcode, value) {
+      setResultType(MIRType::Boolean);
+      setMovable();
+    }
+  
+  public:
+    INSTRUCTION_HEADER(IsNullOrUndefined)
+    TRIVIAL_NEW_WRAPPERS
+    NAMED_OPERANDS((0, value))
+  
+    bool congruentTo(const MDefinition* ins) const override {
+        return congruentIfOperandsEqual(ins);
+    }
+    AliasSet getAliasSet() const override {
+        return AliasSet::None();
+    }
+};
+
 class MHasClass
     : public MUnaryInstruction,
       public SingleObjectPolicy::Data
diff -Nrup mozilla-OLD/js/src/jit/MOpcodes.h mozilla/js/src/jit/MOpcodes.h
--- mozilla-OLD/js/src/jit/MOpcodes.h	2022-01-25 01:04:29.000000000 +0300
+++ mozilla/js/src/jit/MOpcodes.h	2022-02-02 20:44:23.117722965 +0300
@@ -280,6 +280,7 @@ namespace jit {
     _(IsArray)                                                              \
     _(IsTypedArray)                                                         \
     _(IsObject)                                                             \
+    _(IsNullOrUndefined)                                                    \
     _(HasClass)                                                             \
     _(ObjectClassToString)                                                  \
     _(CopySign)                                                             \
diff -Nrup mozilla-OLD/js/src/jit/shared/LIR-shared.h mozilla/js/src/jit/shared/LIR-shared.h
--- mozilla-OLD/js/src/jit/shared/LIR-shared.h	2022-01-25 01:04:29.000000000 +0300
+++ mozilla/js/src/jit/shared/LIR-shared.h	2022-02-02 20:44:23.119722951 +0300
@@ -8092,6 +8092,21 @@ class LIsObjectAndBranch : public LContr
     }
 };
 
+class LIsNullOrUndefined : public LInstructionHelper<1, BOX_PIECES, 0>
+{
+  public:
+    LIR_HEADER(IsNullOrUndefined);
+    static const size_t Input = 0;
+  
+    explicit LIsNullOrUndefined(const LBoxAllocation& input) {
+        setBoxOperand(Input, input);
+    }
+  
+    MIsNullOrUndefined* mir() const {
+        return mir_->toIsNullOrUndefined();
+    }
+};
+
 class LHasClass : public LInstructionHelper<1, 1, 0>
 {
   public:
diff -Nrup mozilla-OLD/js/src/jit/shared/LOpcodes-shared.h mozilla/js/src/jit/shared/LOpcodes-shared.h
--- mozilla-OLD/js/src/jit/shared/LOpcodes-shared.h	2021-03-01 21:17:56.000000000 +0300
+++ mozilla/js/src/jit/shared/LOpcodes-shared.h	2022-02-02 20:44:23.119722951 +0300
@@ -395,6 +395,7 @@
     _(IsTypedArray)                 \
     _(IsObject)                     \
     _(IsObjectAndBranch)            \
+    _(IsNullOrUndefined)            \
     _(HasClass)                     \
     _(ObjectClassToString)          \
     _(RecompileCheck)               \
diff -Nrup mozilla-OLD/js/src/js.msg mozilla/js/src/js.msg
--- mozilla-OLD/js/src/js.msg	2022-02-02 18:46:49.494446631 +0300
+++ mozilla/js/src/js.msg	2022-02-02 20:44:23.120722944 +0300
@@ -190,6 +190,7 @@ MSG_DEF(JSMSG_AWAIT_IN_DEFAULT,        0
 MSG_DEF(JSMSG_AWAIT_OUTSIDE_ASYNC,     0, JSEXN_SYNTAXERR, "await is only valid in async functions and async generators")
 MSG_DEF(JSMSG_BAD_ARROW_ARGS,          0, JSEXN_SYNTAXERR, "invalid arrow-function arguments (parentheses around the arrow-function may help)")
 MSG_DEF(JSMSG_BAD_BINDING,             1, JSEXN_SYNTAXERR, "redefining {0} is deprecated")
+MSG_DEF(JSMSG_BAD_COALESCE_MIXING,     0, JSEXN_SYNTAXERR, "cannot use `??` unparenthesized within `||` and `&&` expressions")
 MSG_DEF(JSMSG_BAD_CONST_DECL,          0, JSEXN_SYNTAXERR, "missing = in const declaration")
 MSG_DEF(JSMSG_BAD_CONTINUE,            0, JSEXN_SYNTAXERR, "continue must be inside loop")
 MSG_DEF(JSMSG_BAD_DESTRUCT_ASS,        0, JSEXN_REFERENCEERR, "invalid destructuring assignment operator")
diff -Nrup mozilla-OLD/js/src/jsopcode.cpp mozilla/js/src/jsopcode.cpp
--- mozilla-OLD/js/src/jsopcode.cpp	2022-01-25 01:04:29.000000000 +0300
+++ mozilla/js/src/jsopcode.cpp	2022-02-02 20:44:23.120722944 +0300
@@ -689,6 +689,7 @@ BytecodeParser::simulateOp(JSOp op, uint
       case JSOP_INITGLEXICAL:
       case JSOP_INITLEXICAL:
       case JSOP_OR:
+      case JSOP_COALESCE:
       case JSOP_SETALIASEDVAR:
       case JSOP_SETARG:
       case JSOP_SETINTRINSIC:
diff -Nrup mozilla-OLD/js/src/jsopcodeinlines.h mozilla/js/src/jsopcodeinlines.h
--- mozilla-OLD/js/src/jsopcodeinlines.h	2020-04-01 14:01:50.000000000 +0300
+++ mozilla/js/src/jsopcodeinlines.h	2022-02-02 20:44:23.121722937 +0300
@@ -23,6 +23,7 @@ GetDefCount(jsbytecode* pc)
     switch (JSOp(*pc)) {
       case JSOP_OR:
       case JSOP_AND:
+      case JSOP_COALESCE:
         return 1;
       case JSOP_PICK:
       case JSOP_UNPICK:
diff -Nrup mozilla-OLD/js/src/vm/Interpreter.cpp mozilla/js/src/vm/Interpreter.cpp
--- mozilla-OLD/js/src/vm/Interpreter.cpp	2022-02-02 18:46:49.509446528 +0300
+++ mozilla/js/src/vm/Interpreter.cpp	2022-02-02 20:44:23.122722930 +0300
@@ -2227,6 +2227,15 @@ CASE(JSOP_OR)
 }
 END_CASE(JSOP_OR)
 
+CASE(JSOP_COALESCE)
+{
+    MutableHandleValue res = REGS.stackHandleAt(-1);
+    bool cond = !res.isNullOrUndefined();
+    if (cond)
+        ADVANCE_AND_DISPATCH(GET_JUMP_OFFSET(REGS.pc));
+}
+END_CASE(JSOP_COALESCE)
+
 CASE(JSOP_AND)
 {
     bool cond = ToBoolean(REGS.stackHandleAt(-1));
diff -Nrup mozilla-OLD/js/src/vm/Opcodes.h mozilla/js/src/vm/Opcodes.h
--- mozilla-OLD/js/src/vm/Opcodes.h	2022-01-25 01:04:29.000000000 +0300
+++ mozilla/js/src/vm/Opcodes.h	2022-02-02 20:44:23.123722923 +0300
@@ -2353,14 +2353,23 @@
      *   Stack: callee, this, args[0], ..., args[argc-1] => rval
      *   nuses: (argc+2)
      */ \
-    macro(JSOP_CALL_IGNORES_RV, 231, "call-ignores-rv", NULL, 3, -1, 1, JOF_UINT16|JOF_INVOKE|JOF_TYPESET)
+    macro(JSOP_CALL_IGNORES_RV, 231, "call-ignores-rv", NULL, 3, -1, 1, JOF_UINT16|JOF_INVOKE|JOF_TYPESET) \
+    /*
+     * If the value on top of the stack is not null or undefined, jumps to a 32-bit offset from the
+     * current bytecode.
+     *
+     *   Category: Statements
+     *   Type: Jumps
+     *   Operands: int32_t offset
+     *   Stack: cond => cond
+     */ \
+    macro(JSOP_COALESCE, 232, "coalesce", NULL, 5, 1, 1, JOF_JUMP|JOF_DETECTING)
 
 /*
  * In certain circumstances it may be useful to "pad out" the opcode space to
  * a power of two.  Use this macro to do so.
  */
 #define FOR_EACH_TRAILING_UNUSED_OPCODE(macro) \
-    macro(232) \
     macro(233) \
     macro(234) \
     macro(235) \
