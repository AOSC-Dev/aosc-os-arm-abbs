
  Revert https://bugzilla.mozilla.org/show_bug.cgi?id=1391154, since it causes issues
  with github-wc-polyfill addon, see
    https://github.com/JustOff/github-wc-polyfill/issues/44#issuecomment-1044298141
  and
    https://github.com/JustOff/github-wc-polyfill/issues/44#issuecomment-1043176073
  for more info.

  Besides that, the old behavior is more in line with the formal specifications
  (rather than Chrome behaviour).


--- mozilla/dom/base/DOMIntersectionObserver.cpp.orig	2022-02-21 02:07:48.110149632 +0300
+++ mozilla/dom/base/DOMIntersectionObserver.cpp	2022-02-23 02:51:07.883008786 +0300
@@ -433,35 +433,37 @@ DOMIntersectionObserver::Update(nsIDocum
     int64_t targetArea =
       (int64_t) targetRect.Width() * (int64_t) targetRect.Height();
     int64_t intersectionArea = !intersectionRect ? 0 :
       (int64_t) intersectionRect->Width() *
       (int64_t) intersectionRect->Height();
 
     double intersectionRatio;
     if (targetArea > 0.0) {
-      intersectionRatio =
-        std::min((double) intersectionArea / (double) targetArea, 1.0);
+      intersectionRatio = (double) intersectionArea / (double) targetArea;
     } else {
       intersectionRatio = intersectionRect.isSome() ? 1.0 : 0.0;
     }
 
     int32_t threshold = -1;
-    if (intersectionRect.isSome()) {
-      // Spec: "Let thresholdIndex be the index of the first entry in
-      // observer.thresholds whose value is greater than intersectionRatio."
-      threshold = mThresholds.IndexOfFirstElementGt(intersectionRatio);
-      if (threshold == 0) {
-        // Per the spec, we should leave threshold at 0 and distinguish between
-        // "less than all thresholds and intersecting" and "not intersecting"
-        // (queuing observer entries as both cases come to pass). However,
-        // neither Chrome nor the WPT tests expect this behavior, so treat these
-        // two cases as one.
-        threshold = -1;
+    if (intersectionRatio > 0.0) {
+      if (intersectionRatio >= 1.0) {
+        intersectionRatio = 1.0;
+        threshold = (int32_t)mThresholds.Length();
+      } else {
+        for (size_t k = 0; k < mThresholds.Length(); ++k) {
+          if (mThresholds[k] <= intersectionRatio) {
+            threshold = (int32_t)k + 1;
+          } else {
+            break;
+          }
+        }
       }
+    } else if (intersectionRect.isSome()) {
+      threshold = 0;
     }
 
     if (target->UpdateIntersectionObservation(this, threshold)) {
       QueueIntersectionObserverEntry(
         target, time,
         isInSimilarOriginBrowsingContext ==
           BrowsingContextInfo::DifferentOriginBrowsingContext ?
           Nothing() : Some(rootIntersectionRect),
