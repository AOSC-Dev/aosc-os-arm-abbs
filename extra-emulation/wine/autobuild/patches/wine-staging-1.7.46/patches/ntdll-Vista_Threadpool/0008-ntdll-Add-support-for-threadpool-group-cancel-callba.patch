From 624d6ab353109a57dfe0d80053795ef64b6adc3e Mon Sep 17 00:00:00 2001
From: Sebastian Lackner <sebastian@fds-team.de>
Date: Wed, 4 Mar 2015 06:57:53 +0100
Subject: ntdll: Add support for threadpool group cancel callback.

---
 dlls/ntdll/threadpool.c | 17 ++++++++++++++---
 1 file changed, 14 insertions(+), 3 deletions(-)

diff --git a/dlls/ntdll/threadpool.c b/dlls/ntdll/threadpool.c
index 1989d56..e30d45c 100644
--- a/dlls/ntdll/threadpool.c
+++ b/dlls/ntdll/threadpool.c
@@ -170,6 +170,7 @@ struct threadpool_object
     struct threadpool       *pool;
     struct threadpool_group *group;
     PVOID                   userdata;
+    PTP_CLEANUP_GROUP_CANCEL_CALLBACK group_cancel_callback;
     /* information about the group, locked via .group->cs */
     struct list             group_entry;
     BOOL                    is_group_member;
@@ -1290,6 +1291,7 @@ static void tp_object_initialize( struct threadpool_object *object, struct threa
     object->pool                    = pool;
     object->group                   = NULL;
     object->userdata                = userdata;
+    object->group_cancel_callback   = NULL;
 
     memset( &object->group_entry, 0, sizeof(object->group_entry) );
     object->is_group_member         = FALSE;
@@ -1305,6 +1307,7 @@ static void tp_object_initialize( struct threadpool_object *object, struct threa
             FIXME("unsupported environment version %u\n", environment->Version);
 
         object->group = impl_from_TP_CLEANUP_GROUP( environment->CleanupGroup );
+        object->group_cancel_callback   = environment->CleanupGroupCancelCallback;
 
         WARN("environment not fully implemented yet\n");
     }
@@ -1377,7 +1380,7 @@ out:
     RtlLeaveCriticalSection( &pool->cs );
 }
 
-static void tp_object_cancel( struct threadpool_object *object )
+static void tp_object_cancel( struct threadpool_object *object, BOOL group_cancel, PVOID userdata )
 {
     struct threadpool *pool = object->pool;
     LONG pending_callbacks = 0;
@@ -1394,6 +1397,14 @@ static void tp_object_cancel( struct threadpool_object *object )
 
     RtlLeaveCriticalSection( &pool->cs );
 
+    /* Execute group cancellation callback if defined, and if this was actually a group cancel. */
+    if (pending_callbacks && group_cancel && object->group_cancel_callback)
+    {
+        TRACE( "executing group cancel callback %p(%p, %p)\n", object->group_cancel_callback, object, userdata );
+        object->group_cancel_callback( object, userdata );
+        TRACE( "callback %p returned\n", object->group_cancel_callback );
+    }
+
     /* Release references */
     while (pending_callbacks--)
         tp_object_release( object );
@@ -1673,7 +1684,7 @@ VOID WINAPI TpReleaseCleanupGroupMembers( TP_CLEANUP_GROUP *group, BOOL cancel_p
     {
         LIST_FOR_EACH_ENTRY( object, &members, struct threadpool_object, group_entry )
         {
-            tp_object_cancel( object );
+            tp_object_cancel( object, TRUE, userdata );
         }
     }
 
@@ -1791,7 +1802,7 @@ VOID WINAPI TpWaitForWork( TP_WORK *work, BOOL cancel_pending )
     if (this)
     {
         if (cancel_pending)
-            tp_object_cancel( this );
+            tp_object_cancel( this, FALSE, NULL );
         tp_object_wait( this );
     }
 }
-- 
2.3.3

