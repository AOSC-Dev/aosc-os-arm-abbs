From e839658d6894708da857b1ab56d8ef608b240f67 Mon Sep 17 00:00:00 2001
From: Huacai Chen <chenhc@lemote.com>
Date: Wed, 12 Jul 2017 16:30:55 +0800
Subject: [PATCH 136/163] AOSCOS: MIPS: Loongson: Make CPUFreq usable for
 Loongson-3

Loongson-3A/3B support frequency scaling. But due to hardware
limitation, Loongson-3A's frequency scaling is not independent for
each core, we suggest enable Loongson-3A's CPUFreq only when there is
one core online. Loongson-3B can adjust frequency independently for
each core, so it can be always enabled.

Each package has only one register (ChipConfig or FreqCtrl) to control
frequency, so we need spinlocks to protect register access for multi-
cores. However, we cannot use spinlock when a core becomes into "wait"
status (frequency = 0), so we only enable "wait" when there is one core
in a package online.

arch/mips/kernel/smp.c is modified to guarantee udelay_val has the
correct value while both CPU hotplug and CPUFreq are enabled.

[Mingcong Bai: Resolved merge conflicts in the following...

  arch/mips/include/asm/mach-loongson64/loongson.h
  arch/mips/kernel/smp.c
  arch/mips/loongson64/Kconfig
  arch/mips/loongson64/clock.c
  arch/mips/loongson64/loongson-3/Makefile =>
  arch/mips/loongson64/Makefile
  drivers/cpufreq/Kconfig
  drivers/cpufreq/Makefile

  Additionally, made a fork for drivers/cpufreq/loongson3_cpufreq.c =>
    drivers/cpufreq/mips_loongson3_cpufreq.c
    (CONFIG_LOONGSON3_CPUFREQ => CONFIG_MIPS_LOONGSON3_CPUFREQ)

  Rename module to gs464_cpufreq to avoid confusion with loongson3_cpufreq
  (for LoongArch), also updated all function names, methods, and
  descriptions to reflect this change.

  Also make this driver a boolean (built-in or disabled), as
  `mips_clockevent_device' and `clockevents_update_freq' are not exposed
  as symbols (SGI IP30 clock module is also a non-tristate).
]

Signed-off-by: Huacai Chen <chenhc@lemote.com>
Signed-off-by: Mingcong Bai <jeffbai@aosc.io>
---
 arch/mips/Kconfig                             |   3 +
 arch/mips/include/asm/clock.h                 |  57 ++++++
 .../include/asm/mach-loongson64/loongson.h    |   5 +
 arch/mips/kernel/smp.c                        |   3 +-
 arch/mips/loongson64/Makefile                 |   2 +-
 arch/mips/loongson64/clock.c                  | 170 ++++++++++++++++
 drivers/cpufreq/Kconfig                       |  12 ++
 drivers/cpufreq/Makefile                      |   2 +
 drivers/cpufreq/gs464_cpufreq.c               | 190 ++++++++++++++++++
 9 files changed, 442 insertions(+), 2 deletions(-)
 create mode 100644 arch/mips/include/asm/clock.h
 create mode 100644 arch/mips/loongson64/clock.c
 create mode 100644 drivers/cpufreq/gs464_cpufreq.c

diff --git a/arch/mips/Kconfig b/arch/mips/Kconfig
index 467b10f4361a..64928f99d3e7 100644
--- a/arch/mips/Kconfig
+++ b/arch/mips/Kconfig
@@ -480,6 +480,7 @@ config MACH_LOONGSON64
 	select CEVT_R4K
 	select SYNC_R4K
 	select FORCE_PCI
+	select HAVE_CLK
 	select ISA
 	select I8259
 	select IRQ_MIPS_CPU
@@ -502,6 +503,8 @@ config MACH_LOONGSON64
 	select USE_OF
 	select BUILTIN_DTB
 	select PCI_HOST_GENERIC
+	select CPU_SUPPORTS_CPUFREQ
+	select MIPS_EXTERNAL_TIMER
 	help
 	  This enables the support of Loongson-2/3 family of machines.
 
diff --git a/arch/mips/include/asm/clock.h b/arch/mips/include/asm/clock.h
new file mode 100644
index 000000000000..db72b78e0b2f
--- /dev/null
+++ b/arch/mips/include/asm/clock.h
@@ -0,0 +1,57 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef __ASM_MIPS_CLOCK_H
+#define __ASM_MIPS_CLOCK_H
+
+#include <linux/kref.h>
+#include <linux/list.h>
+#include <linux/seq_file.h>
+#include <linux/clk.h>
+
+struct clk;
+
+struct clk_ops {
+	void (*init) (struct clk *clk);
+	void (*enable) (struct clk *clk);
+	void (*disable) (struct clk *clk);
+	void (*recalc) (struct clk *clk);
+	int (*set_rate) (struct clk *clk, unsigned long rate, int algo_id);
+	long (*round_rate) (struct clk *clk, unsigned long rate);
+};
+
+struct clk {
+	struct list_head node;
+	const char *name;
+	int id;
+	struct module *owner;
+
+	struct clk *parent;
+	struct clk_ops *ops;
+
+	struct kref kref;
+
+	unsigned long rate;
+	unsigned long flags;
+};
+
+#define CLK_ALWAYS_ENABLED	(1 << 0)
+#define CLK_RATE_PROPAGATES	(1 << 1)
+
+int clk_init(void);
+
+int __clk_enable(struct clk *);
+void __clk_disable(struct clk *);
+
+void clk_recalc_rate(struct clk *);
+
+int clk_register(struct clk *);
+void clk_unregister(struct clk *);
+
+struct clk *gs464_cpu_clk_get(int cpu);
+struct clk *gs464_clk_get(struct device *dev, const char *id);
+void gs464_propagate_rate(struct clk *clk);
+unsigned long gs464_clk_get_rate(struct clk *clk);
+int gs464_clk_set_rate(struct clk *clk, unsigned long rate);
+long gs464_clk_round_rate(struct clk *clk, unsigned long rate);
+int gs464_clock_init(void);
+
+#endif				/* __ASM_MIPS_CLOCK_H */
diff --git a/arch/mips/include/asm/mach-loongson64/loongson.h b/arch/mips/include/asm/mach-loongson64/loongson.h
index f7c3ab6d724e..70399b6cd2ae 100644
--- a/arch/mips/include/asm/mach-loongson64/loongson.h
+++ b/arch/mips/include/asm/mach-loongson64/loongson.h
@@ -263,4 +263,9 @@ extern u64 loongson_freqctrl[MAX_PACKAGES];
 #define LOONGSON_PCIMAP_WIN(WIN, ADDR)	\
 	((((ADDR)>>26) & LOONGSON_PCIMAP_PCIMAP_LO0) << ((WIN)*6))
 
+#ifdef CONFIG_CPU_SUPPORTS_CPUFREQ
+#include <linux/cpufreq.h>
+extern struct cpufreq_frequency_table gs464_clockmod_table[];
+#endif
+
 #endif /* __ASM_MACH_LOONGSON64_LOONGSON_H */
diff --git a/arch/mips/kernel/smp.c b/arch/mips/kernel/smp.c
index 39e193cad2b9..1d07dd74a94c 100644
--- a/arch/mips/kernel/smp.c
+++ b/arch/mips/kernel/smp.c
@@ -368,7 +368,8 @@ asmlinkage void start_secondary(void)
 	 */
 
 	calibrate_delay();
-	cpu_data[cpu].udelay_val = loops_per_jiffy;
+	if (!cpu_data[cpu].udelay_val)
+		cpu_data[cpu].udelay_val = loops_per_jiffy;
 
 	set_cpu_sibling_map(cpu);
 	set_cpu_core_map(cpu);
diff --git a/arch/mips/loongson64/Makefile b/arch/mips/loongson64/Makefile
index ba083beb6ca8..79bd31a35e81 100644
--- a/arch/mips/loongson64/Makefile
+++ b/arch/mips/loongson64/Makefile
@@ -4,7 +4,7 @@
 #
 obj-$(CONFIG_MACH_LOONGSON64) += cop2-ex.o dma.o \
 				setup.o init.o env.o time.o reset.o \
-				constant_timer.o \
+				clock.o constant_timer.o \
 
 obj-$(CONFIG_SMP)	+= smp.o
 obj-$(CONFIG_NUMA)	+= numa.o
diff --git a/arch/mips/loongson64/clock.c b/arch/mips/loongson64/clock.c
new file mode 100644
index 000000000000..09d3c28a23ab
--- /dev/null
+++ b/arch/mips/loongson64/clock.c
@@ -0,0 +1,170 @@
+/*
+ * Copyright (C) 2008 - 2014 Lemote Inc.
+ * Author: Yan Hua, yanh@lemote.com
+ *         Chen Huacai, chenhc@lemote.com
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ */
+
+#include <linux/module.h>
+#include <linux/err.h>
+#include <linux/slab.h>
+#include <linux/cpufreq.h>
+#include <linux/platform_device.h>
+
+#include <asm/clock.h>
+
+#include <loongson.h>
+
+static LIST_HEAD(clock_list);
+static DEFINE_SPINLOCK(clock_lock);
+static DEFINE_MUTEX(clock_list_sem);
+
+/* Minimum CLK support */
+enum {
+	DC_ZERO, DC_12PT, DC_25PT, DC_37PT, DC_50PT, DC_62PT,
+	DC_75PT, DC_87PT, DC_DISABLE, DC_RESV
+};
+
+struct cpufreq_frequency_table gs464_clockmod_table[] = {
+	{0, DC_ZERO, CPUFREQ_ENTRY_INVALID},
+	{0, DC_12PT, 0},
+	{0, DC_25PT, 0},
+	{0, DC_37PT, 0},
+	{0, DC_50PT, 0},
+	{0, DC_62PT, 0},
+	{0, DC_75PT, 0},
+	{0, DC_87PT, 0},
+	{0, DC_DISABLE, 0},
+	{0, DC_RESV, CPUFREQ_TABLE_END},
+};
+
+static struct clk cpu_clks[NR_CPUS];
+static char clk_names[NR_CPUS][10];
+
+struct clk *gs464_cpu_clk_get(int cpu)
+{
+        return &cpu_clks[cpu];
+}
+
+struct clk *gs464_clk_get(struct device *dev, const char *id)
+{
+	int i;
+	struct clk *clk;
+
+	if (!id)
+		return NULL;
+
+	for_each_possible_cpu(i) {
+		clk = &cpu_clks[i];
+		if (strcmp(clk->name, id) == 0)
+			return clk;
+	}
+
+	return NULL;
+}
+
+void gs464_propagate_rate(struct clk *clk)
+{
+	struct clk *clkp;
+
+	list_for_each_entry(clkp, &clock_list, node) {
+		if (likely(clkp->parent != clk))
+			continue;
+		if (likely(clkp->ops && clkp->ops->recalc))
+			clkp->ops->recalc(clkp);
+		if (unlikely(clkp->flags & CLK_RATE_PROPAGATES))
+			gs464_propagate_rate(clkp);
+	}
+}
+
+unsigned long gs464_clk_get_rate(struct clk *clk)
+{
+	if (!clk)
+		return 0;
+
+	return (unsigned long)clk->rate;
+}
+
+int gs464_clk_set_rate(struct clk *clk, unsigned long rate)
+{
+	int regval, ret = 0;
+	struct cpufreq_frequency_table *pos;
+	int cpu = clk - cpu_clks;
+	uint64_t core_id = cpu_core(&cpu_data[cpu]);
+	uint64_t package_id = cpu_data[cpu].package;
+
+	if (likely(clk->ops && clk->ops->set_rate)) {
+		unsigned long flags;
+
+		spin_lock_irqsave(&clock_lock, flags);
+		ret = clk->ops->set_rate(clk, rate, 0);
+		spin_unlock_irqrestore(&clock_lock, flags);
+	}
+
+	if (unlikely(clk->flags & CLK_RATE_PROPAGATES))
+		gs464_propagate_rate(clk);
+
+	cpufreq_for_each_valid_entry(pos, gs464_clockmod_table)
+		if (rate == pos->frequency)
+			break;
+	if (rate != pos->frequency)
+		return -ENOTSUPP;
+
+	clk->rate = rate;
+
+	if ((read_c0_prid() & 0xf) == PRID_REV_LOONGSON3A_R1) {
+		regval = LOONGSON_CHIPCFG(package_id);
+		regval = (regval & ~0x7) | (pos->driver_data - 1);
+		LOONGSON_CHIPCFG(package_id) = regval;
+	} else {
+		regval = LOONGSON_FREQCTRL(package_id);
+		regval = (regval & ~(0x7 << (core_id*4))) |
+			((pos->driver_data - 1) << (core_id*4));
+		LOONGSON_FREQCTRL(package_id) = regval;
+	}
+
+	return ret;
+}
+
+long gs464_clk_round_rate(struct clk *clk, unsigned long rate)
+{
+	if (likely(clk->ops && clk->ops->round_rate)) {
+		unsigned long flags, rounded;
+
+		spin_lock_irqsave(&clock_lock, flags);
+		rounded = clk->ops->round_rate(clk, rate);
+		spin_unlock_irqrestore(&clock_lock, flags);
+
+		return rounded;
+	}
+
+	return rate;
+}
+
+int gs464_clock_init(void)
+{
+	int i;
+
+	for_each_possible_cpu(i) {
+		sprintf(clk_names[i], "cpu%d_clk", i);
+		cpu_clks[i].name = clk_names[i];
+		cpu_clks[i].flags = CLK_ALWAYS_ENABLED | CLK_RATE_PROPAGATES;
+		cpu_clks[i].rate = cpu_clock_freq / 1000;
+	}
+
+	/* clock table init */
+	for (i = 1;
+	     (gs464_clockmod_table[i].frequency != CPUFREQ_TABLE_END);
+	     i++)
+		gs464_clockmod_table[i].frequency = ((cpu_clock_freq / 1000) * i) / 8;
+
+	return 0;
+}
+arch_initcall(gs464_clock_init);
+
+MODULE_AUTHOR("Huacai Chen <chenhc@lemote.com>");
+MODULE_DESCRIPTION("CPUFreq driver for GS464 (MIPS-based Loongson-3) processors");
+MODULE_LICENSE("GPL");
diff --git a/drivers/cpufreq/Kconfig b/drivers/cpufreq/Kconfig
index 92a83a9bb2e1..41019014a499 100644
--- a/drivers/cpufreq/Kconfig
+++ b/drivers/cpufreq/Kconfig
@@ -272,6 +272,18 @@ config LOONGSON2_CPUFREQ
 	  Loongson2F and its successors support this feature.
 
 	  If in doubt, say N.
+
+config GS464_CPUFREQ
+        bool "GS464 (MIPS-based Loongson-3) CPUFreq Driver"
+        depends on CPU_LOONGSON64 && MIPS
+        help
+          This option adds a CPUFreq driver for GS464 (MIPS-based
+          Loongson-3) processors which support software configurable CPU
+          frequency.
+
+          For details, take a look at <file:Documentation/cpu-freq/>.
+
+          If in doubt, say N.
 endif
 
 if LOONGARCH
diff --git a/drivers/cpufreq/Makefile b/drivers/cpufreq/Makefile
index d35a28dd9463..b604ee643786 100644
--- a/drivers/cpufreq/Makefile
+++ b/drivers/cpufreq/Makefile
@@ -102,8 +102,10 @@ obj-$(CONFIG_POWERNV_CPUFREQ)		+= powernv-cpufreq.o
 ##################################################################################
 # Other platform drivers
 obj-$(CONFIG_BMIPS_CPUFREQ)		+= bmips-cpufreq.o
+obj-$(CONFIG_GS464_CPUFREQ)		+= gs464_cpufreq.o
 obj-$(CONFIG_LOONGSON2_CPUFREQ)		+= loongson2_cpufreq.o
 obj-$(CONFIG_LOONGSON3_CPUFREQ)		+= loongson3_cpufreq.o
+obj-$(CONFIG_LOONGSON1_CPUFREQ)		+= loongson1-cpufreq.o
 obj-$(CONFIG_SH_CPU_FREQ)		+= sh-cpufreq.o
 obj-$(CONFIG_SPARC_US2E_CPUFREQ)	+= sparc-us2e-cpufreq.o
 obj-$(CONFIG_SPARC_US3_CPUFREQ)		+= sparc-us3-cpufreq.o
diff --git a/drivers/cpufreq/gs464_cpufreq.c b/drivers/cpufreq/gs464_cpufreq.c
new file mode 100644
index 000000000000..0066e828170b
--- /dev/null
+++ b/drivers/cpufreq/gs464_cpufreq.c
@@ -0,0 +1,190 @@
+/*
+ * CPUFreq driver for the loongson-3 processors
+ *
+ * All revisions of Loongson-3 processor support this feature.
+ *
+ * Copyright (C) 2008 - 2014 Lemote Inc.
+ * Author: Yan Hua, yanh@lemote.com
+ *         Chen Huacai, chenhc@lemote.com
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ */
+#include <linux/module.h>
+#include <linux/time.h>
+#include <linux/delay.h>
+#include <linux/cpufreq.h>
+#include <linux/platform_device.h>
+#include <asm/idle.h>
+#include <asm/clock.h>
+#include <asm/cevt-r4k.h>
+
+#include <loongson.h>
+
+static spinlock_t cpufreq_reg_lock[MAX_PACKAGES];
+
+extern struct clk *gs464_cpu_clk_get(int cpu);
+
+static int gs464_cpu_freq_notifier(struct notifier_block *nb,
+					unsigned long val, void *data);
+
+static struct notifier_block gs464_cpufreq_notifier_block = {
+	.notifier_call = gs464_cpu_freq_notifier
+};
+
+#ifdef CONFIG_SMP
+static int gs464_cpu_freq_notifier(struct notifier_block *nb,
+					unsigned long val, void *data)
+{
+	unsigned long cpu;
+	struct clock_event_device *cd;
+	struct cpufreq_freqs *freqs = (struct cpufreq_freqs *)data;
+
+	if (val != CPUFREQ_POSTCHANGE)
+		return 0;
+
+	for_each_cpu(cpu, freqs->policy->cpus) {
+		cd = &per_cpu(mips_clockevent_device, cpu);
+
+		if (cpu == smp_processor_id())
+			clockevents_update_freq(cd, freqs->new * 1000 / 2);
+		else {
+			clockevents_calc_mult_shift(cd, freqs->new * 1000 / 2, 4);
+			cd->min_delta_ns = clockevent_delta2ns(cd->min_delta_ticks, cd);
+			cd->max_delta_ns = clockevent_delta2ns(cd->max_delta_ticks, cd);
+		}
+	}
+
+	return 0;
+}
+#else
+static int gs464_cpu_freq_notifier(struct notifier_block *nb,
+					unsigned long val, void *data)
+{
+	struct cpufreq_freqs *freqs = (struct cpufreq_freqs *)data;
+	struct clock_event_device *cd = &per_cpu(mips_clockevent_device, 0);
+
+	if (val == CPUFREQ_POSTCHANGE)
+		clockevents_update_freq(cd, freqs->new * 1000 / 2);
+
+	return 0;
+}
+#endif
+
+static unsigned int gs464_cpufreq_get(unsigned int cpu)
+{
+	return gs464_clk_get_rate(gs464_cpu_clk_get(cpu));
+}
+
+/*
+ * Here we notify other drivers of the proposed change and the final change.
+ */
+static int gs464_cpufreq_target(struct cpufreq_policy *policy,
+				     unsigned int index)
+{
+	unsigned int freq;
+	unsigned int cpu = policy->cpu;
+	unsigned int package = cpu_data[cpu].package;
+
+	if (!cpu_online(cpu))
+		return -ENODEV;
+
+	freq =
+	    ((cpu_clock_freq / 1000) *
+	     gs464_clockmod_table[index].driver_data) / 8;
+
+	/* setting the cpu frequency */
+	spin_lock(&cpufreq_reg_lock[package]);
+	gs464_clk_set_rate(policy->clk, freq);
+	spin_unlock(&cpufreq_reg_lock[package]);
+
+	return 0;
+}
+
+static int gs464_cpufreq_cpu_init(struct cpufreq_policy *policy)
+{
+	if (!cpu_online(policy->cpu))
+		return -ENODEV;
+
+	policy->clk = gs464_cpu_clk_get(policy->cpu);
+	policy->cur = gs464_cpufreq_get(policy->cpu);
+
+	policy->cpuinfo.transition_latency = 1000;
+	policy->freq_table = gs464_clockmod_table;
+
+	/* Loongson-3A R1: all cores in a package share one clock */
+	if ((read_c0_prid() & 0xf) == PRID_REV_LOONGSON3A_R1)
+		cpumask_copy(policy->cpus, topology_core_cpumask(policy->cpu));
+
+	return 0;
+}
+
+static void gs464_cpufreq_exit(struct cpufreq_policy *policy)
+{
+}
+
+static struct cpufreq_driver gs464_cpufreq_driver = {
+	.name = "loongson3",
+	.init = gs464_cpufreq_cpu_init,
+	.verify = cpufreq_generic_frequency_table_verify,
+	.target_index = gs464_cpufreq_target,
+	.get = gs464_cpufreq_get,
+	.exit = gs464_cpufreq_exit,
+	.attr = cpufreq_generic_attr,
+};
+
+static struct platform_device_id platform_device_ids[] = {
+	{
+		.name = "gs464_cpufreq",
+	},
+	{}
+};
+
+MODULE_DEVICE_TABLE(platform, platform_device_ids);
+
+static struct platform_driver platform_driver = {
+	.driver = {
+		.name = "gs464_cpufreq",
+		.owner = THIS_MODULE,
+	},
+	.id_table = platform_device_ids,
+};
+
+static int __init cpufreq_init(void)
+{
+	int i, ret;
+
+	/* Register platform stuff */
+	ret = platform_driver_register(&platform_driver);
+	if (ret)
+		return ret;
+
+	pr_info("cpufreq: Loongson-3 CPU frequency driver.\n");
+
+	for (i = 0; i < MAX_PACKAGES; i++)
+		spin_lock_init(&cpufreq_reg_lock[i]);
+
+	cpufreq_register_notifier(&gs464_cpufreq_notifier_block,
+				  CPUFREQ_TRANSITION_NOTIFIER);
+
+	ret = cpufreq_register_driver(&gs464_cpufreq_driver);
+
+	return ret;
+}
+
+static void __exit cpufreq_exit(void)
+{
+	cpufreq_unregister_driver(&gs464_cpufreq_driver);
+	cpufreq_unregister_notifier(&gs464_cpufreq_notifier_block,
+				    CPUFREQ_TRANSITION_NOTIFIER);
+
+	platform_driver_unregister(&platform_driver);
+}
+
+module_init(cpufreq_init);
+module_exit(cpufreq_exit);
+
+MODULE_AUTHOR("Huacai Chen <chenhc@lemote.com>");
+MODULE_DESCRIPTION("CPUFreq driver for GS464 (MIPS-based Loongson-3) processors");
+MODULE_LICENSE("GPL");
-- 
2.47.1

